
out/main.elf:     file format elf32-littlearm


Disassembly of section .text:

08000000 <g_pfnVectors>:
 8000000:	00 00 02 20 41 37 00 08 89 01 00 08 95 01 00 08     ... A7..........
 8000010:	9d 01 00 08 a5 01 00 08 ad 01 00 08 00 00 00 00     ................
	...
 800002c:	a1 0a 00 08 b5 01 00 08 00 00 00 00 d5 0b 00 08     ................
 800003c:	25 0c 00 08 9d 37 00 08 9d 37 00 08 9d 37 00 08     %....7...7...7..
 800004c:	9d 37 00 08 9d 37 00 08 9d 37 00 08 9d 37 00 08     .7...7...7...7..
 800005c:	9d 37 00 08 9d 37 00 08 9d 37 00 08 9d 37 00 08     .7...7...7...7..
 800006c:	9d 37 00 08 9d 37 00 08 9d 37 00 08 9d 37 00 08     .7...7...7...7..
 800007c:	9d 37 00 08 9d 37 00 08 9d 37 00 08 9d 37 00 08     .7...7...7...7..
 800008c:	9d 37 00 08 9d 37 00 08 9d 37 00 08 9d 37 00 08     .7...7...7...7..
 800009c:	9d 37 00 08 9d 37 00 08 9d 37 00 08 9d 37 00 08     .7...7...7...7..
 80000ac:	9d 37 00 08 9d 37 00 08 9d 37 00 08 9d 37 00 08     .7...7...7...7..
 80000bc:	9d 37 00 08 9d 37 00 08 9d 37 00 08 9d 37 00 08     .7...7...7...7..
 80000cc:	9d 37 00 08 9d 37 00 08 9d 37 00 08 9d 37 00 08     .7...7...7...7..
 80000dc:	9d 37 00 08 9d 37 00 08 9d 37 00 08 9d 37 00 08     .7...7...7...7..
 80000ec:	9d 37 00 08 9d 37 00 08 9d 37 00 08 9d 37 00 08     .7...7...7...7..
 80000fc:	9d 37 00 08 9d 37 00 08 9d 37 00 08 9d 37 00 08     .7...7...7...7..
 800010c:	9d 37 00 08 9d 37 00 08 9d 37 00 08 9d 37 00 08     .7...7...7...7..
 800011c:	9d 37 00 08 9d 37 00 08 9d 37 00 08 9d 37 00 08     .7...7...7...7..
 800012c:	9d 37 00 08 9d 37 00 08 9d 37 00 08 9d 37 00 08     .7...7...7...7..
 800013c:	9d 37 00 08 9d 37 00 08 9d 37 00 08 9d 37 00 08     .7...7...7...7..
 800014c:	9d 37 00 08 9d 37 00 08 9d 37 00 08 9d 37 00 08     .7...7...7...7..
 800015c:	9d 37 00 08 9d 37 00 08 9d 37 00 08 9d 37 00 08     .7...7...7...7..
 800016c:	9d 37 00 08 9d 37 00 08 9d 37 00 08 9d 37 00 08     .7...7...7...7..
 800017c:	9d 37 00 08 9d 37 00 08 9d 37 00 08                 .7...7...7..

08000188 <NMI_Handler>:
/******************************************************************************/
/*            Cortex-M4 Processor Exceptions Handlers                         */
/******************************************************************************/

void NMI_Handler(void)
{
 8000188:	b480      	push	{r7}
 800018a:	af00      	add	r7, sp, #0
}
 800018c:	46bd      	mov	sp, r7
 800018e:	bc80      	pop	{r7}
 8000190:	4770      	bx	lr
 8000192:	bf00      	nop

08000194 <HardFault_Handler>:

void HardFault_Handler(void)
{
 8000194:	b480      	push	{r7}
 8000196:	af00      	add	r7, sp, #0
  /* Go to infinite loop when Hard Fault exception occurs */
  while (1)
  {
  }
 8000198:	e7fe      	b.n	8000198 <HardFault_Handler+0x4>
 800019a:	bf00      	nop

0800019c <MemManage_Handler>:
}

void MemManage_Handler(void)
{
 800019c:	b480      	push	{r7}
 800019e:	af00      	add	r7, sp, #0
  /* Go to infinite loop when Memory Manage exception occurs */
  while (1)
  {
  }
 80001a0:	e7fe      	b.n	80001a0 <MemManage_Handler+0x4>
 80001a2:	bf00      	nop

080001a4 <BusFault_Handler>:
}

void BusFault_Handler(void)
{
 80001a4:	b480      	push	{r7}
 80001a6:	af00      	add	r7, sp, #0
  /* Go to infinite loop when Bus Fault exception occurs */
  while (1)
  {
  }
 80001a8:	e7fe      	b.n	80001a8 <BusFault_Handler+0x4>
 80001aa:	bf00      	nop

080001ac <UsageFault_Handler>:
}

void UsageFault_Handler(void)
{
 80001ac:	b480      	push	{r7}
 80001ae:	af00      	add	r7, sp, #0
  /* Go to infinite loop when Usage Fault exception occurs */
  while (1)
  {
  }
 80001b0:	e7fe      	b.n	80001b0 <UsageFault_Handler+0x4>
 80001b2:	bf00      	nop

080001b4 <DebugMon_Handler>:
//void SVC_Handler(void)
//{
//}

void DebugMon_Handler(void)
{
 80001b4:	b480      	push	{r7}
 80001b6:	af00      	add	r7, sp, #0
}
 80001b8:	46bd      	mov	sp, r7
 80001ba:	bc80      	pop	{r7}
 80001bc:	4770      	bx	lr
 80001be:	bf00      	nop

080001c0 <pvPortMalloc>:
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;										\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
 80001c0:	b580      	push	{r7, lr}
 80001c2:	b08a      	sub	sp, #40	; 0x28
 80001c4:	af00      	add	r7, sp, #0
 80001c6:	6078      	str	r0, [r7, #4]
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
 80001c8:	f04f 0300 	mov.w	r3, #0
 80001cc:	61fb      	str	r3, [r7, #28]

	vTaskSuspendAll();
 80001ce:	f001 ffdf 	bl	8002190 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
 80001d2:	f642 43a0 	movw	r3, #11424	; 0x2ca0
 80001d6:	f2c2 0301 	movt	r3, #8193	; 0x2001
 80001da:	681b      	ldr	r3, [r3, #0]
 80001dc:	2b00      	cmp	r3, #0
 80001de:	d133      	bne.n	8000248 <pvPortMalloc+0x88>
		{
			prvHeapInit();
 80001e0:	f642 4390 	movw	r3, #11408	; 0x2c90
 80001e4:	f2c2 0301 	movt	r3, #8193	; 0x2001
 80001e8:	f240 0290 	movw	r2, #144	; 0x90
 80001ec:	f2c2 0200 	movt	r2, #8192	; 0x2000
 80001f0:	601a      	str	r2, [r3, #0]
 80001f2:	f642 4390 	movw	r3, #11408	; 0x2c90
 80001f6:	f2c2 0301 	movt	r3, #8193	; 0x2001
 80001fa:	f04f 0200 	mov.w	r2, #0
 80001fe:	605a      	str	r2, [r3, #4]
 8000200:	f642 4398 	movw	r3, #11416	; 0x2c98
 8000204:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8000208:	f44f 3296 	mov.w	r2, #76800	; 0x12c00
 800020c:	605a      	str	r2, [r3, #4]
 800020e:	f642 4398 	movw	r3, #11416	; 0x2c98
 8000212:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8000216:	f04f 0200 	mov.w	r2, #0
 800021a:	601a      	str	r2, [r3, #0]
 800021c:	f240 0390 	movw	r3, #144	; 0x90
 8000220:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000224:	617b      	str	r3, [r7, #20]
 8000226:	697b      	ldr	r3, [r7, #20]
 8000228:	f44f 3296 	mov.w	r2, #76800	; 0x12c00
 800022c:	605a      	str	r2, [r3, #4]
 800022e:	697a      	ldr	r2, [r7, #20]
 8000230:	f642 4398 	movw	r3, #11416	; 0x2c98
 8000234:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8000238:	6013      	str	r3, [r2, #0]
			xHeapHasBeenInitialised = pdTRUE;
 800023a:	f642 43a0 	movw	r3, #11424	; 0x2ca0
 800023e:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8000242:	f04f 0201 	mov.w	r2, #1
 8000246:	601a      	str	r2, [r3, #0]
		}

		/* The wanted size is increased so it can contain a xBlockLink
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
 8000248:	687b      	ldr	r3, [r7, #4]
 800024a:	2b00      	cmp	r3, #0
 800024c:	d012      	beq.n	8000274 <pvPortMalloc+0xb4>
		{
			xWantedSize += heapSTRUCT_SIZE;
 800024e:	f244 239e 	movw	r3, #17054	; 0x429e
 8000252:	f6c0 0300 	movt	r3, #2048	; 0x800
 8000256:	881b      	ldrh	r3, [r3, #0]
 8000258:	687a      	ldr	r2, [r7, #4]
 800025a:	18d3      	adds	r3, r2, r3
 800025c:	607b      	str	r3, [r7, #4]

			/* Ensure that blocks are always aligned to the required number of bytes. */
			if( xWantedSize & portBYTE_ALIGNMENT_MASK )
 800025e:	687b      	ldr	r3, [r7, #4]
 8000260:	f003 0307 	and.w	r3, r3, #7
 8000264:	2b00      	cmp	r3, #0
 8000266:	d005      	beq.n	8000274 <pvPortMalloc+0xb4>
			{
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 8000268:	687b      	ldr	r3, [r7, #4]
 800026a:	f023 0307 	bic.w	r3, r3, #7
 800026e:	f103 0308 	add.w	r3, r3, #8
 8000272:	607b      	str	r3, [r7, #4]
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
 8000274:	687b      	ldr	r3, [r7, #4]
 8000276:	2b00      	cmp	r3, #0
 8000278:	d074      	beq.n	8000364 <pvPortMalloc+0x1a4>
 800027a:	687a      	ldr	r2, [r7, #4]
 800027c:	f642 33ff 	movw	r3, #11263	; 0x2bff
 8000280:	f2c0 0301 	movt	r3, #1
 8000284:	429a      	cmp	r2, r3
 8000286:	d86d      	bhi.n	8000364 <pvPortMalloc+0x1a4>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
 8000288:	f642 4390 	movw	r3, #11408	; 0x2c90
 800028c:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8000290:	623b      	str	r3, [r7, #32]
			pxBlock = xStart.pxNextFreeBlock;
 8000292:	f642 4390 	movw	r3, #11408	; 0x2c90
 8000296:	f2c2 0301 	movt	r3, #8193	; 0x2001
 800029a:	681b      	ldr	r3, [r3, #0]
 800029c:	627b      	str	r3, [r7, #36]	; 0x24
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 800029e:	e004      	b.n	80002aa <pvPortMalloc+0xea>
			{
				pxPreviousBlock = pxBlock;
 80002a0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80002a2:	623b      	str	r3, [r7, #32]
				pxBlock = pxBlock->pxNextFreeBlock;
 80002a4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80002a6:	681b      	ldr	r3, [r3, #0]
 80002a8:	627b      	str	r3, [r7, #36]	; 0x24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 80002aa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80002ac:	685a      	ldr	r2, [r3, #4]
 80002ae:	687b      	ldr	r3, [r7, #4]
 80002b0:	429a      	cmp	r2, r3
 80002b2:	d203      	bcs.n	80002bc <pvPortMalloc+0xfc>
 80002b4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80002b6:	681b      	ldr	r3, [r3, #0]
 80002b8:	2b00      	cmp	r3, #0
 80002ba:	d1f1      	bne.n	80002a0 <pvPortMalloc+0xe0>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
 80002bc:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80002be:	f642 4398 	movw	r3, #11416	; 0x2c98
 80002c2:	f2c2 0301 	movt	r3, #8193	; 0x2001
 80002c6:	429a      	cmp	r2, r3
 80002c8:	d04c      	beq.n	8000364 <pvPortMalloc+0x1a4>
			{
				/* Return the memory space - jumping over the xBlockLink structure
				at its start. */
				pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
 80002ca:	6a3b      	ldr	r3, [r7, #32]
 80002cc:	681a      	ldr	r2, [r3, #0]
 80002ce:	f244 239e 	movw	r3, #17054	; 0x429e
 80002d2:	f6c0 0300 	movt	r3, #2048	; 0x800
 80002d6:	881b      	ldrh	r3, [r3, #0]
 80002d8:	18d3      	adds	r3, r2, r3
 80002da:	61fb      	str	r3, [r7, #28]

				/* This block is being returned for use so must be taken out of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 80002dc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80002de:	681a      	ldr	r2, [r3, #0]
 80002e0:	6a3b      	ldr	r3, [r7, #32]
 80002e2:	601a      	str	r2, [r3, #0]

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 80002e4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80002e6:	685a      	ldr	r2, [r3, #4]
 80002e8:	687b      	ldr	r3, [r7, #4]
 80002ea:	1ad2      	subs	r2, r2, r3
 80002ec:	f244 239e 	movw	r3, #17054	; 0x429e
 80002f0:	f6c0 0300 	movt	r3, #2048	; 0x800
 80002f4:	881b      	ldrh	r3, [r3, #0]
 80002f6:	ea4f 0343 	mov.w	r3, r3, lsl #1
 80002fa:	429a      	cmp	r2, r3
 80002fc:	d925      	bls.n	800034a <pvPortMalloc+0x18a>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
 80002fe:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8000300:	687b      	ldr	r3, [r7, #4]
 8000302:	18d3      	adds	r3, r2, r3
 8000304:	613b      	str	r3, [r7, #16]

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 8000306:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8000308:	685a      	ldr	r2, [r3, #4]
 800030a:	687b      	ldr	r3, [r7, #4]
 800030c:	1ad2      	subs	r2, r2, r3
 800030e:	693b      	ldr	r3, [r7, #16]
 8000310:	605a      	str	r2, [r3, #4]
					pxBlock->xBlockSize = xWantedSize;
 8000312:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8000314:	687a      	ldr	r2, [r7, #4]
 8000316:	605a      	str	r2, [r3, #4]

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
 8000318:	693b      	ldr	r3, [r7, #16]
 800031a:	685b      	ldr	r3, [r3, #4]
 800031c:	60fb      	str	r3, [r7, #12]
 800031e:	f642 4390 	movw	r3, #11408	; 0x2c90
 8000322:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8000326:	61bb      	str	r3, [r7, #24]
 8000328:	e002      	b.n	8000330 <pvPortMalloc+0x170>
 800032a:	69bb      	ldr	r3, [r7, #24]
 800032c:	681b      	ldr	r3, [r3, #0]
 800032e:	61bb      	str	r3, [r7, #24]
 8000330:	69bb      	ldr	r3, [r7, #24]
 8000332:	681b      	ldr	r3, [r3, #0]
 8000334:	685a      	ldr	r2, [r3, #4]
 8000336:	68fb      	ldr	r3, [r7, #12]
 8000338:	429a      	cmp	r2, r3
 800033a:	d3f6      	bcc.n	800032a <pvPortMalloc+0x16a>
 800033c:	69bb      	ldr	r3, [r7, #24]
 800033e:	681a      	ldr	r2, [r3, #0]
 8000340:	693b      	ldr	r3, [r7, #16]
 8000342:	601a      	str	r2, [r3, #0]
 8000344:	69bb      	ldr	r3, [r7, #24]
 8000346:	693a      	ldr	r2, [r7, #16]
 8000348:	601a      	str	r2, [r3, #0]
				}
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
 800034a:	f240 0300 	movw	r3, #0
 800034e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000352:	681a      	ldr	r2, [r3, #0]
 8000354:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8000356:	685b      	ldr	r3, [r3, #4]
 8000358:	1ad2      	subs	r2, r2, r3
 800035a:	f240 0300 	movw	r3, #0
 800035e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000362:	601a      	str	r2, [r3, #0]
			}
		}
	}
	xTaskResumeAll();
 8000364:	f001 ff26 	bl	80021b4 <xTaskResumeAll>

	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
	{
		if( pvReturn == NULL )
 8000368:	69fb      	ldr	r3, [r7, #28]
 800036a:	2b00      	cmp	r3, #0
 800036c:	d101      	bne.n	8000372 <pvPortMalloc+0x1b2>
		{
			extern void vApplicationMallocFailedHook( void );
			vApplicationMallocFailedHook();
 800036e:	f000 f863 	bl	8000438 <vApplicationMallocFailedHook>
		}
	}
	#endif

	return pvReturn;
 8000372:	69fb      	ldr	r3, [r7, #28]
}
 8000374:	4618      	mov	r0, r3
 8000376:	f107 0728 	add.w	r7, r7, #40	; 0x28
 800037a:	46bd      	mov	sp, r7
 800037c:	bd80      	pop	{r7, pc}
 800037e:	bf00      	nop

08000380 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
 8000380:	b580      	push	{r7, lr}
 8000382:	b086      	sub	sp, #24
 8000384:	af00      	add	r7, sp, #0
 8000386:	6078      	str	r0, [r7, #4]
unsigned char *puc = ( unsigned char * ) pv;
 8000388:	687b      	ldr	r3, [r7, #4]
 800038a:	613b      	str	r3, [r7, #16]
xBlockLink *pxLink;

	if( pv != NULL )
 800038c:	687b      	ldr	r3, [r7, #4]
 800038e:	2b00      	cmp	r3, #0
 8000390:	d035      	beq.n	80003fe <vPortFree+0x7e>
	{
		/* The memory being freed will have an xBlockLink structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
 8000392:	f244 239e 	movw	r3, #17054	; 0x429e
 8000396:	f6c0 0300 	movt	r3, #2048	; 0x800
 800039a:	881b      	ldrh	r3, [r3, #0]
 800039c:	f1c3 0300 	rsb	r3, r3, #0
 80003a0:	693a      	ldr	r2, [r7, #16]
 80003a2:	18d3      	adds	r3, r2, r3
 80003a4:	613b      	str	r3, [r7, #16]

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;
 80003a6:	693b      	ldr	r3, [r7, #16]
 80003a8:	60fb      	str	r3, [r7, #12]

		vTaskSuspendAll();
 80003aa:	f001 fef1 	bl	8002190 <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );
 80003ae:	68fb      	ldr	r3, [r7, #12]
 80003b0:	685b      	ldr	r3, [r3, #4]
 80003b2:	60bb      	str	r3, [r7, #8]
 80003b4:	f642 4390 	movw	r3, #11408	; 0x2c90
 80003b8:	f2c2 0301 	movt	r3, #8193	; 0x2001
 80003bc:	617b      	str	r3, [r7, #20]
 80003be:	e002      	b.n	80003c6 <vPortFree+0x46>
 80003c0:	697b      	ldr	r3, [r7, #20]
 80003c2:	681b      	ldr	r3, [r3, #0]
 80003c4:	617b      	str	r3, [r7, #20]
 80003c6:	697b      	ldr	r3, [r7, #20]
 80003c8:	681b      	ldr	r3, [r3, #0]
 80003ca:	685a      	ldr	r2, [r3, #4]
 80003cc:	68bb      	ldr	r3, [r7, #8]
 80003ce:	429a      	cmp	r2, r3
 80003d0:	d3f6      	bcc.n	80003c0 <vPortFree+0x40>
 80003d2:	697b      	ldr	r3, [r7, #20]
 80003d4:	681a      	ldr	r2, [r3, #0]
 80003d6:	68fb      	ldr	r3, [r7, #12]
 80003d8:	601a      	str	r2, [r3, #0]
 80003da:	697b      	ldr	r3, [r7, #20]
 80003dc:	68fa      	ldr	r2, [r7, #12]
 80003de:	601a      	str	r2, [r3, #0]
			xFreeBytesRemaining += pxLink->xBlockSize;
 80003e0:	68fb      	ldr	r3, [r7, #12]
 80003e2:	685a      	ldr	r2, [r3, #4]
 80003e4:	f240 0300 	movw	r3, #0
 80003e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80003ec:	681b      	ldr	r3, [r3, #0]
 80003ee:	18d2      	adds	r2, r2, r3
 80003f0:	f240 0300 	movw	r3, #0
 80003f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80003f8:	601a      	str	r2, [r3, #0]
		}
		xTaskResumeAll();
 80003fa:	f001 fedb 	bl	80021b4 <xTaskResumeAll>
	}
}
 80003fe:	f107 0718 	add.w	r7, r7, #24
 8000402:	46bd      	mov	sp, r7
 8000404:	bd80      	pop	{r7, pc}
 8000406:	bf00      	nop

08000408 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
 8000408:	b480      	push	{r7}
 800040a:	af00      	add	r7, sp, #0
	return xFreeBytesRemaining;
 800040c:	f240 0300 	movw	r3, #0
 8000410:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000414:	681b      	ldr	r3, [r3, #0]
}
 8000416:	4618      	mov	r0, r3
 8000418:	46bd      	mov	sp, r7
 800041a:	bc80      	pop	{r7}
 800041c:	4770      	bx	lr
 800041e:	bf00      	nop

08000420 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
 8000420:	b480      	push	{r7}
 8000422:	af00      	add	r7, sp, #0
	/* This just exists to keep the linker quiet. */
}
 8000424:	46bd      	mov	sp, r7
 8000426:	bc80      	pop	{r7}
 8000428:	4770      	bx	lr
 800042a:	bf00      	nop

0800042c <vApplicationTickHook>:
#include "task.h"

/*-----------------------------------------------------------*/

void vApplicationTickHook( void )
{
 800042c:	b480      	push	{r7}
 800042e:	af00      	add	r7, sp, #0
    /* TickHook */
}
 8000430:	46bd      	mov	sp, r7
 8000432:	bc80      	pop	{r7}
 8000434:	4770      	bx	lr
 8000436:	bf00      	nop

08000438 <vApplicationMallocFailedHook>:

/*-----------------------------------------------------------*/

void vApplicationMallocFailedHook( void )
{
 8000438:	b580      	push	{r7, lr}
 800043a:	af00      	add	r7, sp, #0
	demo application.  If heap_1.c or heap_2.c are used, then the size of the
	heap available to pvPortMalloc() is defined by configTOTAL_HEAP_SIZE in
	FreeRTOSConfig.h, and the xPortGetFreeHeapSize() API function can be used
	to query the size of free heap space that remains (although it does not
	provide information on how the remaining heap might be fragmented). */
	taskDISABLE_INTERRUPTS();
 800043c:	f000 fbbc 	bl	8000bb8 <ulPortSetInterruptMask>
	for( ;; );
 8000440:	e7fe      	b.n	8000440 <vApplicationMallocFailedHook+0x8>
 8000442:	bf00      	nop

08000444 <vApplicationIdleHook>:
}
/*-----------------------------------------------------------*/

void vApplicationIdleHook( void )
{
 8000444:	b480      	push	{r7}
 8000446:	af00      	add	r7, sp, #0
	vTaskDelete() API function (as this demo application does) then it is also
	important that vApplicationIdleHook() is permitted to return to its calling
	function, because it is the responsibility of the idle task to clean up
	memory allocated by the kernel to any task that has since been deleted. */
    static uint32_t idle_hook_called = 0;
    idle_hook_called++;
 8000448:	f642 43a8 	movw	r3, #11432	; 0x2ca8
 800044c:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8000450:	681b      	ldr	r3, [r3, #0]
 8000452:	f103 0201 	add.w	r2, r3, #1
 8000456:	f642 43a8 	movw	r3, #11432	; 0x2ca8
 800045a:	f2c2 0301 	movt	r3, #8193	; 0x2001
 800045e:	601a      	str	r2, [r3, #0]
}
 8000460:	46bd      	mov	sp, r7
 8000462:	bc80      	pop	{r7}
 8000464:	4770      	bx	lr
 8000466:	bf00      	nop

08000468 <vApplicationStackOverflowHook>:
/*-----------------------------------------------------------*/

void vApplicationStackOverflowHook( xTaskHandle pxTask, signed char *pcTaskName )
{
 8000468:	b580      	push	{r7, lr}
 800046a:	b082      	sub	sp, #8
 800046c:	af00      	add	r7, sp, #0
 800046e:	6078      	str	r0, [r7, #4]
 8000470:	6039      	str	r1, [r7, #0]
	( void ) pxTask;

	/* Run time stack overflow checking is performed if
	configCHECK_FOR_STACK_OVERFLOW is defined to 1 or 2.  This hook
	function is called if a stack overflow is detected. */
	taskDISABLE_INTERRUPTS();
 8000472:	f000 fba1 	bl	8000bb8 <ulPortSetInterruptMask>
	for( ;; );
 8000476:	e7fe      	b.n	8000476 <vApplicationStackOverflowHook+0xe>

08000478 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
 8000478:	b480      	push	{r7}
 800047a:	b083      	sub	sp, #12
 800047c:	af00      	add	r7, sp, #0
 800047e:	6078      	str	r0, [r7, #4]
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
 8000480:	687b      	ldr	r3, [r7, #4]
 8000482:	f103 0208 	add.w	r2, r3, #8
 8000486:	687b      	ldr	r3, [r7, #4]
 8000488:	605a      	str	r2, [r3, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 800048a:	687b      	ldr	r3, [r7, #4]
 800048c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8000490:	609a      	str	r2, [r3, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
 8000492:	687b      	ldr	r3, [r7, #4]
 8000494:	f103 0208 	add.w	r2, r3, #8
 8000498:	687b      	ldr	r3, [r7, #4]
 800049a:	60da      	str	r2, [r3, #12]
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
 800049c:	687b      	ldr	r3, [r7, #4]
 800049e:	f103 0208 	add.w	r2, r3, #8
 80004a2:	687b      	ldr	r3, [r7, #4]
 80004a4:	611a      	str	r2, [r3, #16]

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
 80004a6:	687b      	ldr	r3, [r7, #4]
 80004a8:	f04f 0200 	mov.w	r2, #0
 80004ac:	601a      	str	r2, [r3, #0]
}
 80004ae:	f107 070c 	add.w	r7, r7, #12
 80004b2:	46bd      	mov	sp, r7
 80004b4:	bc80      	pop	{r7}
 80004b6:	4770      	bx	lr

080004b8 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
 80004b8:	b480      	push	{r7}
 80004ba:	b083      	sub	sp, #12
 80004bc:	af00      	add	r7, sp, #0
 80004be:	6078      	str	r0, [r7, #4]
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 80004c0:	687b      	ldr	r3, [r7, #4]
 80004c2:	f04f 0200 	mov.w	r2, #0
 80004c6:	611a      	str	r2, [r3, #16]
}
 80004c8:	f107 070c 	add.w	r7, r7, #12
 80004cc:	46bd      	mov	sp, r7
 80004ce:	bc80      	pop	{r7}
 80004d0:	4770      	bx	lr
 80004d2:	bf00      	nop

080004d4 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
 80004d4:	b480      	push	{r7}
 80004d6:	b085      	sub	sp, #20
 80004d8:	af00      	add	r7, sp, #0
 80004da:	6078      	str	r0, [r7, #4]
 80004dc:	6039      	str	r1, [r7, #0]

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
 80004de:	687b      	ldr	r3, [r7, #4]
 80004e0:	685b      	ldr	r3, [r3, #4]
 80004e2:	60fb      	str	r3, [r7, #12]

	pxNewListItem->pxNext = pxIndex->pxNext;
 80004e4:	68fb      	ldr	r3, [r7, #12]
 80004e6:	685a      	ldr	r2, [r3, #4]
 80004e8:	683b      	ldr	r3, [r7, #0]
 80004ea:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxPrevious = pxList->pxIndex;
 80004ec:	687b      	ldr	r3, [r7, #4]
 80004ee:	685a      	ldr	r2, [r3, #4]
 80004f0:	683b      	ldr	r3, [r7, #0]
 80004f2:	609a      	str	r2, [r3, #8]
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
 80004f4:	68fb      	ldr	r3, [r7, #12]
 80004f6:	685b      	ldr	r3, [r3, #4]
 80004f8:	683a      	ldr	r2, [r7, #0]
 80004fa:	609a      	str	r2, [r3, #8]
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
 80004fc:	68fb      	ldr	r3, [r7, #12]
 80004fe:	683a      	ldr	r2, [r7, #0]
 8000500:	605a      	str	r2, [r3, #4]
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
 8000502:	687b      	ldr	r3, [r7, #4]
 8000504:	683a      	ldr	r2, [r7, #0]
 8000506:	605a      	str	r2, [r3, #4]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 8000508:	683b      	ldr	r3, [r7, #0]
 800050a:	687a      	ldr	r2, [r7, #4]
 800050c:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
 800050e:	687b      	ldr	r3, [r7, #4]
 8000510:	681b      	ldr	r3, [r3, #0]
 8000512:	f103 0201 	add.w	r2, r3, #1
 8000516:	687b      	ldr	r3, [r7, #4]
 8000518:	601a      	str	r2, [r3, #0]
}
 800051a:	f107 0714 	add.w	r7, r7, #20
 800051e:	46bd      	mov	sp, r7
 8000520:	bc80      	pop	{r7}
 8000522:	4770      	bx	lr

08000524 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
 8000524:	b480      	push	{r7}
 8000526:	b085      	sub	sp, #20
 8000528:	af00      	add	r7, sp, #0
 800052a:	6078      	str	r0, [r7, #4]
 800052c:	6039      	str	r1, [r7, #0]
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
 800052e:	683b      	ldr	r3, [r7, #0]
 8000530:	681b      	ldr	r3, [r3, #0]
 8000532:	60bb      	str	r3, [r7, #8]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 8000534:	68bb      	ldr	r3, [r7, #8]
 8000536:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 800053a:	d103      	bne.n	8000544 <vListInsert+0x20>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 800053c:	687b      	ldr	r3, [r7, #4]
 800053e:	691b      	ldr	r3, [r3, #16]
 8000540:	60fb      	str	r3, [r7, #12]
 8000542:	e00d      	b.n	8000560 <vListInsert+0x3c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
 8000544:	687b      	ldr	r3, [r7, #4]
 8000546:	f103 0308 	add.w	r3, r3, #8
 800054a:	60fb      	str	r3, [r7, #12]
 800054c:	e002      	b.n	8000554 <vListInsert+0x30>
 800054e:	68fb      	ldr	r3, [r7, #12]
 8000550:	685b      	ldr	r3, [r3, #4]
 8000552:	60fb      	str	r3, [r7, #12]
 8000554:	68fb      	ldr	r3, [r7, #12]
 8000556:	685b      	ldr	r3, [r3, #4]
 8000558:	681a      	ldr	r2, [r3, #0]
 800055a:	68bb      	ldr	r3, [r7, #8]
 800055c:	429a      	cmp	r2, r3
 800055e:	d9f6      	bls.n	800054e <vListInsert+0x2a>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 8000560:	68fb      	ldr	r3, [r7, #12]
 8000562:	685a      	ldr	r2, [r3, #4]
 8000564:	683b      	ldr	r3, [r7, #0]
 8000566:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
 8000568:	683b      	ldr	r3, [r7, #0]
 800056a:	685b      	ldr	r3, [r3, #4]
 800056c:	683a      	ldr	r2, [r7, #0]
 800056e:	609a      	str	r2, [r3, #8]
	pxNewListItem->pxPrevious = pxIterator;
 8000570:	683b      	ldr	r3, [r7, #0]
 8000572:	68fa      	ldr	r2, [r7, #12]
 8000574:	609a      	str	r2, [r3, #8]
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
 8000576:	68fb      	ldr	r3, [r7, #12]
 8000578:	683a      	ldr	r2, [r7, #0]
 800057a:	605a      	str	r2, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 800057c:	683b      	ldr	r3, [r7, #0]
 800057e:	687a      	ldr	r2, [r7, #4]
 8000580:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
 8000582:	687b      	ldr	r3, [r7, #4]
 8000584:	681b      	ldr	r3, [r3, #0]
 8000586:	f103 0201 	add.w	r2, r3, #1
 800058a:	687b      	ldr	r3, [r7, #4]
 800058c:	601a      	str	r2, [r3, #0]
}
 800058e:	f107 0714 	add.w	r7, r7, #20
 8000592:	46bd      	mov	sp, r7
 8000594:	bc80      	pop	{r7}
 8000596:	4770      	bx	lr

08000598 <uxListRemove>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxListRemove( xListItem *pxItemToRemove )
{
 8000598:	b480      	push	{r7}
 800059a:	b085      	sub	sp, #20
 800059c:	af00      	add	r7, sp, #0
 800059e:	6078      	str	r0, [r7, #4]
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 80005a0:	687b      	ldr	r3, [r7, #4]
 80005a2:	685b      	ldr	r3, [r3, #4]
 80005a4:	687a      	ldr	r2, [r7, #4]
 80005a6:	6892      	ldr	r2, [r2, #8]
 80005a8:	609a      	str	r2, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 80005aa:	687b      	ldr	r3, [r7, #4]
 80005ac:	689b      	ldr	r3, [r3, #8]
 80005ae:	687a      	ldr	r2, [r7, #4]
 80005b0:	6852      	ldr	r2, [r2, #4]
 80005b2:	605a      	str	r2, [r3, #4]

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
 80005b4:	687b      	ldr	r3, [r7, #4]
 80005b6:	691b      	ldr	r3, [r3, #16]
 80005b8:	60fb      	str	r3, [r7, #12]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 80005ba:	68fb      	ldr	r3, [r7, #12]
 80005bc:	685a      	ldr	r2, [r3, #4]
 80005be:	687b      	ldr	r3, [r7, #4]
 80005c0:	429a      	cmp	r2, r3
 80005c2:	d103      	bne.n	80005cc <uxListRemove+0x34>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 80005c4:	687b      	ldr	r3, [r7, #4]
 80005c6:	689a      	ldr	r2, [r3, #8]
 80005c8:	68fb      	ldr	r3, [r7, #12]
 80005ca:	605a      	str	r2, [r3, #4]
	}

	pxItemToRemove->pvContainer = NULL;
 80005cc:	687b      	ldr	r3, [r7, #4]
 80005ce:	f04f 0200 	mov.w	r2, #0
 80005d2:	611a      	str	r2, [r3, #16]
	( pxList->uxNumberOfItems )--;
 80005d4:	68fb      	ldr	r3, [r7, #12]
 80005d6:	681b      	ldr	r3, [r3, #0]
 80005d8:	f103 32ff 	add.w	r2, r3, #4294967295	; 0xffffffff
 80005dc:	68fb      	ldr	r3, [r7, #12]
 80005de:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
 80005e0:	68fb      	ldr	r3, [r7, #12]
 80005e2:	681b      	ldr	r3, [r3, #0]
}
 80005e4:	4618      	mov	r0, r3
 80005e6:	f107 0714 	add.w	r7, r7, #20
 80005ea:	46bd      	mov	sp, r7
 80005ec:	bc80      	pop	{r7}
 80005ee:	4770      	bx	lr

080005f0 <low_level_init>:
  *         SystemFrequency variable.
  * @param  None
  * @retval None
  */
void low_level_init(void)
{
 80005f0:	b580      	push	{r7, lr}
 80005f2:	af00      	add	r7, sp, #0
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 80005f4:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80005f8:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80005fc:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8000600:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8000604:	6812      	ldr	r2, [r2, #0]
 8000606:	f042 0201 	orr.w	r2, r2, #1
 800060a:	601a      	str	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 800060c:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8000610:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8000614:	f04f 0200 	mov.w	r2, #0
 8000618:	609a      	str	r2, [r3, #8]

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 800061a:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800061e:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8000622:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8000626:	f2c4 0202 	movt	r2, #16386	; 0x4002
 800062a:	6812      	ldr	r2, [r2, #0]
 800062c:	f022 7284 	bic.w	r2, r2, #17301504	; 0x1080000
 8000630:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8000634:	601a      	str	r2, [r3, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 8000636:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800063a:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800063e:	f243 0210 	movw	r2, #12304	; 0x3010
 8000642:	f2c2 4200 	movt	r2, #9216	; 0x2400
 8000646:	605a      	str	r2, [r3, #4]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 8000648:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800064c:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8000650:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8000654:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8000658:	6812      	ldr	r2, [r2, #0]
 800065a:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 800065e:	601a      	str	r2, [r3, #0]

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
 8000660:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8000664:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8000668:	f04f 0200 	mov.w	r2, #0
 800066c:	60da      	str	r2, [r3, #12]

  /* Configure the System clock source, PLL Multiplier and Divider factors, 
     AHB/APBx prescalers and Flash settings ----------------------------------*/
  SetSysClock();
 800066e:	f000 f809 	bl	8000684 <SetSysClock>
#ifdef VECT_TAB_SRAM
  /* Vector Table Relocation in Internal SRAM */
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET;
#else
  /* Vector Table Relocation in Internal FLASH */
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET;
 8000672:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 8000676:	f2ce 0300 	movt	r3, #57344	; 0xe000
 800067a:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 800067e:	609a      	str	r2, [r3, #8]
#endif
}
 8000680:	bd80      	pop	{r7, pc}
 8000682:	bf00      	nop

08000684 <SetSysClock>:
  *         is reset to the default reset state (done in SystemInit() function).
  * @param  None
  * @retval None
  */
static void SetSysClock(void)
{
 8000684:	b480      	push	{r7}
 8000686:	b083      	sub	sp, #12
 8000688:	af00      	add	r7, sp, #0
/******************************************************************************/
/*            PLL (clocked by HSE) used as System clock source                */
/******************************************************************************/
  __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
 800068a:	f04f 0300 	mov.w	r3, #0
 800068e:	607b      	str	r3, [r7, #4]
 8000690:	f04f 0300 	mov.w	r3, #0
 8000694:	603b      	str	r3, [r7, #0]
  
  /* Enable HSE */
  RCC->CR |= ((uint32_t)RCC_CR_HSEON);
 8000696:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800069a:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800069e:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 80006a2:	f2c4 0202 	movt	r2, #16386	; 0x4002
 80006a6:	6812      	ldr	r2, [r2, #0]
 80006a8:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 80006ac:	601a      	str	r2, [r3, #0]
 
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    HSEStatus = RCC->CR & RCC_CR_HSERDY;
 80006ae:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80006b2:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80006b6:	681b      	ldr	r3, [r3, #0]
 80006b8:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 80006bc:	603b      	str	r3, [r7, #0]
    StartUpCounter++;
 80006be:	687b      	ldr	r3, [r7, #4]
 80006c0:	f103 0301 	add.w	r3, r3, #1
 80006c4:	607b      	str	r3, [r7, #4]
  } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));
 80006c6:	683b      	ldr	r3, [r7, #0]
 80006c8:	2b00      	cmp	r3, #0
 80006ca:	d103      	bne.n	80006d4 <SetSysClock+0x50>
 80006cc:	687b      	ldr	r3, [r7, #4]
 80006ce:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 80006d2:	d1ec      	bne.n	80006ae <SetSysClock+0x2a>

  if ((RCC->CR & RCC_CR_HSERDY) != RESET)
 80006d4:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80006d8:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80006dc:	681b      	ldr	r3, [r3, #0]
 80006de:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 80006e2:	2b00      	cmp	r3, #0
 80006e4:	d003      	beq.n	80006ee <SetSysClock+0x6a>
  {
    HSEStatus = (uint32_t)0x01;
 80006e6:	f04f 0301 	mov.w	r3, #1
 80006ea:	603b      	str	r3, [r7, #0]
 80006ec:	e002      	b.n	80006f4 <SetSysClock+0x70>
  }
  else
  {
    HSEStatus = (uint32_t)0x00;
 80006ee:	f04f 0300 	mov.w	r3, #0
 80006f2:	603b      	str	r3, [r7, #0]
  }

  if (HSEStatus == (uint32_t)0x01)
 80006f4:	683b      	ldr	r3, [r7, #0]
 80006f6:	2b01      	cmp	r3, #1
 80006f8:	f040 8082 	bne.w	8000800 <SetSysClock+0x17c>
  {
    /* Enable high performance mode, System frequency up to 168 MHz */
    RCC->APB1ENR |= RCC_APB1ENR_PWREN;
 80006fc:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8000700:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8000704:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8000708:	f2c4 0202 	movt	r2, #16386	; 0x4002
 800070c:	6c12      	ldr	r2, [r2, #64]	; 0x40
 800070e:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8000712:	641a      	str	r2, [r3, #64]	; 0x40
    PWR->CR |= PWR_CR_PMODE;  
 8000714:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
 8000718:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800071c:	f44f 42e0 	mov.w	r2, #28672	; 0x7000
 8000720:	f2c4 0200 	movt	r2, #16384	; 0x4000
 8000724:	6812      	ldr	r2, [r2, #0]
 8000726:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 800072a:	601a      	str	r2, [r3, #0]

    /* HCLK = SYSCLK / 1*/
    RCC->CFGR |= RCC_CFGR_HPRE_DIV1;
 800072c:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8000730:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8000734:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8000738:	f2c4 0202 	movt	r2, #16386	; 0x4002
 800073c:	6892      	ldr	r2, [r2, #8]
 800073e:	609a      	str	r2, [r3, #8]
      
    /* PCLK2 = HCLK / 2*/
    RCC->CFGR |= RCC_CFGR_PPRE2_DIV2;
 8000740:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8000744:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8000748:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 800074c:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8000750:	6892      	ldr	r2, [r2, #8]
 8000752:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8000756:	609a      	str	r2, [r3, #8]
    
    /* PCLK1 = HCLK / 4*/
    RCC->CFGR |= RCC_CFGR_PPRE1_DIV4;
 8000758:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800075c:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8000760:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8000764:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8000768:	6892      	ldr	r2, [r2, #8]
 800076a:	f442 52a0 	orr.w	r2, r2, #5120	; 0x1400
 800076e:	609a      	str	r2, [r3, #8]

    /* Configure the main PLL */
    RCC->PLLCFGR = PLL_M | (PLL_N << 6) | (((PLL_P >> 1) -1) << 16) |
 8000770:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8000774:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8000778:	f245 4208 	movw	r2, #21512	; 0x5408
 800077c:	f2c0 7240 	movt	r2, #1856	; 0x740
 8000780:	605a      	str	r2, [r3, #4]
                   (RCC_PLLCFGR_PLLSRC_HSE) | (PLL_Q << 24);

    /* Enable the main PLL */
    RCC->CR |= RCC_CR_PLLON;
 8000782:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8000786:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800078a:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 800078e:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8000792:	6812      	ldr	r2, [r2, #0]
 8000794:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8000798:	601a      	str	r2, [r3, #0]

    /* Wait till the main PLL is ready */
    while((RCC->CR & RCC_CR_PLLRDY) == 0) { }
 800079a:	bf00      	nop
 800079c:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80007a0:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80007a4:	681b      	ldr	r3, [r3, #0]
 80007a6:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 80007aa:	2b00      	cmp	r3, #0
 80007ac:	d0f6      	beq.n	800079c <SetSysClock+0x118>
   
    /* Configure Flash prefetch, Instruction cache, Data cache and wait state */
    FLASH->ACR = FLASH_ACR_ICEN |FLASH_ACR_DCEN |FLASH_ACR_LATENCY_5WS;
 80007ae:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
 80007b2:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80007b6:	f240 6205 	movw	r2, #1541	; 0x605
 80007ba:	601a      	str	r2, [r3, #0]

    /* Select the main PLL as system clock source */
    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
 80007bc:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80007c0:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80007c4:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 80007c8:	f2c4 0202 	movt	r2, #16386	; 0x4002
 80007cc:	6892      	ldr	r2, [r2, #8]
 80007ce:	f022 0203 	bic.w	r2, r2, #3
 80007d2:	609a      	str	r2, [r3, #8]
    RCC->CFGR |= RCC_CFGR_SW_PLL;
 80007d4:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80007d8:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80007dc:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 80007e0:	f2c4 0202 	movt	r2, #16386	; 0x4002
 80007e4:	6892      	ldr	r2, [r2, #8]
 80007e6:	f042 0202 	orr.w	r2, r2, #2
 80007ea:	609a      	str	r2, [r3, #8]

    /* Wait till the main PLL is used as system clock source */
    while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS ) != RCC_CFGR_SWS_PLL);
 80007ec:	bf00      	nop
 80007ee:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80007f2:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80007f6:	689b      	ldr	r3, [r3, #8]
 80007f8:	f003 030c 	and.w	r3, r3, #12
 80007fc:	2b08      	cmp	r3, #8
 80007fe:	d1f6      	bne.n	80007ee <SetSysClock+0x16a>
  }
  else
  { /* If HSE fails to start-up, the application will have wrong clock
         configuration. User can add here some code to deal with this error */
  }
}
 8000800:	f107 070c 	add.w	r7, r7, #12
 8000804:	46bd      	mov	sp, r7
 8000806:	bc80      	pop	{r7}
 8000808:	4770      	bx	lr
 800080a:	bf00      	nop

0800080c <clock_setup>:
void vTest1Task(void *pvParameters);
void vLEDTask(void *pvParmeters);

/* Set STM32 to 168 MHz. */
static void clock_setup(void)
{
 800080c:	b580      	push	{r7, lr}
 800080e:	af00      	add	r7, sp, #0
    rcc_clock_setup_hse_3v3(&hse_8mhz_3v3[CLOCK_3V3_168MHZ]);
 8000810:	4805      	ldr	r0, [pc, #20]	; (8000828 <clock_setup+0x1c>)
 8000812:	f003 f887 	bl	8003924 <rcc_clock_setup_hse_3v3>

    /* Enable GPIOD clock. */
    rcc_peripheral_enable_clock(&RCC_AHB1ENR, RCC_AHB1ENR_IOPDEN);
 8000816:	f643 0030 	movw	r0, #14384	; 0x3830
 800081a:	f2c4 0002 	movt	r0, #16386	; 0x4002
 800081e:	f04f 0108 	mov.w	r1, #8
 8000822:	f003 f843 	bl	80038ac <rcc_peripheral_enable_clock>
}
 8000826:	bd80      	pop	{r7, pc}
 8000828:	08004320 	.word	0x08004320

0800082c <gpio_setup>:

static void gpio_setup(void)
{
 800082c:	b580      	push	{r7, lr}
 800082e:	af00      	add	r7, sp, #0
    /* Set GPIO12-15 (in GPIO port D) to 'output push-pull'. */
    gpio_mode_setup(GPIOD, GPIO_MODE_OUTPUT,
 8000830:	f44f 6040 	mov.w	r0, #3072	; 0xc00
 8000834:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8000838:	f04f 0101 	mov.w	r1, #1
 800083c:	f04f 0200 	mov.w	r2, #0
 8000840:	f44f 4370 	mov.w	r3, #61440	; 0xf000
 8000844:	f003 f8bb 	bl	80039be <gpio_mode_setup>
            GPIO_PUPD_NONE, GPIO12 | GPIO13 | GPIO14 | GPIO15);
}
 8000848:	bd80      	pop	{r7, pc}
 800084a:	bf00      	nop

0800084c <main>:


/* main C entry point - should never return */
int main(void)
{
 800084c:	b580      	push	{r7, lr}
 800084e:	b086      	sub	sp, #24
 8000850:	af04      	add	r7, sp, #16
    uint32_t i=0;
 8000852:	f04f 0300 	mov.w	r3, #0
 8000856:	607b      	str	r3, [r7, #4]

    clock_setup();
 8000858:	f7ff ffd8 	bl	800080c <clock_setup>
    gpio_setup();
 800085c:	f7ff ffe6 	bl	800082c <gpio_setup>

    xTaskCreate( vTest1Task, ( signed char * ) "Test1",
 8000860:	f04f 0300 	mov.w	r3, #0
 8000864:	9300      	str	r3, [sp, #0]
 8000866:	f04f 0300 	mov.w	r3, #0
 800086a:	9301      	str	r3, [sp, #4]
 800086c:	f04f 0300 	mov.w	r3, #0
 8000870:	9302      	str	r3, [sp, #8]
 8000872:	f04f 0300 	mov.w	r3, #0
 8000876:	9303      	str	r3, [sp, #12]
 8000878:	f640 00d9 	movw	r0, #2265	; 0x8d9
 800087c:	f6c0 0000 	movt	r0, #2048	; 0x800
 8000880:	f244 21a0 	movw	r1, #17056	; 0x42a0
 8000884:	f6c0 0100 	movt	r1, #2048	; 0x800
 8000888:	f04f 0282 	mov.w	r2, #130	; 0x82
 800088c:	f04f 0300 	mov.w	r3, #0
 8000890:	f001 f83c 	bl	800190c <xTaskGenericCreate>
                    configMINIMAL_STACK_SIZE, ( void * ) NULL,
                    tskIDLE_PRIORITY, NULL );
    xTaskCreate( vLEDTask, ( signed char * ) "LED_Blink",
 8000894:	f04f 0301 	mov.w	r3, #1
 8000898:	9300      	str	r3, [sp, #0]
 800089a:	f04f 0300 	mov.w	r3, #0
 800089e:	9301      	str	r3, [sp, #4]
 80008a0:	f04f 0300 	mov.w	r3, #0
 80008a4:	9302      	str	r3, [sp, #8]
 80008a6:	f04f 0300 	mov.w	r3, #0
 80008aa:	9303      	str	r3, [sp, #12]
 80008ac:	f640 00f5 	movw	r0, #2293	; 0x8f5
 80008b0:	f6c0 0000 	movt	r0, #2048	; 0x800
 80008b4:	f244 21a8 	movw	r1, #17064	; 0x42a8
 80008b8:	f6c0 0100 	movt	r1, #2048	; 0x800
 80008bc:	f04f 0282 	mov.w	r2, #130	; 0x82
 80008c0:	f04f 0300 	mov.w	r3, #0
 80008c4:	f001 f822 	bl	800190c <xTaskGenericCreate>
                    configMINIMAL_STACK_SIZE, ( void * ) NULL,
                    tskIDLE_PRIORITY+1, NULL );
		
    vTaskStartScheduler();
 80008c8:	f001 fc10 	bl	80020ec <vTaskStartScheduler>

    for EVER
    {
        i++;
 80008cc:	687b      	ldr	r3, [r7, #4]
 80008ce:	f103 0301 	add.w	r3, r3, #1
 80008d2:	607b      	str	r3, [r7, #4]
    }
 80008d4:	e7fa      	b.n	80008cc <main+0x80>
 80008d6:	bf00      	nop

080008d8 <vTest1Task>:
}

void vTest1Task(void *pvParameters)
{
 80008d8:	b480      	push	{r7}
 80008da:	b085      	sub	sp, #20
 80008dc:	af00      	add	r7, sp, #0
 80008de:	6078      	str	r0, [r7, #4]
    uint32_t j = 0;
 80008e0:	f04f 0300 	mov.w	r3, #0
 80008e4:	60fb      	str	r3, [r7, #12]
    void * param = pvParameters;
 80008e6:	687b      	ldr	r3, [r7, #4]
 80008e8:	60bb      	str	r3, [r7, #8]
    for EVER
    {
        j++;
 80008ea:	68fb      	ldr	r3, [r7, #12]
 80008ec:	f103 0301 	add.w	r3, r3, #1
 80008f0:	60fb      	str	r3, [r7, #12]
    }
 80008f2:	e7fa      	b.n	80008ea <vTest1Task+0x12>

080008f4 <vLEDTask>:
}

void vLEDTask(void *pvParmeters)
{
 80008f4:	b580      	push	{r7, lr}
 80008f6:	b084      	sub	sp, #16
 80008f8:	af00      	add	r7, sp, #0
 80008fa:	6078      	str	r0, [r7, #4]
    portTickType xLastWakeTime;
    xLastWakeTime = xTaskGetTickCount();
 80008fc:	f001 fd0c 	bl	8002318 <xTaskGetTickCount>
 8000900:	4603      	mov	r3, r0
 8000902:	60fb      	str	r3, [r7, #12]

    for EVER
    {
        static uint8_t run_loop = 0;
        // Wait for the next cycle.
        vTaskDelayUntil(&xLastWakeTime, 250u); /* in ms */
 8000904:	f107 030c 	add.w	r3, r7, #12
 8000908:	4618      	mov	r0, r3
 800090a:	f04f 01fa 	mov.w	r1, #250	; 0xfa
 800090e:	f001 f94d 	bl	8001bac <vTaskDelayUntil>

        // Toggle LED
        switch (run_loop)
 8000912:	f642 43ac 	movw	r3, #11436	; 0x2cac
 8000916:	f2c2 0301 	movt	r3, #8193	; 0x2001
 800091a:	781b      	ldrb	r3, [r3, #0]
 800091c:	2b03      	cmp	r3, #3
 800091e:	d87d      	bhi.n	8000a1c <vLEDTask+0x128>
 8000920:	a201      	add	r2, pc, #4	; (adr r2, 8000928 <vLEDTask+0x34>)
 8000922:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8000926:	bf00      	nop
 8000928:	08000939 	.word	0x08000939
 800092c:	08000975 	.word	0x08000975
 8000930:	080009b1 	.word	0x080009b1
 8000934:	080009ed 	.word	0x080009ed
        {
            case 0:
                gpio_set(GPIOD, GPIO12);
 8000938:	f44f 6040 	mov.w	r0, #3072	; 0xc00
 800093c:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8000940:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8000944:	f003 f836 	bl	80039b4 <gpio_set>
                gpio_clear(GPIOD, GPIO13 | GPIO14 | GPIO15);
 8000948:	f44f 6040 	mov.w	r0, #3072	; 0xc00
 800094c:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8000950:	f44f 4160 	mov.w	r1, #57344	; 0xe000
 8000954:	f003 f830 	bl	80039b8 <gpio_clear>
                run_loop++;
 8000958:	f642 43ac 	movw	r3, #11436	; 0x2cac
 800095c:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8000960:	781b      	ldrb	r3, [r3, #0]
 8000962:	f103 0301 	add.w	r3, r3, #1
 8000966:	b2da      	uxtb	r2, r3
 8000968:	f642 43ac 	movw	r3, #11436	; 0x2cac
 800096c:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8000970:	701a      	strb	r2, [r3, #0]
                break;
 8000972:	e05b      	b.n	8000a2c <vLEDTask+0x138>
            case 1:
                gpio_set(GPIOD, GPIO13);
 8000974:	f44f 6040 	mov.w	r0, #3072	; 0xc00
 8000978:	f2c4 0002 	movt	r0, #16386	; 0x4002
 800097c:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 8000980:	f003 f818 	bl	80039b4 <gpio_set>
                gpio_clear(GPIOD, GPIO12 | GPIO14 | GPIO15);
 8000984:	f44f 6040 	mov.w	r0, #3072	; 0xc00
 8000988:	f2c4 0002 	movt	r0, #16386	; 0x4002
 800098c:	f44f 4150 	mov.w	r1, #53248	; 0xd000
 8000990:	f003 f812 	bl	80039b8 <gpio_clear>
                run_loop++;
 8000994:	f642 43ac 	movw	r3, #11436	; 0x2cac
 8000998:	f2c2 0301 	movt	r3, #8193	; 0x2001
 800099c:	781b      	ldrb	r3, [r3, #0]
 800099e:	f103 0301 	add.w	r3, r3, #1
 80009a2:	b2da      	uxtb	r2, r3
 80009a4:	f642 43ac 	movw	r3, #11436	; 0x2cac
 80009a8:	f2c2 0301 	movt	r3, #8193	; 0x2001
 80009ac:	701a      	strb	r2, [r3, #0]
                break;
 80009ae:	e03d      	b.n	8000a2c <vLEDTask+0x138>
            case 2:
                gpio_set(GPIOD, GPIO14);
 80009b0:	f44f 6040 	mov.w	r0, #3072	; 0xc00
 80009b4:	f2c4 0002 	movt	r0, #16386	; 0x4002
 80009b8:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 80009bc:	f002 fffa 	bl	80039b4 <gpio_set>
                gpio_clear(GPIOD, GPIO12 | GPIO13 | GPIO15);
 80009c0:	f44f 6040 	mov.w	r0, #3072	; 0xc00
 80009c4:	f2c4 0002 	movt	r0, #16386	; 0x4002
 80009c8:	f44f 4130 	mov.w	r1, #45056	; 0xb000
 80009cc:	f002 fff4 	bl	80039b8 <gpio_clear>
                run_loop++;
 80009d0:	f642 43ac 	movw	r3, #11436	; 0x2cac
 80009d4:	f2c2 0301 	movt	r3, #8193	; 0x2001
 80009d8:	781b      	ldrb	r3, [r3, #0]
 80009da:	f103 0301 	add.w	r3, r3, #1
 80009de:	b2da      	uxtb	r2, r3
 80009e0:	f642 43ac 	movw	r3, #11436	; 0x2cac
 80009e4:	f2c2 0301 	movt	r3, #8193	; 0x2001
 80009e8:	701a      	strb	r2, [r3, #0]
                break;
 80009ea:	e01f      	b.n	8000a2c <vLEDTask+0x138>
            case 3:
                gpio_set(GPIOD, GPIO15);
 80009ec:	f44f 6040 	mov.w	r0, #3072	; 0xc00
 80009f0:	f2c4 0002 	movt	r0, #16386	; 0x4002
 80009f4:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 80009f8:	f002 ffdc 	bl	80039b4 <gpio_set>
                gpio_clear(GPIOD, GPIO12 | GPIO13 | GPIO14);
 80009fc:	f44f 6040 	mov.w	r0, #3072	; 0xc00
 8000a00:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8000a04:	f44f 41e0 	mov.w	r1, #28672	; 0x7000
 8000a08:	f002 ffd6 	bl	80039b8 <gpio_clear>
                run_loop=0;
 8000a0c:	f642 43ac 	movw	r3, #11436	; 0x2cac
 8000a10:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8000a14:	f04f 0200 	mov.w	r2, #0
 8000a18:	701a      	strb	r2, [r3, #0]
                break;
 8000a1a:	e007      	b.n	8000a2c <vLEDTask+0x138>
            default:
                run_loop=0;
 8000a1c:	f642 43ac 	movw	r3, #11436	; 0x2cac
 8000a20:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8000a24:	f04f 0200 	mov.w	r2, #0
 8000a28:	701a      	strb	r2, [r3, #0]
        }
    }
 8000a2a:	e76b      	b.n	8000904 <vLEDTask+0x10>
 8000a2c:	e76a      	b.n	8000904 <vLEDTask+0x10>
 8000a2e:	bf00      	nop

08000a30 <pxPortInitialiseStack>:

/*
 * See header file for description.
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
 8000a30:	b480      	push	{r7}
 8000a32:	b085      	sub	sp, #20
 8000a34:	af00      	add	r7, sp, #0
 8000a36:	60f8      	str	r0, [r7, #12]
 8000a38:	60b9      	str	r1, [r7, #8]
 8000a3a:	607a      	str	r2, [r7, #4]
	/* Simulate the stack frame as it would be created by a context switch
	interrupt. */

	/* Offset added to account for the way the MCU uses the stack on entry/exit
	of interrupts, and to ensure alignment. */
	pxTopOfStack--;
 8000a3c:	68fb      	ldr	r3, [r7, #12]
 8000a3e:	f1a3 0304 	sub.w	r3, r3, #4
 8000a42:	60fb      	str	r3, [r7, #12]

	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 8000a44:	68fb      	ldr	r3, [r7, #12]
 8000a46:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 8000a4a:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
 8000a4c:	68fb      	ldr	r3, [r7, #12]
 8000a4e:	f1a3 0304 	sub.w	r3, r3, #4
 8000a52:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( portSTACK_TYPE ) pxCode;	/* PC */
 8000a54:	68ba      	ldr	r2, [r7, #8]
 8000a56:	68fb      	ldr	r3, [r7, #12]
 8000a58:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
 8000a5a:	68fb      	ldr	r3, [r7, #12]
 8000a5c:	f1a3 0304 	sub.w	r3, r3, #4
 8000a60:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = 0;	/* LR */
 8000a62:	68fb      	ldr	r3, [r7, #12]
 8000a64:	f04f 0200 	mov.w	r2, #0
 8000a68:	601a      	str	r2, [r3, #0]

	/* Save code space by skipping register initialisation. */
	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
 8000a6a:	68fb      	ldr	r3, [r7, #12]
 8000a6c:	f1a3 0314 	sub.w	r3, r3, #20
 8000a70:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( portSTACK_TYPE ) pvParameters;	/* R0 */
 8000a72:	687a      	ldr	r2, [r7, #4]
 8000a74:	68fb      	ldr	r3, [r7, #12]
 8000a76:	601a      	str	r2, [r3, #0]

	/* A save method is being used that requires each task to maintain its
	own exec return value. */
	pxTopOfStack--;
 8000a78:	68fb      	ldr	r3, [r7, #12]
 8000a7a:	f1a3 0304 	sub.w	r3, r3, #4
 8000a7e:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = portINITIAL_EXEC_RETURN;
 8000a80:	68fb      	ldr	r3, [r7, #12]
 8000a82:	f06f 0202 	mvn.w	r2, #2
 8000a86:	601a      	str	r2, [r3, #0]

	pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */
 8000a88:	68fb      	ldr	r3, [r7, #12]
 8000a8a:	f1a3 0320 	sub.w	r3, r3, #32
 8000a8e:	60fb      	str	r3, [r7, #12]

	return pxTopOfStack;
 8000a90:	68fb      	ldr	r3, [r7, #12]
}
 8000a92:	4618      	mov	r0, r3
 8000a94:	f107 0714 	add.w	r7, r7, #20
 8000a98:	46bd      	mov	sp, r7
 8000a9a:	bc80      	pop	{r7}
 8000a9c:	4770      	bx	lr
 8000a9e:	bf00      	nop

08000aa0 <SVC_Handler>:
/*-----------------------------------------------------------*/

void vPortSVCHandler( void )
{
	__asm volatile (
 8000aa0:	4b05      	ldr	r3, [pc, #20]	; (8000ab8 <pxCurrentTCBConst2>)
 8000aa2:	6819      	ldr	r1, [r3, #0]
 8000aa4:	6808      	ldr	r0, [r1, #0]
 8000aa6:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000aaa:	f380 8809 	msr	PSP, r0
 8000aae:	f04f 0000 	mov.w	r0, #0
 8000ab2:	f380 8811 	msr	BASEPRI, r0
 8000ab6:	4770      	bx	lr

08000ab8 <pxCurrentTCBConst2>:
 8000ab8:	20012cb4 	.word	0x20012cb4

08000abc <prvPortStartFirstTask>:
}
/*-----------------------------------------------------------*/

static void prvPortStartFirstTask( void )
{
	__asm volatile(
 8000abc:	4876      	ldr	r0, [pc, #472]	; (8000c98 <vPortEnableVFP+0x10>)
 8000abe:	6800      	ldr	r0, [r0, #0]
 8000ac0:	6800      	ldr	r0, [r0, #0]
 8000ac2:	f380 8808 	msr	MSP, r0
 8000ac6:	b662      	cpsie	i
 8000ac8:	df00      	svc	0
 8000aca:	bf00      	nop

08000acc <xPortStartScheduler>:

/*
 * See header file for description.
 */
portBASE_TYPE xPortStartScheduler( void )
{
 8000acc:	b580      	push	{r7, lr}
 8000ace:	af00      	add	r7, sp, #0
	/* configMAX_SYSCALL_INTERRUPT_PRIORITY must not be set to 0.
	See http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
	configASSERT( configMAX_SYSCALL_INTERRUPT_PRIORITY );

	/* Make PendSV, CallSV and SysTick the same priroity as the kernel. */
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
 8000ad0:	f64e 5320 	movw	r3, #60704	; 0xed20
 8000ad4:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8000ad8:	f64e 5220 	movw	r2, #60704	; 0xed20
 8000adc:	f2ce 0200 	movt	r2, #57344	; 0xe000
 8000ae0:	6812      	ldr	r2, [r2, #0]
 8000ae2:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
 8000ae6:	601a      	str	r2, [r3, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
 8000ae8:	f64e 5320 	movw	r3, #60704	; 0xed20
 8000aec:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8000af0:	f64e 5220 	movw	r2, #60704	; 0xed20
 8000af4:	f2ce 0200 	movt	r2, #57344	; 0xe000
 8000af8:	6812      	ldr	r2, [r2, #0]
 8000afa:	f042 4270 	orr.w	r2, r2, #4026531840	; 0xf0000000
 8000afe:	601a      	str	r2, [r3, #0]

	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	vPortSetupTimerInterrupt();
 8000b00:	f000 f8a2 	bl	8000c48 <vPortSetupTimerInterrupt>

	/* Initialise the critical nesting count ready for the first task. */
	uxCriticalNesting = 0;
 8000b04:	f240 0318 	movw	r3, #24
 8000b08:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000b0c:	f04f 0200 	mov.w	r2, #0
 8000b10:	601a      	str	r2, [r3, #0]

	/* Ensure the VFP is enabled - it should be anyway. */
	vPortEnableVFP();
 8000b12:	f000 f8b9 	bl	8000c88 <vPortEnableVFP>

	/* Lazy save always. */
	*( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;
 8000b16:	f64e 7334 	movw	r3, #61236	; 0xef34
 8000b1a:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8000b1e:	f64e 7234 	movw	r2, #61236	; 0xef34
 8000b22:	f2ce 0200 	movt	r2, #57344	; 0xe000
 8000b26:	6812      	ldr	r2, [r2, #0]
 8000b28:	f042 4240 	orr.w	r2, r2, #3221225472	; 0xc0000000
 8000b2c:	601a      	str	r2, [r3, #0]

	/* Start the first task. */
	prvPortStartFirstTask();
 8000b2e:	f7ff ffc5 	bl	8000abc <prvPortStartFirstTask>

	/* Should not get here! */
	return 0;
 8000b32:	f04f 0300 	mov.w	r3, #0
}
 8000b36:	4618      	mov	r0, r3
 8000b38:	bd80      	pop	{r7, pc}
 8000b3a:	bf00      	nop

08000b3c <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
 8000b3c:	b480      	push	{r7}
 8000b3e:	af00      	add	r7, sp, #0
	/* It is unlikely that the CM4F port will require this function as there
	is nothing to return to.  */
}
 8000b40:	46bd      	mov	sp, r7
 8000b42:	bc80      	pop	{r7}
 8000b44:	4770      	bx	lr
 8000b46:	bf00      	nop

08000b48 <vPortYieldFromISR>:
/*-----------------------------------------------------------*/

void vPortYieldFromISR( void )
{
 8000b48:	b480      	push	{r7}
 8000b4a:	af00      	add	r7, sp, #0
	/* Set a PendSV to request a context switch. */
	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 8000b4c:	f64e 5304 	movw	r3, #60676	; 0xed04
 8000b50:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8000b54:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8000b58:	601a      	str	r2, [r3, #0]
}
 8000b5a:	46bd      	mov	sp, r7
 8000b5c:	bc80      	pop	{r7}
 8000b5e:	4770      	bx	lr

08000b60 <vPortEnterCritical>:
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
 8000b60:	b580      	push	{r7, lr}
 8000b62:	af00      	add	r7, sp, #0
	portDISABLE_INTERRUPTS();
 8000b64:	f000 f828 	bl	8000bb8 <ulPortSetInterruptMask>
	uxCriticalNesting++;
 8000b68:	f240 0318 	movw	r3, #24
 8000b6c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000b70:	681b      	ldr	r3, [r3, #0]
 8000b72:	f103 0201 	add.w	r2, r3, #1
 8000b76:	f240 0318 	movw	r3, #24
 8000b7a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000b7e:	601a      	str	r2, [r3, #0]
}
 8000b80:	bd80      	pop	{r7, pc}
 8000b82:	bf00      	nop

08000b84 <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
 8000b84:	b580      	push	{r7, lr}
 8000b86:	af00      	add	r7, sp, #0
	uxCriticalNesting--;
 8000b88:	f240 0318 	movw	r3, #24
 8000b8c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000b90:	681b      	ldr	r3, [r3, #0]
 8000b92:	f103 32ff 	add.w	r2, r3, #4294967295	; 0xffffffff
 8000b96:	f240 0318 	movw	r3, #24
 8000b9a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000b9e:	601a      	str	r2, [r3, #0]
	if( uxCriticalNesting == 0 )
 8000ba0:	f240 0318 	movw	r3, #24
 8000ba4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000ba8:	681b      	ldr	r3, [r3, #0]
 8000baa:	2b00      	cmp	r3, #0
 8000bac:	d103      	bne.n	8000bb6 <vPortExitCritical+0x32>
	{
		portENABLE_INTERRUPTS();
 8000bae:	f04f 0000 	mov.w	r0, #0
 8000bb2:	f000 f80b 	bl	8000bcc <vPortClearInterruptMask>
	}
}
 8000bb6:	bd80      	pop	{r7, pc}

08000bb8 <ulPortSetInterruptMask>:
/*-----------------------------------------------------------*/

__attribute__(( naked )) unsigned long ulPortSetInterruptMask( void )
{
	__asm volatile														\
 8000bb8:	f3ef 8011 	mrs	r0, BASEPRI
 8000bbc:	f04f 0150 	mov.w	r1, #80	; 0x50
 8000bc0:	f381 8811 	msr	BASEPRI, r1
 8000bc4:	4770      	bx	lr
		:: "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "r0", "r1"	\
	);

	/* This return will not be reached but is necessary to prevent compiler
	warnings. */
	return 0;
 8000bc6:	f04f 0300 	mov.w	r3, #0
}
 8000bca:	4618      	mov	r0, r3

08000bcc <vPortClearInterruptMask>:
/*-----------------------------------------------------------*/

__attribute__(( naked )) void vPortClearInterruptMask( unsigned long ulNewMaskValue )
{
	__asm volatile													\
 8000bcc:	f380 8811 	msr	BASEPRI, r0
 8000bd0:	4770      	bx	lr
 8000bd2:	bf00      	nop

08000bd4 <PendSV_Handler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
 8000bd4:	f3ef 8009 	mrs	r0, PSP
 8000bd8:	4b11      	ldr	r3, [pc, #68]	; (8000c20 <pxCurrentTCBConst>)
 8000bda:	681a      	ldr	r2, [r3, #0]
 8000bdc:	f01e 0f10 	tst.w	lr, #16
 8000be0:	bf08      	it	eq
 8000be2:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
 8000be6:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000bea:	6010      	str	r0, [r2, #0]
 8000bec:	e92d 4008 	stmdb	sp!, {r3, lr}
 8000bf0:	f04f 0050 	mov.w	r0, #80	; 0x50
 8000bf4:	f380 8811 	msr	BASEPRI, r0
 8000bf8:	f001 fd42 	bl	8002680 <vTaskSwitchContext>
 8000bfc:	f04f 0000 	mov.w	r0, #0
 8000c00:	f380 8811 	msr	BASEPRI, r0
 8000c04:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 8000c08:	6819      	ldr	r1, [r3, #0]
 8000c0a:	6808      	ldr	r0, [r1, #0]
 8000c0c:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000c10:	f01e 0f10 	tst.w	lr, #16
 8000c14:	bf08      	it	eq
 8000c16:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
 8000c1a:	f380 8809 	msr	PSP, r0
 8000c1e:	4770      	bx	lr

08000c20 <pxCurrentTCBConst>:
 8000c20:	20012cb4 	.word	0x20012cb4

08000c24 <SysTick_Handler>:
	);
}
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
 8000c24:	b580      	push	{r7, lr}
 8000c26:	af00      	add	r7, sp, #0
	/* If using preemption, also force a context switch. */
	#if configUSE_PREEMPTION == 1
		portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 8000c28:	f64e 5304 	movw	r3, #60676	; 0xed04
 8000c2c:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8000c30:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8000c34:	601a      	str	r2, [r3, #0]
	to generate the tick interrupt. */
	#if configUSE_TICKLESS_IDLE == 1
		portNVIC_SYSTICK_LOAD_REG = ulTimerReloadValueForOneTick;
	#endif

	( void ) portSET_INTERRUPT_MASK_FROM_ISR();
 8000c36:	f7ff ffbf 	bl	8000bb8 <ulPortSetInterruptMask>
	{
		vTaskIncrementTick();
 8000c3a:	f001 fc31 	bl	80024a0 <vTaskIncrementTick>
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( 0 );
 8000c3e:	f04f 0000 	mov.w	r0, #0
 8000c42:	f7ff ffc3 	bl	8000bcc <vPortClearInterruptMask>
}
 8000c46:	bd80      	pop	{r7, pc}

08000c48 <vPortSetupTimerInterrupt>:
/*
 * Setup the systick timer to generate the tick interrupts at the required
 * frequency.
 */
__attribute__(( weak )) void vPortSetupTimerInterrupt( void )
{
 8000c48:	b480      	push	{r7}
 8000c4a:	af00      	add	r7, sp, #0
		ulStoppedTimerCompensation = 45UL / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
	}
	#endif /* configUSE_TICKLESS_IDLE */

	/* Configure SysTick to interrupt at the requested rate. */
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;;
 8000c4c:	f24e 0314 	movw	r3, #57364	; 0xe014
 8000c50:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8000c54:	f240 0204 	movw	r2, #4
 8000c58:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8000c5c:	6811      	ldr	r1, [r2, #0]
 8000c5e:	f644 52d3 	movw	r2, #19923	; 0x4dd3
 8000c62:	f2c1 0262 	movt	r2, #4194	; 0x1062
 8000c66:	fba2 0201 	umull	r0, r2, r2, r1
 8000c6a:	ea4f 1292 	mov.w	r2, r2, lsr #6
 8000c6e:	f102 32ff 	add.w	r2, r2, #4294967295	; 0xffffffff
 8000c72:	601a      	str	r2, [r3, #0]
	portNVIC_SYSTICK_CTRL_REG = portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT;
 8000c74:	f24e 0310 	movw	r3, #57360	; 0xe010
 8000c78:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8000c7c:	f04f 0207 	mov.w	r2, #7
 8000c80:	601a      	str	r2, [r3, #0]
}
 8000c82:	46bd      	mov	sp, r7
 8000c84:	bc80      	pop	{r7}
 8000c86:	4770      	bx	lr

08000c88 <vPortEnableVFP>:
/*-----------------------------------------------------------*/

/* This is a naked function. */
static void vPortEnableVFP( void )
{
	__asm volatile
 8000c88:	f8df 0010 	ldr.w	r0, [pc, #16]	; 8000c9c <vPortEnableVFP+0x14>
 8000c8c:	6801      	ldr	r1, [r0, #0]
 8000c8e:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8000c92:	6001      	str	r1, [r0, #0]
 8000c94:	4770      	bx	lr
 8000c96:	0000      	.short	0x0000
 8000c98:	e000ed08 	.word	0xe000ed08
 8000c9c:	e000ed88 	.word	0xe000ed88

08000ca0 <xQueueGenericReset>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

portBASE_TYPE xQueueGenericReset( xQueueHandle pxQueue, portBASE_TYPE xNewQueue )
{
 8000ca0:	b580      	push	{r7, lr}
 8000ca2:	b082      	sub	sp, #8
 8000ca4:	af00      	add	r7, sp, #0
 8000ca6:	6078      	str	r0, [r7, #4]
 8000ca8:	6039      	str	r1, [r7, #0]
	configASSERT( pxQueue );
 8000caa:	687b      	ldr	r3, [r7, #4]
 8000cac:	2b00      	cmp	r3, #0
 8000cae:	d102      	bne.n	8000cb6 <xQueueGenericReset+0x16>
 8000cb0:	f7ff ff82 	bl	8000bb8 <ulPortSetInterruptMask>
 8000cb4:	e7fe      	b.n	8000cb4 <xQueueGenericReset+0x14>

	taskENTER_CRITICAL();
 8000cb6:	f7ff ff53 	bl	8000b60 <vPortEnterCritical>
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 8000cba:	687b      	ldr	r3, [r7, #4]
 8000cbc:	681a      	ldr	r2, [r3, #0]
 8000cbe:	687b      	ldr	r3, [r7, #4]
 8000cc0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8000cc2:	6879      	ldr	r1, [r7, #4]
 8000cc4:	6c09      	ldr	r1, [r1, #64]	; 0x40
 8000cc6:	fb01 f303 	mul.w	r3, r1, r3
 8000cca:	18d2      	adds	r2, r2, r3
 8000ccc:	687b      	ldr	r3, [r7, #4]
 8000cce:	605a      	str	r2, [r3, #4]
		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
 8000cd0:	687b      	ldr	r3, [r7, #4]
 8000cd2:	f04f 0200 	mov.w	r2, #0
 8000cd6:	639a      	str	r2, [r3, #56]	; 0x38
		pxQueue->pcWriteTo = pxQueue->pcHead;
 8000cd8:	687b      	ldr	r3, [r7, #4]
 8000cda:	681a      	ldr	r2, [r3, #0]
 8000cdc:	687b      	ldr	r3, [r7, #4]
 8000cde:	609a      	str	r2, [r3, #8]
		pxQueue->pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned portBASE_TYPE ) 1U ) * pxQueue->uxItemSize );
 8000ce0:	687b      	ldr	r3, [r7, #4]
 8000ce2:	681a      	ldr	r2, [r3, #0]
 8000ce4:	687b      	ldr	r3, [r7, #4]
 8000ce6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8000ce8:	f103 33ff 	add.w	r3, r3, #4294967295	; 0xffffffff
 8000cec:	6879      	ldr	r1, [r7, #4]
 8000cee:	6c09      	ldr	r1, [r1, #64]	; 0x40
 8000cf0:	fb01 f303 	mul.w	r3, r1, r3
 8000cf4:	18d2      	adds	r2, r2, r3
 8000cf6:	687b      	ldr	r3, [r7, #4]
 8000cf8:	60da      	str	r2, [r3, #12]
		pxQueue->xRxLock = queueUNLOCKED;
 8000cfa:	687b      	ldr	r3, [r7, #4]
 8000cfc:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8000d00:	645a      	str	r2, [r3, #68]	; 0x44
		pxQueue->xTxLock = queueUNLOCKED;
 8000d02:	687b      	ldr	r3, [r7, #4]
 8000d04:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8000d08:	649a      	str	r2, [r3, #72]	; 0x48

		if( xNewQueue == pdFALSE )
 8000d0a:	683b      	ldr	r3, [r7, #0]
 8000d0c:	2b00      	cmp	r3, #0
 8000d0e:	d10f      	bne.n	8000d30 <xQueueGenericReset+0x90>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to	write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8000d10:	687b      	ldr	r3, [r7, #4]
 8000d12:	691b      	ldr	r3, [r3, #16]
 8000d14:	2b00      	cmp	r3, #0
 8000d16:	d017      	beq.n	8000d48 <xQueueGenericReset+0xa8>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 8000d18:	687b      	ldr	r3, [r7, #4]
 8000d1a:	f103 0310 	add.w	r3, r3, #16
 8000d1e:	4618      	mov	r0, r3
 8000d20:	f001 fdca 	bl	80028b8 <xTaskRemoveFromEventList>
 8000d24:	4603      	mov	r3, r0
 8000d26:	2b01      	cmp	r3, #1
 8000d28:	d10e      	bne.n	8000d48 <xQueueGenericReset+0xa8>
				{
					portYIELD_WITHIN_API();
 8000d2a:	f7ff ff0d 	bl	8000b48 <vPortYieldFromISR>
 8000d2e:	e00b      	b.n	8000d48 <xQueueGenericReset+0xa8>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 8000d30:	687b      	ldr	r3, [r7, #4]
 8000d32:	f103 0310 	add.w	r3, r3, #16
 8000d36:	4618      	mov	r0, r3
 8000d38:	f7ff fb9e 	bl	8000478 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 8000d3c:	687b      	ldr	r3, [r7, #4]
 8000d3e:	f103 0324 	add.w	r3, r3, #36	; 0x24
 8000d42:	4618      	mov	r0, r3
 8000d44:	f7ff fb98 	bl	8000478 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
 8000d48:	f7ff ff1c 	bl	8000b84 <vPortExitCritical>

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
 8000d4c:	f04f 0301 	mov.w	r3, #1
}
 8000d50:	4618      	mov	r0, r3
 8000d52:	f107 0708 	add.w	r7, r7, #8
 8000d56:	46bd      	mov	sp, r7
 8000d58:	bd80      	pop	{r7, pc}
 8000d5a:	bf00      	nop

08000d5c <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
{
 8000d5c:	b580      	push	{r7, lr}
 8000d5e:	b088      	sub	sp, #32
 8000d60:	af00      	add	r7, sp, #0
 8000d62:	60f8      	str	r0, [r7, #12]
 8000d64:	60b9      	str	r1, [r7, #8]
 8000d66:	4613      	mov	r3, r2
 8000d68:	71fb      	strb	r3, [r7, #7]
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
 8000d6a:	f04f 0300 	mov.w	r3, #0
 8000d6e:	61fb      	str	r3, [r7, #28]
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
 8000d70:	68fb      	ldr	r3, [r7, #12]
 8000d72:	2b00      	cmp	r3, #0
 8000d74:	d02d      	beq.n	8000dd2 <xQueueGenericCreate+0x76>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
 8000d76:	f04f 0050 	mov.w	r0, #80	; 0x50
 8000d7a:	f7ff fa21 	bl	80001c0 <pvPortMalloc>
 8000d7e:	61b8      	str	r0, [r7, #24]
		if( pxNewQueue != NULL )
 8000d80:	69bb      	ldr	r3, [r7, #24]
 8000d82:	2b00      	cmp	r3, #0
 8000d84:	d025      	beq.n	8000dd2 <xQueueGenericCreate+0x76>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
 8000d86:	68fb      	ldr	r3, [r7, #12]
 8000d88:	68ba      	ldr	r2, [r7, #8]
 8000d8a:	fb02 f303 	mul.w	r3, r2, r3
 8000d8e:	f103 0301 	add.w	r3, r3, #1
 8000d92:	617b      	str	r3, [r7, #20]

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
 8000d94:	6978      	ldr	r0, [r7, #20]
 8000d96:	f7ff fa13 	bl	80001c0 <pvPortMalloc>
 8000d9a:	4602      	mov	r2, r0
 8000d9c:	69bb      	ldr	r3, [r7, #24]
 8000d9e:	601a      	str	r2, [r3, #0]
			if( pxNewQueue->pcHead != NULL )
 8000da0:	69bb      	ldr	r3, [r7, #24]
 8000da2:	681b      	ldr	r3, [r3, #0]
 8000da4:	2b00      	cmp	r3, #0
 8000da6:	d011      	beq.n	8000dcc <xQueueGenericCreate+0x70>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
 8000da8:	69bb      	ldr	r3, [r7, #24]
 8000daa:	68fa      	ldr	r2, [r7, #12]
 8000dac:	63da      	str	r2, [r3, #60]	; 0x3c
				pxNewQueue->uxItemSize = uxItemSize;
 8000dae:	69bb      	ldr	r3, [r7, #24]
 8000db0:	68ba      	ldr	r2, [r7, #8]
 8000db2:	641a      	str	r2, [r3, #64]	; 0x40
				xQueueGenericReset( pxNewQueue, pdTRUE );
 8000db4:	69b8      	ldr	r0, [r7, #24]
 8000db6:	f04f 0101 	mov.w	r1, #1
 8000dba:	f7ff ff71 	bl	8000ca0 <xQueueGenericReset>
				#if ( configUSE_TRACE_FACILITY == 1 )
				{
					pxNewQueue->ucQueueType = ucQueueType;
 8000dbe:	69bb      	ldr	r3, [r7, #24]
 8000dc0:	79fa      	ldrb	r2, [r7, #7]
 8000dc2:	f883 204d 	strb.w	r2, [r3, #77]	; 0x4d
				}
				#endif /* configUSE_TRACE_FACILITY */

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
 8000dc6:	69bb      	ldr	r3, [r7, #24]
 8000dc8:	61fb      	str	r3, [r7, #28]
 8000dca:	e002      	b.n	8000dd2 <xQueueGenericCreate+0x76>
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
 8000dcc:	69b8      	ldr	r0, [r7, #24]
 8000dce:	f7ff fad7 	bl	8000380 <vPortFree>
			}
		}
	}

	configASSERT( xReturn );
 8000dd2:	69fb      	ldr	r3, [r7, #28]
 8000dd4:	2b00      	cmp	r3, #0
 8000dd6:	d102      	bne.n	8000dde <xQueueGenericCreate+0x82>
 8000dd8:	f7ff feee 	bl	8000bb8 <ulPortSetInterruptMask>
 8000ddc:	e7fe      	b.n	8000ddc <xQueueGenericCreate+0x80>

	return xReturn;
 8000dde:	69fb      	ldr	r3, [r7, #28]
}
 8000de0:	4618      	mov	r0, r3
 8000de2:	f107 0720 	add.w	r7, r7, #32
 8000de6:	46bd      	mov	sp, r7
 8000de8:	bd80      	pop	{r7, pc}
 8000dea:	bf00      	nop

08000dec <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( unsigned char ucQueueType )
	{
 8000dec:	b580      	push	{r7, lr}
 8000dee:	b084      	sub	sp, #16
 8000df0:	af00      	add	r7, sp, #0
 8000df2:	4603      	mov	r3, r0
 8000df4:	71fb      	strb	r3, [r7, #7]
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
 8000df6:	f04f 0050 	mov.w	r0, #80	; 0x50
 8000dfa:	f7ff f9e1 	bl	80001c0 <pvPortMalloc>
 8000dfe:	60f8      	str	r0, [r7, #12]
		if( pxNewQueue != NULL )
 8000e00:	68fb      	ldr	r3, [r7, #12]
 8000e02:	2b00      	cmp	r3, #0
 8000e04:	d03c      	beq.n	8000e80 <xQueueCreateMutex+0x94>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
 8000e06:	68fb      	ldr	r3, [r7, #12]
 8000e08:	f04f 0200 	mov.w	r2, #0
 8000e0c:	605a      	str	r2, [r3, #4]
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 8000e0e:	68fb      	ldr	r3, [r7, #12]
 8000e10:	f04f 0200 	mov.w	r2, #0
 8000e14:	601a      	str	r2, [r3, #0]

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
 8000e16:	68fb      	ldr	r3, [r7, #12]
 8000e18:	f04f 0200 	mov.w	r2, #0
 8000e1c:	609a      	str	r2, [r3, #8]
			pxNewQueue->pcReadFrom = NULL;
 8000e1e:	68fb      	ldr	r3, [r7, #12]
 8000e20:	f04f 0200 	mov.w	r2, #0
 8000e24:	60da      	str	r2, [r3, #12]

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
 8000e26:	68fb      	ldr	r3, [r7, #12]
 8000e28:	f04f 0200 	mov.w	r2, #0
 8000e2c:	639a      	str	r2, [r3, #56]	; 0x38
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
 8000e2e:	68fb      	ldr	r3, [r7, #12]
 8000e30:	f04f 0201 	mov.w	r2, #1
 8000e34:	63da      	str	r2, [r3, #60]	; 0x3c
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
 8000e36:	68fb      	ldr	r3, [r7, #12]
 8000e38:	f04f 0200 	mov.w	r2, #0
 8000e3c:	641a      	str	r2, [r3, #64]	; 0x40
			pxNewQueue->xRxLock = queueUNLOCKED;
 8000e3e:	68fb      	ldr	r3, [r7, #12]
 8000e40:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8000e44:	645a      	str	r2, [r3, #68]	; 0x44
			pxNewQueue->xTxLock = queueUNLOCKED;
 8000e46:	68fb      	ldr	r3, [r7, #12]
 8000e48:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8000e4c:	649a      	str	r2, [r3, #72]	; 0x48

			#if ( configUSE_TRACE_FACILITY == 1 )
			{
				pxNewQueue->ucQueueType = ucQueueType;
 8000e4e:	68fb      	ldr	r3, [r7, #12]
 8000e50:	79fa      	ldrb	r2, [r7, #7]
 8000e52:	f883 204d 	strb.w	r2, [r3, #77]	; 0x4d
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
 8000e56:	68fb      	ldr	r3, [r7, #12]
 8000e58:	f103 0310 	add.w	r3, r3, #16
 8000e5c:	4618      	mov	r0, r3
 8000e5e:	f7ff fb0b 	bl	8000478 <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
 8000e62:	68fb      	ldr	r3, [r7, #12]
 8000e64:	f103 0324 	add.w	r3, r3, #36	; 0x24
 8000e68:	4618      	mov	r0, r3
 8000e6a:	f7ff fb05 	bl	8000478 <vListInitialise>

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
 8000e6e:	68f8      	ldr	r0, [r7, #12]
 8000e70:	f04f 0100 	mov.w	r1, #0
 8000e74:	f04f 0200 	mov.w	r2, #0
 8000e78:	f04f 0300 	mov.w	r3, #0
 8000e7c:	f000 f892 	bl	8000fa4 <xQueueGenericSend>
		else
		{
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
 8000e80:	68fb      	ldr	r3, [r7, #12]
 8000e82:	2b00      	cmp	r3, #0
 8000e84:	d102      	bne.n	8000e8c <xQueueCreateMutex+0xa0>
 8000e86:	f7ff fe97 	bl	8000bb8 <ulPortSetInterruptMask>
 8000e8a:	e7fe      	b.n	8000e8a <xQueueCreateMutex+0x9e>
		return pxNewQueue;
 8000e8c:	68fb      	ldr	r3, [r7, #12]
	}
 8000e8e:	4618      	mov	r0, r3
 8000e90:	f107 0710 	add.w	r7, r7, #16
 8000e94:	46bd      	mov	sp, r7
 8000e96:	bd80      	pop	{r7, pc}

08000e98 <xQueueGiveMutexRecursive>:
/*-----------------------------------------------------------*/

#if ( configUSE_RECURSIVE_MUTEXES == 1 )

	portBASE_TYPE xQueueGiveMutexRecursive( xQueueHandle pxMutex )
	{
 8000e98:	b590      	push	{r4, r7, lr}
 8000e9a:	b085      	sub	sp, #20
 8000e9c:	af00      	add	r7, sp, #0
 8000e9e:	6078      	str	r0, [r7, #4]
	portBASE_TYPE xReturn;

		configASSERT( pxMutex );
 8000ea0:	687b      	ldr	r3, [r7, #4]
 8000ea2:	2b00      	cmp	r3, #0
 8000ea4:	d102      	bne.n	8000eac <xQueueGiveMutexRecursive+0x14>
 8000ea6:	f7ff fe87 	bl	8000bb8 <ulPortSetInterruptMask>
 8000eaa:	e7fe      	b.n	8000eaa <xQueueGiveMutexRecursive+0x12>
		change outside of this task.  If this task does not hold the mutex then
		pxMutexHolder can never coincidentally equal the tasks handle, and as
		this is the only condition we are interested in it does not matter if
		pxMutexHolder is accessed simultaneously by another task.  Therefore no
		mutual exclusion is required to test the pxMutexHolder variable. */
		if( pxMutex->pxMutexHolder == xTaskGetCurrentTaskHandle() )
 8000eac:	687b      	ldr	r3, [r7, #4]
 8000eae:	685c      	ldr	r4, [r3, #4]
 8000eb0:	f002 f814 	bl	8002edc <xTaskGetCurrentTaskHandle>
 8000eb4:	4603      	mov	r3, r0
 8000eb6:	429c      	cmp	r4, r3
 8000eb8:	d116      	bne.n	8000ee8 <xQueueGiveMutexRecursive+0x50>
			/* uxRecursiveCallCount cannot be zero if pxMutexHolder is equal to
			the task handle, therefore no underflow check is required.  Also,
			uxRecursiveCallCount is only modified by the mutex holder, and as
			there can only be one, no mutual exclusion is required to modify the
			uxRecursiveCallCount member. */
			( pxMutex->uxRecursiveCallCount )--;
 8000eba:	687b      	ldr	r3, [r7, #4]
 8000ebc:	68db      	ldr	r3, [r3, #12]
 8000ebe:	f103 32ff 	add.w	r2, r3, #4294967295	; 0xffffffff
 8000ec2:	687b      	ldr	r3, [r7, #4]
 8000ec4:	60da      	str	r2, [r3, #12]

			/* Have we unwound the call count? */
			if( pxMutex->uxRecursiveCallCount == 0 )
 8000ec6:	687b      	ldr	r3, [r7, #4]
 8000ec8:	68db      	ldr	r3, [r3, #12]
 8000eca:	2b00      	cmp	r3, #0
 8000ecc:	d108      	bne.n	8000ee0 <xQueueGiveMutexRecursive+0x48>
			{
				/* Return the mutex.  This will automatically unblock any other
				task that might be waiting to access the mutex. */
				xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
 8000ece:	6878      	ldr	r0, [r7, #4]
 8000ed0:	f04f 0100 	mov.w	r1, #0
 8000ed4:	f04f 0200 	mov.w	r2, #0
 8000ed8:	f04f 0300 	mov.w	r3, #0
 8000edc:	f000 f862 	bl	8000fa4 <xQueueGenericSend>
			}

			xReturn = pdPASS;
 8000ee0:	f04f 0301 	mov.w	r3, #1
 8000ee4:	60fb      	str	r3, [r7, #12]
 8000ee6:	e002      	b.n	8000eee <xQueueGiveMutexRecursive+0x56>
		}
		else
		{
			/* We cannot give the mutex because we are not the holder. */
			xReturn = pdFAIL;
 8000ee8:	f04f 0300 	mov.w	r3, #0
 8000eec:	60fb      	str	r3, [r7, #12]

			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
		}

		return xReturn;
 8000eee:	68fb      	ldr	r3, [r7, #12]
	}
 8000ef0:	4618      	mov	r0, r3
 8000ef2:	f107 0714 	add.w	r7, r7, #20
 8000ef6:	46bd      	mov	sp, r7
 8000ef8:	bd90      	pop	{r4, r7, pc}
 8000efa:	bf00      	nop

08000efc <xQueueTakeMutexRecursive>:
/*-----------------------------------------------------------*/

#if configUSE_RECURSIVE_MUTEXES == 1

	portBASE_TYPE xQueueTakeMutexRecursive( xQueueHandle pxMutex, portTickType xBlockTime )
	{
 8000efc:	b590      	push	{r4, r7, lr}
 8000efe:	b085      	sub	sp, #20
 8000f00:	af00      	add	r7, sp, #0
 8000f02:	6078      	str	r0, [r7, #4]
 8000f04:	6039      	str	r1, [r7, #0]
	portBASE_TYPE xReturn;

		configASSERT( pxMutex );
 8000f06:	687b      	ldr	r3, [r7, #4]
 8000f08:	2b00      	cmp	r3, #0
 8000f0a:	d102      	bne.n	8000f12 <xQueueTakeMutexRecursive+0x16>
 8000f0c:	f7ff fe54 	bl	8000bb8 <ulPortSetInterruptMask>
 8000f10:	e7fe      	b.n	8000f10 <xQueueTakeMutexRecursive+0x14>
		/* Comments regarding mutual exclusion as per those within
		xQueueGiveMutexRecursive(). */

		traceTAKE_MUTEX_RECURSIVE( pxMutex );

		if( pxMutex->pxMutexHolder == xTaskGetCurrentTaskHandle() )
 8000f12:	687b      	ldr	r3, [r7, #4]
 8000f14:	685c      	ldr	r4, [r3, #4]
 8000f16:	f001 ffe1 	bl	8002edc <xTaskGetCurrentTaskHandle>
 8000f1a:	4603      	mov	r3, r0
 8000f1c:	429c      	cmp	r4, r3
 8000f1e:	d109      	bne.n	8000f34 <xQueueTakeMutexRecursive+0x38>
		{
			( pxMutex->uxRecursiveCallCount )++;
 8000f20:	687b      	ldr	r3, [r7, #4]
 8000f22:	68db      	ldr	r3, [r3, #12]
 8000f24:	f103 0201 	add.w	r2, r3, #1
 8000f28:	687b      	ldr	r3, [r7, #4]
 8000f2a:	60da      	str	r2, [r3, #12]
			xReturn = pdPASS;
 8000f2c:	f04f 0301 	mov.w	r3, #1
 8000f30:	60fb      	str	r3, [r7, #12]
 8000f32:	e011      	b.n	8000f58 <xQueueTakeMutexRecursive+0x5c>
		}
		else
		{
			xReturn = xQueueGenericReceive( pxMutex, NULL, xBlockTime, pdFALSE );
 8000f34:	6878      	ldr	r0, [r7, #4]
 8000f36:	f04f 0100 	mov.w	r1, #0
 8000f3a:	683a      	ldr	r2, [r7, #0]
 8000f3c:	f04f 0300 	mov.w	r3, #0
 8000f40:	f000 f932 	bl	80011a8 <xQueueGenericReceive>
 8000f44:	60f8      	str	r0, [r7, #12]

			/* pdPASS will only be returned if we successfully obtained the mutex,
			we may have blocked to reach here. */
			if( xReturn == pdPASS )
 8000f46:	68fb      	ldr	r3, [r7, #12]
 8000f48:	2b01      	cmp	r3, #1
 8000f4a:	d105      	bne.n	8000f58 <xQueueTakeMutexRecursive+0x5c>
			{
				( pxMutex->uxRecursiveCallCount )++;
 8000f4c:	687b      	ldr	r3, [r7, #4]
 8000f4e:	68db      	ldr	r3, [r3, #12]
 8000f50:	f103 0201 	add.w	r2, r3, #1
 8000f54:	687b      	ldr	r3, [r7, #4]
 8000f56:	60da      	str	r2, [r3, #12]
			{
				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
			}
		}

		return xReturn;
 8000f58:	68fb      	ldr	r3, [r7, #12]
	}
 8000f5a:	4618      	mov	r0, r3
 8000f5c:	f107 0714 	add.w	r7, r7, #20
 8000f60:	46bd      	mov	sp, r7
 8000f62:	bd90      	pop	{r4, r7, pc}

08000f64 <xQueueCreateCountingSemaphore>:
/*-----------------------------------------------------------*/

#if configUSE_COUNTING_SEMAPHORES == 1

	xQueueHandle xQueueCreateCountingSemaphore( unsigned portBASE_TYPE uxCountValue, unsigned portBASE_TYPE uxInitialCount )
	{
 8000f64:	b580      	push	{r7, lr}
 8000f66:	b084      	sub	sp, #16
 8000f68:	af00      	add	r7, sp, #0
 8000f6a:	6078      	str	r0, [r7, #4]
 8000f6c:	6039      	str	r1, [r7, #0]
	xQueueHandle pxHandle;

		pxHandle = xQueueGenericCreate( ( unsigned portBASE_TYPE ) uxCountValue, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
 8000f6e:	6878      	ldr	r0, [r7, #4]
 8000f70:	f04f 0100 	mov.w	r1, #0
 8000f74:	f04f 0202 	mov.w	r2, #2
 8000f78:	f7ff fef0 	bl	8000d5c <xQueueGenericCreate>
 8000f7c:	60f8      	str	r0, [r7, #12]

		if( pxHandle != NULL )
 8000f7e:	68fb      	ldr	r3, [r7, #12]
 8000f80:	2b00      	cmp	r3, #0
 8000f82:	d002      	beq.n	8000f8a <xQueueCreateCountingSemaphore+0x26>
		{
			pxHandle->uxMessagesWaiting = uxInitialCount;
 8000f84:	68fb      	ldr	r3, [r7, #12]
 8000f86:	683a      	ldr	r2, [r7, #0]
 8000f88:	639a      	str	r2, [r3, #56]	; 0x38
		else
		{
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		configASSERT( pxHandle );
 8000f8a:	68fb      	ldr	r3, [r7, #12]
 8000f8c:	2b00      	cmp	r3, #0
 8000f8e:	d102      	bne.n	8000f96 <xQueueCreateCountingSemaphore+0x32>
 8000f90:	f7ff fe12 	bl	8000bb8 <ulPortSetInterruptMask>
 8000f94:	e7fe      	b.n	8000f94 <xQueueCreateCountingSemaphore+0x30>
		return pxHandle;
 8000f96:	68fb      	ldr	r3, [r7, #12]
	}
 8000f98:	4618      	mov	r0, r3
 8000f9a:	f107 0710 	add.w	r7, r7, #16
 8000f9e:	46bd      	mov	sp, r7
 8000fa0:	bd80      	pop	{r7, pc}
 8000fa2:	bf00      	nop

08000fa4 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
 8000fa4:	b580      	push	{r7, lr}
 8000fa6:	b088      	sub	sp, #32
 8000fa8:	af00      	add	r7, sp, #0
 8000faa:	60f8      	str	r0, [r7, #12]
 8000fac:	60b9      	str	r1, [r7, #8]
 8000fae:	607a      	str	r2, [r7, #4]
 8000fb0:	603b      	str	r3, [r7, #0]
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 8000fb2:	f04f 0300 	mov.w	r3, #0
 8000fb6:	61fb      	str	r3, [r7, #28]
xTimeOutType xTimeOut;

	configASSERT( pxQueue );
 8000fb8:	68fb      	ldr	r3, [r7, #12]
 8000fba:	2b00      	cmp	r3, #0
 8000fbc:	d102      	bne.n	8000fc4 <xQueueGenericSend+0x20>
 8000fbe:	f7ff fdfb 	bl	8000bb8 <ulPortSetInterruptMask>
 8000fc2:	e7fe      	b.n	8000fc2 <xQueueGenericSend+0x1e>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
 8000fc4:	68bb      	ldr	r3, [r7, #8]
 8000fc6:	2b00      	cmp	r3, #0
 8000fc8:	d103      	bne.n	8000fd2 <xQueueGenericSend+0x2e>
 8000fca:	68fb      	ldr	r3, [r7, #12]
 8000fcc:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8000fce:	2b00      	cmp	r3, #0
 8000fd0:	d102      	bne.n	8000fd8 <xQueueGenericSend+0x34>
 8000fd2:	f04f 0301 	mov.w	r3, #1
 8000fd6:	e001      	b.n	8000fdc <xQueueGenericSend+0x38>
 8000fd8:	f04f 0300 	mov.w	r3, #0
 8000fdc:	2b00      	cmp	r3, #0
 8000fde:	d103      	bne.n	8000fe8 <xQueueGenericSend+0x44>
 8000fe0:	f7ff fdea 	bl	8000bb8 <ulPortSetInterruptMask>
 8000fe4:	e7fe      	b.n	8000fe4 <xQueueGenericSend+0x40>
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
 8000fe6:	bf00      	nop
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
 8000fe8:	f7ff fdba 	bl	8000b60 <vPortEnterCritical>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 8000fec:	68fb      	ldr	r3, [r7, #12]
 8000fee:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8000ff0:	68fb      	ldr	r3, [r7, #12]
 8000ff2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8000ff4:	429a      	cmp	r2, r3
 8000ff6:	d218      	bcs.n	800102a <xQueueGenericSend+0x86>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 8000ff8:	68f8      	ldr	r0, [r7, #12]
 8000ffa:	68b9      	ldr	r1, [r7, #8]
 8000ffc:	683a      	ldr	r2, [r7, #0]
 8000ffe:	f000 fa7d 	bl	80014fc <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8001002:	68fb      	ldr	r3, [r7, #12]
 8001004:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001006:	2b00      	cmp	r3, #0
 8001008:	d00a      	beq.n	8001020 <xQueueGenericSend+0x7c>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 800100a:	68fb      	ldr	r3, [r7, #12]
 800100c:	f103 0324 	add.w	r3, r3, #36	; 0x24
 8001010:	4618      	mov	r0, r3
 8001012:	f001 fc51 	bl	80028b8 <xTaskRemoveFromEventList>
 8001016:	4603      	mov	r3, r0
 8001018:	2b01      	cmp	r3, #1
 800101a:	d101      	bne.n	8001020 <xQueueGenericSend+0x7c>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
 800101c:	f7ff fd94 	bl	8000b48 <vPortYieldFromISR>
					}
				}

				taskEXIT_CRITICAL();
 8001020:	f7ff fdb0 	bl	8000b84 <vPortExitCritical>

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
 8001024:	f04f 0301 	mov.w	r3, #1
 8001028:	e05d      	b.n	80010e6 <xQueueGenericSend+0x142>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
 800102a:	687b      	ldr	r3, [r7, #4]
 800102c:	2b00      	cmp	r3, #0
 800102e:	d104      	bne.n	800103a <xQueueGenericSend+0x96>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
 8001030:	f7ff fda8 	bl	8000b84 <vPortExitCritical>

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
 8001034:	f04f 0300 	mov.w	r3, #0
 8001038:	e055      	b.n	80010e6 <xQueueGenericSend+0x142>
				}
				else if( xEntryTimeSet == pdFALSE )
 800103a:	69fb      	ldr	r3, [r7, #28]
 800103c:	2b00      	cmp	r3, #0
 800103e:	d107      	bne.n	8001050 <xQueueGenericSend+0xac>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
 8001040:	f107 0314 	add.w	r3, r7, #20
 8001044:	4618      	mov	r0, r3
 8001046:	f001 fc9f 	bl	8002988 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
 800104a:	f04f 0301 	mov.w	r3, #1
 800104e:	61fb      	str	r3, [r7, #28]
				}
			}
		}
		taskEXIT_CRITICAL();
 8001050:	f7ff fd98 	bl	8000b84 <vPortExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
 8001054:	f001 f89c 	bl	8002190 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 8001058:	f7ff fd82 	bl	8000b60 <vPortEnterCritical>
 800105c:	68fb      	ldr	r3, [r7, #12]
 800105e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8001060:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8001064:	d103      	bne.n	800106e <xQueueGenericSend+0xca>
 8001066:	68fb      	ldr	r3, [r7, #12]
 8001068:	f04f 0200 	mov.w	r2, #0
 800106c:	645a      	str	r2, [r3, #68]	; 0x44
 800106e:	68fb      	ldr	r3, [r7, #12]
 8001070:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8001072:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8001076:	d103      	bne.n	8001080 <xQueueGenericSend+0xdc>
 8001078:	68fb      	ldr	r3, [r7, #12]
 800107a:	f04f 0200 	mov.w	r2, #0
 800107e:	649a      	str	r2, [r3, #72]	; 0x48
 8001080:	f7ff fd80 	bl	8000b84 <vPortExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 8001084:	f107 0214 	add.w	r2, r7, #20
 8001088:	f107 0304 	add.w	r3, r7, #4
 800108c:	4610      	mov	r0, r2
 800108e:	4619      	mov	r1, r3
 8001090:	f001 fc96 	bl	80029c0 <xTaskCheckForTimeOut>
 8001094:	4603      	mov	r3, r0
 8001096:	2b00      	cmp	r3, #0
 8001098:	d11e      	bne.n	80010d8 <xQueueGenericSend+0x134>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 800109a:	68f8      	ldr	r0, [r7, #12]
 800109c:	f000 fb36 	bl	800170c <prvIsQueueFull>
 80010a0:	4603      	mov	r3, r0
 80010a2:	2b00      	cmp	r3, #0
 80010a4:	d012      	beq.n	80010cc <xQueueGenericSend+0x128>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 80010a6:	68fb      	ldr	r3, [r7, #12]
 80010a8:	f103 0210 	add.w	r2, r3, #16
 80010ac:	687b      	ldr	r3, [r7, #4]
 80010ae:	4610      	mov	r0, r2
 80010b0:	4619      	mov	r1, r3
 80010b2:	f001 fb8f 	bl	80027d4 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
 80010b6:	68f8      	ldr	r0, [r7, #12]
 80010b8:	f000 faaa 	bl	8001610 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
 80010bc:	f001 f87a 	bl	80021b4 <xTaskResumeAll>
 80010c0:	4603      	mov	r3, r0
 80010c2:	2b00      	cmp	r3, #0
 80010c4:	d18f      	bne.n	8000fe6 <xQueueGenericSend+0x42>
				{
					portYIELD_WITHIN_API();
 80010c6:	f7ff fd3f 	bl	8000b48 <vPortYieldFromISR>
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
 80010ca:	e78c      	b.n	8000fe6 <xQueueGenericSend+0x42>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
 80010cc:	68f8      	ldr	r0, [r7, #12]
 80010ce:	f000 fa9f 	bl	8001610 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 80010d2:	f001 f86f 	bl	80021b4 <xTaskResumeAll>
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
 80010d6:	e786      	b.n	8000fe6 <xQueueGenericSend+0x42>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
 80010d8:	68f8      	ldr	r0, [r7, #12]
 80010da:	f000 fa99 	bl	8001610 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 80010de:	f001 f869 	bl	80021b4 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
 80010e2:	f04f 0300 	mov.w	r3, #0
		}
	}
}
 80010e6:	4618      	mov	r0, r3
 80010e8:	f107 0720 	add.w	r7, r7, #32
 80010ec:	46bd      	mov	sp, r7
 80010ee:	bd80      	pop	{r7, pc}

080010f0 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
 80010f0:	b580      	push	{r7, lr}
 80010f2:	b086      	sub	sp, #24
 80010f4:	af00      	add	r7, sp, #0
 80010f6:	60f8      	str	r0, [r7, #12]
 80010f8:	60b9      	str	r1, [r7, #8]
 80010fa:	607a      	str	r2, [r7, #4]
 80010fc:	603b      	str	r3, [r7, #0]
signed portBASE_TYPE xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	configASSERT( pxQueue );
 80010fe:	68fb      	ldr	r3, [r7, #12]
 8001100:	2b00      	cmp	r3, #0
 8001102:	d102      	bne.n	800110a <xQueueGenericSendFromISR+0x1a>
 8001104:	f7ff fd58 	bl	8000bb8 <ulPortSetInterruptMask>
 8001108:	e7fe      	b.n	8001108 <xQueueGenericSendFromISR+0x18>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
 800110a:	68bb      	ldr	r3, [r7, #8]
 800110c:	2b00      	cmp	r3, #0
 800110e:	d103      	bne.n	8001118 <xQueueGenericSendFromISR+0x28>
 8001110:	68fb      	ldr	r3, [r7, #12]
 8001112:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8001114:	2b00      	cmp	r3, #0
 8001116:	d102      	bne.n	800111e <xQueueGenericSendFromISR+0x2e>
 8001118:	f04f 0301 	mov.w	r3, #1
 800111c:	e001      	b.n	8001122 <xQueueGenericSendFromISR+0x32>
 800111e:	f04f 0300 	mov.w	r3, #0
 8001122:	2b00      	cmp	r3, #0
 8001124:	d102      	bne.n	800112c <xQueueGenericSendFromISR+0x3c>
 8001126:	f7ff fd47 	bl	8000bb8 <ulPortSetInterruptMask>
 800112a:	e7fe      	b.n	800112a <xQueueGenericSendFromISR+0x3a>
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 800112c:	f7ff fd44 	bl	8000bb8 <ulPortSetInterruptMask>
 8001130:	6138      	str	r0, [r7, #16]
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 8001132:	68fb      	ldr	r3, [r7, #12]
 8001134:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8001136:	68fb      	ldr	r3, [r7, #12]
 8001138:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800113a:	429a      	cmp	r2, r3
 800113c:	d228      	bcs.n	8001190 <xQueueGenericSendFromISR+0xa0>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 800113e:	68f8      	ldr	r0, [r7, #12]
 8001140:	68b9      	ldr	r1, [r7, #8]
 8001142:	683a      	ldr	r2, [r7, #0]
 8001144:	f000 f9da 	bl	80014fc <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
 8001148:	68fb      	ldr	r3, [r7, #12]
 800114a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800114c:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8001150:	d114      	bne.n	800117c <xQueueGenericSendFromISR+0x8c>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8001152:	68fb      	ldr	r3, [r7, #12]
 8001154:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001156:	2b00      	cmp	r3, #0
 8001158:	d016      	beq.n	8001188 <xQueueGenericSendFromISR+0x98>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800115a:	68fb      	ldr	r3, [r7, #12]
 800115c:	f103 0324 	add.w	r3, r3, #36	; 0x24
 8001160:	4618      	mov	r0, r3
 8001162:	f001 fba9 	bl	80028b8 <xTaskRemoveFromEventList>
 8001166:	4603      	mov	r3, r0
 8001168:	2b00      	cmp	r3, #0
 800116a:	d00d      	beq.n	8001188 <xQueueGenericSendFromISR+0x98>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						if( pxHigherPriorityTaskWoken != NULL )
 800116c:	687b      	ldr	r3, [r7, #4]
 800116e:	2b00      	cmp	r3, #0
 8001170:	d00a      	beq.n	8001188 <xQueueGenericSendFromISR+0x98>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
 8001172:	687b      	ldr	r3, [r7, #4]
 8001174:	f04f 0201 	mov.w	r2, #1
 8001178:	601a      	str	r2, [r3, #0]
 800117a:	e005      	b.n	8001188 <xQueueGenericSendFromISR+0x98>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
 800117c:	68fb      	ldr	r3, [r7, #12]
 800117e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8001180:	f103 0201 	add.w	r2, r3, #1
 8001184:	68fb      	ldr	r3, [r7, #12]
 8001186:	649a      	str	r2, [r3, #72]	; 0x48
			}

			xReturn = pdPASS;
 8001188:	f04f 0301 	mov.w	r3, #1
 800118c:	617b      	str	r3, [r7, #20]
 800118e:	e002      	b.n	8001196 <xQueueGenericSendFromISR+0xa6>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
 8001190:	f04f 0300 	mov.w	r3, #0
 8001194:	617b      	str	r3, [r7, #20]
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 8001196:	6938      	ldr	r0, [r7, #16]
 8001198:	f7ff fd18 	bl	8000bcc <vPortClearInterruptMask>

	return xReturn;
 800119c:	697b      	ldr	r3, [r7, #20]
}
 800119e:	4618      	mov	r0, r3
 80011a0:	f107 0718 	add.w	r7, r7, #24
 80011a4:	46bd      	mov	sp, r7
 80011a6:	bd80      	pop	{r7, pc}

080011a8 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
 80011a8:	b580      	push	{r7, lr}
 80011aa:	b088      	sub	sp, #32
 80011ac:	af00      	add	r7, sp, #0
 80011ae:	60f8      	str	r0, [r7, #12]
 80011b0:	60b9      	str	r1, [r7, #8]
 80011b2:	607a      	str	r2, [r7, #4]
 80011b4:	603b      	str	r3, [r7, #0]
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 80011b6:	f04f 0300 	mov.w	r3, #0
 80011ba:	61fb      	str	r3, [r7, #28]
xTimeOutType xTimeOut;
signed char *pcOriginalReadPosition;

	configASSERT( pxQueue );
 80011bc:	68fb      	ldr	r3, [r7, #12]
 80011be:	2b00      	cmp	r3, #0
 80011c0:	d102      	bne.n	80011c8 <xQueueGenericReceive+0x20>
 80011c2:	f7ff fcf9 	bl	8000bb8 <ulPortSetInterruptMask>
 80011c6:	e7fe      	b.n	80011c6 <xQueueGenericReceive+0x1e>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
 80011c8:	68bb      	ldr	r3, [r7, #8]
 80011ca:	2b00      	cmp	r3, #0
 80011cc:	d103      	bne.n	80011d6 <xQueueGenericReceive+0x2e>
 80011ce:	68fb      	ldr	r3, [r7, #12]
 80011d0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80011d2:	2b00      	cmp	r3, #0
 80011d4:	d102      	bne.n	80011dc <xQueueGenericReceive+0x34>
 80011d6:	f04f 0301 	mov.w	r3, #1
 80011da:	e001      	b.n	80011e0 <xQueueGenericReceive+0x38>
 80011dc:	f04f 0300 	mov.w	r3, #0
 80011e0:	2b00      	cmp	r3, #0
 80011e2:	d103      	bne.n	80011ec <xQueueGenericReceive+0x44>
 80011e4:	f7ff fce8 	bl	8000bb8 <ulPortSetInterruptMask>
 80011e8:	e7fe      	b.n	80011e8 <xQueueGenericReceive+0x40>
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
 80011ea:	bf00      	nop
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
 80011ec:	f7ff fcb8 	bl	8000b60 <vPortEnterCritical>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 80011f0:	68fb      	ldr	r3, [r7, #12]
 80011f2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80011f4:	2b00      	cmp	r3, #0
 80011f6:	d03f      	beq.n	8001278 <xQueueGenericReceive+0xd0>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
 80011f8:	68fb      	ldr	r3, [r7, #12]
 80011fa:	68db      	ldr	r3, [r3, #12]
 80011fc:	61bb      	str	r3, [r7, #24]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
 80011fe:	68f8      	ldr	r0, [r7, #12]
 8001200:	68b9      	ldr	r1, [r7, #8]
 8001202:	f000 f9dd 	bl	80015c0 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
 8001206:	683b      	ldr	r3, [r7, #0]
 8001208:	2b00      	cmp	r3, #0
 800120a:	d11e      	bne.n	800124a <xQueueGenericReceive+0xa2>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
 800120c:	68fb      	ldr	r3, [r7, #12]
 800120e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8001210:	f103 32ff 	add.w	r2, r3, #4294967295	; 0xffffffff
 8001214:	68fb      	ldr	r3, [r7, #12]
 8001216:	639a      	str	r2, [r3, #56]	; 0x38

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8001218:	68fb      	ldr	r3, [r7, #12]
 800121a:	681b      	ldr	r3, [r3, #0]
 800121c:	2b00      	cmp	r3, #0
 800121e:	d104      	bne.n	800122a <xQueueGenericReceive+0x82>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
 8001220:	f001 fe5c 	bl	8002edc <xTaskGetCurrentTaskHandle>
 8001224:	4602      	mov	r2, r0
 8001226:	68fb      	ldr	r3, [r7, #12]
 8001228:	605a      	str	r2, [r3, #4]
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800122a:	68fb      	ldr	r3, [r7, #12]
 800122c:	691b      	ldr	r3, [r3, #16]
 800122e:	2b00      	cmp	r3, #0
 8001230:	d01d      	beq.n	800126e <xQueueGenericReceive+0xc6>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 8001232:	68fb      	ldr	r3, [r7, #12]
 8001234:	f103 0310 	add.w	r3, r3, #16
 8001238:	4618      	mov	r0, r3
 800123a:	f001 fb3d 	bl	80028b8 <xTaskRemoveFromEventList>
 800123e:	4603      	mov	r3, r0
 8001240:	2b01      	cmp	r3, #1
 8001242:	d114      	bne.n	800126e <xQueueGenericReceive+0xc6>
						{
							portYIELD_WITHIN_API();
 8001244:	f7ff fc80 	bl	8000b48 <vPortYieldFromISR>
 8001248:	e011      	b.n	800126e <xQueueGenericReceive+0xc6>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
 800124a:	68fb      	ldr	r3, [r7, #12]
 800124c:	69ba      	ldr	r2, [r7, #24]
 800124e:	60da      	str	r2, [r3, #12]

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8001250:	68fb      	ldr	r3, [r7, #12]
 8001252:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001254:	2b00      	cmp	r3, #0
 8001256:	d00a      	beq.n	800126e <xQueueGenericReceive+0xc6>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8001258:	68fb      	ldr	r3, [r7, #12]
 800125a:	f103 0324 	add.w	r3, r3, #36	; 0x24
 800125e:	4618      	mov	r0, r3
 8001260:	f001 fb2a 	bl	80028b8 <xTaskRemoveFromEventList>
 8001264:	4603      	mov	r3, r0
 8001266:	2b00      	cmp	r3, #0
 8001268:	d001      	beq.n	800126e <xQueueGenericReceive+0xc6>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
 800126a:	f7ff fc6d 	bl	8000b48 <vPortYieldFromISR>
						}
					}
				}

				taskEXIT_CRITICAL();
 800126e:	f7ff fc89 	bl	8000b84 <vPortExitCritical>
				return pdPASS;
 8001272:	f04f 0301 	mov.w	r3, #1
 8001276:	e06b      	b.n	8001350 <xQueueGenericReceive+0x1a8>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
 8001278:	687b      	ldr	r3, [r7, #4]
 800127a:	2b00      	cmp	r3, #0
 800127c:	d104      	bne.n	8001288 <xQueueGenericReceive+0xe0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
 800127e:	f7ff fc81 	bl	8000b84 <vPortExitCritical>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
 8001282:	f04f 0300 	mov.w	r3, #0
 8001286:	e063      	b.n	8001350 <xQueueGenericReceive+0x1a8>
				}
				else if( xEntryTimeSet == pdFALSE )
 8001288:	69fb      	ldr	r3, [r7, #28]
 800128a:	2b00      	cmp	r3, #0
 800128c:	d107      	bne.n	800129e <xQueueGenericReceive+0xf6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
 800128e:	f107 0310 	add.w	r3, r7, #16
 8001292:	4618      	mov	r0, r3
 8001294:	f001 fb78 	bl	8002988 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
 8001298:	f04f 0301 	mov.w	r3, #1
 800129c:	61fb      	str	r3, [r7, #28]
				}
			}
		}
		taskEXIT_CRITICAL();
 800129e:	f7ff fc71 	bl	8000b84 <vPortExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
 80012a2:	f000 ff75 	bl	8002190 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 80012a6:	f7ff fc5b 	bl	8000b60 <vPortEnterCritical>
 80012aa:	68fb      	ldr	r3, [r7, #12]
 80012ac:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80012ae:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 80012b2:	d103      	bne.n	80012bc <xQueueGenericReceive+0x114>
 80012b4:	68fb      	ldr	r3, [r7, #12]
 80012b6:	f04f 0200 	mov.w	r2, #0
 80012ba:	645a      	str	r2, [r3, #68]	; 0x44
 80012bc:	68fb      	ldr	r3, [r7, #12]
 80012be:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80012c0:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 80012c4:	d103      	bne.n	80012ce <xQueueGenericReceive+0x126>
 80012c6:	68fb      	ldr	r3, [r7, #12]
 80012c8:	f04f 0200 	mov.w	r2, #0
 80012cc:	649a      	str	r2, [r3, #72]	; 0x48
 80012ce:	f7ff fc59 	bl	8000b84 <vPortExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 80012d2:	f107 0210 	add.w	r2, r7, #16
 80012d6:	f107 0304 	add.w	r3, r7, #4
 80012da:	4610      	mov	r0, r2
 80012dc:	4619      	mov	r1, r3
 80012de:	f001 fb6f 	bl	80029c0 <xTaskCheckForTimeOut>
 80012e2:	4603      	mov	r3, r0
 80012e4:	2b00      	cmp	r3, #0
 80012e6:	d12c      	bne.n	8001342 <xQueueGenericReceive+0x19a>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 80012e8:	68f8      	ldr	r0, [r7, #12]
 80012ea:	f000 f9e1 	bl	80016b0 <prvIsQueueEmpty>
 80012ee:	4603      	mov	r3, r0
 80012f0:	2b00      	cmp	r3, #0
 80012f2:	d020      	beq.n	8001336 <xQueueGenericReceive+0x18e>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 80012f4:	68fb      	ldr	r3, [r7, #12]
 80012f6:	681b      	ldr	r3, [r3, #0]
 80012f8:	2b00      	cmp	r3, #0
 80012fa:	d108      	bne.n	800130e <xQueueGenericReceive+0x166>
					{
						portENTER_CRITICAL();
 80012fc:	f7ff fc30 	bl	8000b60 <vPortEnterCritical>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 8001300:	68fb      	ldr	r3, [r7, #12]
 8001302:	685b      	ldr	r3, [r3, #4]
 8001304:	4618      	mov	r0, r3
 8001306:	f001 fe1d 	bl	8002f44 <vTaskPriorityInherit>
						}
						portEXIT_CRITICAL();
 800130a:	f7ff fc3b 	bl	8000b84 <vPortExitCritical>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 800130e:	68fb      	ldr	r3, [r7, #12]
 8001310:	f103 0224 	add.w	r2, r3, #36	; 0x24
 8001314:	687b      	ldr	r3, [r7, #4]
 8001316:	4610      	mov	r0, r2
 8001318:	4619      	mov	r1, r3
 800131a:	f001 fa5b 	bl	80027d4 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 800131e:	68f8      	ldr	r0, [r7, #12]
 8001320:	f000 f976 	bl	8001610 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 8001324:	f000 ff46 	bl	80021b4 <xTaskResumeAll>
 8001328:	4603      	mov	r3, r0
 800132a:	2b00      	cmp	r3, #0
 800132c:	f47f af5d 	bne.w	80011ea <xQueueGenericReceive+0x42>
				{
					portYIELD_WITHIN_API();
 8001330:	f7ff fc0a 	bl	8000b48 <vPortYieldFromISR>
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
 8001334:	e759      	b.n	80011ea <xQueueGenericReceive+0x42>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
 8001336:	68f8      	ldr	r0, [r7, #12]
 8001338:	f000 f96a 	bl	8001610 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 800133c:	f000 ff3a 	bl	80021b4 <xTaskResumeAll>
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
 8001340:	e753      	b.n	80011ea <xQueueGenericReceive+0x42>
				( void ) xTaskResumeAll();
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
 8001342:	68f8      	ldr	r0, [r7, #12]
 8001344:	f000 f964 	bl	8001610 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 8001348:	f000 ff34 	bl	80021b4 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
 800134c:	f04f 0300 	mov.w	r3, #0
		}
	}
}
 8001350:	4618      	mov	r0, r3
 8001352:	f107 0720 	add.w	r7, r7, #32
 8001356:	46bd      	mov	sp, r7
 8001358:	bd80      	pop	{r7, pc}
 800135a:	bf00      	nop

0800135c <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxHigherPriorityTaskWoken )
{
 800135c:	b580      	push	{r7, lr}
 800135e:	b086      	sub	sp, #24
 8001360:	af00      	add	r7, sp, #0
 8001362:	60f8      	str	r0, [r7, #12]
 8001364:	60b9      	str	r1, [r7, #8]
 8001366:	607a      	str	r2, [r7, #4]
signed portBASE_TYPE xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	configASSERT( pxQueue );
 8001368:	68fb      	ldr	r3, [r7, #12]
 800136a:	2b00      	cmp	r3, #0
 800136c:	d102      	bne.n	8001374 <xQueueReceiveFromISR+0x18>
 800136e:	f7ff fc23 	bl	8000bb8 <ulPortSetInterruptMask>
 8001372:	e7fe      	b.n	8001372 <xQueueReceiveFromISR+0x16>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
 8001374:	68bb      	ldr	r3, [r7, #8]
 8001376:	2b00      	cmp	r3, #0
 8001378:	d103      	bne.n	8001382 <xQueueReceiveFromISR+0x26>
 800137a:	68fb      	ldr	r3, [r7, #12]
 800137c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800137e:	2b00      	cmp	r3, #0
 8001380:	d102      	bne.n	8001388 <xQueueReceiveFromISR+0x2c>
 8001382:	f04f 0301 	mov.w	r3, #1
 8001386:	e001      	b.n	800138c <xQueueReceiveFromISR+0x30>
 8001388:	f04f 0300 	mov.w	r3, #0
 800138c:	2b00      	cmp	r3, #0
 800138e:	d102      	bne.n	8001396 <xQueueReceiveFromISR+0x3a>
 8001390:	f7ff fc12 	bl	8000bb8 <ulPortSetInterruptMask>
 8001394:	e7fe      	b.n	8001394 <xQueueReceiveFromISR+0x38>

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 8001396:	f7ff fc0f 	bl	8000bb8 <ulPortSetInterruptMask>
 800139a:	6138      	str	r0, [r7, #16]
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 800139c:	68fb      	ldr	r3, [r7, #12]
 800139e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80013a0:	2b00      	cmp	r3, #0
 80013a2:	d02d      	beq.n	8001400 <xQueueReceiveFromISR+0xa4>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
 80013a4:	68f8      	ldr	r0, [r7, #12]
 80013a6:	68b9      	ldr	r1, [r7, #8]
 80013a8:	f000 f90a 	bl	80015c0 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
 80013ac:	68fb      	ldr	r3, [r7, #12]
 80013ae:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80013b0:	f103 32ff 	add.w	r2, r3, #4294967295	; 0xffffffff
 80013b4:	68fb      	ldr	r3, [r7, #12]
 80013b6:	639a      	str	r2, [r3, #56]	; 0x38

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
 80013b8:	68fb      	ldr	r3, [r7, #12]
 80013ba:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80013bc:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 80013c0:	d114      	bne.n	80013ec <xQueueReceiveFromISR+0x90>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 80013c2:	68fb      	ldr	r3, [r7, #12]
 80013c4:	691b      	ldr	r3, [r3, #16]
 80013c6:	2b00      	cmp	r3, #0
 80013c8:	d016      	beq.n	80013f8 <xQueueReceiveFromISR+0x9c>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 80013ca:	68fb      	ldr	r3, [r7, #12]
 80013cc:	f103 0310 	add.w	r3, r3, #16
 80013d0:	4618      	mov	r0, r3
 80013d2:	f001 fa71 	bl	80028b8 <xTaskRemoveFromEventList>
 80013d6:	4603      	mov	r3, r0
 80013d8:	2b00      	cmp	r3, #0
 80013da:	d00d      	beq.n	80013f8 <xQueueReceiveFromISR+0x9c>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
 80013dc:	687b      	ldr	r3, [r7, #4]
 80013de:	2b00      	cmp	r3, #0
 80013e0:	d00a      	beq.n	80013f8 <xQueueReceiveFromISR+0x9c>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
 80013e2:	687b      	ldr	r3, [r7, #4]
 80013e4:	f04f 0201 	mov.w	r2, #1
 80013e8:	601a      	str	r2, [r3, #0]
 80013ea:	e005      	b.n	80013f8 <xQueueReceiveFromISR+0x9c>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
 80013ec:	68fb      	ldr	r3, [r7, #12]
 80013ee:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80013f0:	f103 0201 	add.w	r2, r3, #1
 80013f4:	68fb      	ldr	r3, [r7, #12]
 80013f6:	645a      	str	r2, [r3, #68]	; 0x44
			}

			xReturn = pdPASS;
 80013f8:	f04f 0301 	mov.w	r3, #1
 80013fc:	617b      	str	r3, [r7, #20]
 80013fe:	e002      	b.n	8001406 <xQueueReceiveFromISR+0xaa>
		}
		else
		{
			xReturn = pdFAIL;
 8001400:	f04f 0300 	mov.w	r3, #0
 8001404:	617b      	str	r3, [r7, #20]
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 8001406:	6938      	ldr	r0, [r7, #16]
 8001408:	f7ff fbe0 	bl	8000bcc <vPortClearInterruptMask>

	return xReturn;
 800140c:	697b      	ldr	r3, [r7, #20]
}
 800140e:	4618      	mov	r0, r3
 8001410:	f107 0718 	add.w	r7, r7, #24
 8001414:	46bd      	mov	sp, r7
 8001416:	bd80      	pop	{r7, pc}

08001418 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
 8001418:	b580      	push	{r7, lr}
 800141a:	b084      	sub	sp, #16
 800141c:	af00      	add	r7, sp, #0
 800141e:	6078      	str	r0, [r7, #4]
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );
 8001420:	687b      	ldr	r3, [r7, #4]
 8001422:	2b00      	cmp	r3, #0
 8001424:	d102      	bne.n	800142c <uxQueueMessagesWaiting+0x14>
 8001426:	f7ff fbc7 	bl	8000bb8 <ulPortSetInterruptMask>
 800142a:	e7fe      	b.n	800142a <uxQueueMessagesWaiting+0x12>

	taskENTER_CRITICAL();
 800142c:	f7ff fb98 	bl	8000b60 <vPortEnterCritical>
		uxReturn = pxQueue->uxMessagesWaiting;
 8001430:	687b      	ldr	r3, [r7, #4]
 8001432:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8001434:	60fb      	str	r3, [r7, #12]
	taskEXIT_CRITICAL();
 8001436:	f7ff fba5 	bl	8000b84 <vPortExitCritical>

	return uxReturn;
 800143a:	68fb      	ldr	r3, [r7, #12]
}
 800143c:	4618      	mov	r0, r3
 800143e:	f107 0710 	add.w	r7, r7, #16
 8001442:	46bd      	mov	sp, r7
 8001444:	bd80      	pop	{r7, pc}
 8001446:	bf00      	nop

08001448 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
 8001448:	b580      	push	{r7, lr}
 800144a:	b084      	sub	sp, #16
 800144c:	af00      	add	r7, sp, #0
 800144e:	6078      	str	r0, [r7, #4]
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );
 8001450:	687b      	ldr	r3, [r7, #4]
 8001452:	2b00      	cmp	r3, #0
 8001454:	d102      	bne.n	800145c <uxQueueMessagesWaitingFromISR+0x14>
 8001456:	f7ff fbaf 	bl	8000bb8 <ulPortSetInterruptMask>
 800145a:	e7fe      	b.n	800145a <uxQueueMessagesWaitingFromISR+0x12>

	uxReturn = pxQueue->uxMessagesWaiting;
 800145c:	687b      	ldr	r3, [r7, #4]
 800145e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8001460:	60fb      	str	r3, [r7, #12]

	return uxReturn;
 8001462:	68fb      	ldr	r3, [r7, #12]
}
 8001464:	4618      	mov	r0, r3
 8001466:	f107 0710 	add.w	r7, r7, #16
 800146a:	46bd      	mov	sp, r7
 800146c:	bd80      	pop	{r7, pc}
 800146e:	bf00      	nop

08001470 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
 8001470:	b580      	push	{r7, lr}
 8001472:	b082      	sub	sp, #8
 8001474:	af00      	add	r7, sp, #0
 8001476:	6078      	str	r0, [r7, #4]
	configASSERT( pxQueue );
 8001478:	687b      	ldr	r3, [r7, #4]
 800147a:	2b00      	cmp	r3, #0
 800147c:	d102      	bne.n	8001484 <vQueueDelete+0x14>
 800147e:	f7ff fb9b 	bl	8000bb8 <ulPortSetInterruptMask>
 8001482:	e7fe      	b.n	8001482 <vQueueDelete+0x12>

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
 8001484:	6878      	ldr	r0, [r7, #4]
 8001486:	f000 f9a5 	bl	80017d4 <vQueueUnregisterQueue>
	vPortFree( pxQueue->pcHead );
 800148a:	687b      	ldr	r3, [r7, #4]
 800148c:	681b      	ldr	r3, [r3, #0]
 800148e:	4618      	mov	r0, r3
 8001490:	f7fe ff76 	bl	8000380 <vPortFree>
	vPortFree( pxQueue );
 8001494:	6878      	ldr	r0, [r7, #4]
 8001496:	f7fe ff73 	bl	8000380 <vPortFree>
}
 800149a:	f107 0708 	add.w	r7, r7, #8
 800149e:	46bd      	mov	sp, r7
 80014a0:	bd80      	pop	{r7, pc}
 80014a2:	bf00      	nop

080014a4 <ucQueueGetQueueNumber>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	unsigned char ucQueueGetQueueNumber( xQueueHandle pxQueue )
	{
 80014a4:	b480      	push	{r7}
 80014a6:	b083      	sub	sp, #12
 80014a8:	af00      	add	r7, sp, #0
 80014aa:	6078      	str	r0, [r7, #4]
		return pxQueue->ucQueueNumber;
 80014ac:	687b      	ldr	r3, [r7, #4]
 80014ae:	f893 304c 	ldrb.w	r3, [r3, #76]	; 0x4c
	}
 80014b2:	4618      	mov	r0, r3
 80014b4:	f107 070c 	add.w	r7, r7, #12
 80014b8:	46bd      	mov	sp, r7
 80014ba:	bc80      	pop	{r7}
 80014bc:	4770      	bx	lr
 80014be:	bf00      	nop

080014c0 <vQueueSetQueueNumber>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	void vQueueSetQueueNumber( xQueueHandle pxQueue, unsigned char ucQueueNumber )
	{
 80014c0:	b480      	push	{r7}
 80014c2:	b083      	sub	sp, #12
 80014c4:	af00      	add	r7, sp, #0
 80014c6:	6078      	str	r0, [r7, #4]
 80014c8:	460b      	mov	r3, r1
 80014ca:	70fb      	strb	r3, [r7, #3]
		pxQueue->ucQueueNumber = ucQueueNumber;
 80014cc:	687b      	ldr	r3, [r7, #4]
 80014ce:	78fa      	ldrb	r2, [r7, #3]
 80014d0:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
	}
 80014d4:	f107 070c 	add.w	r7, r7, #12
 80014d8:	46bd      	mov	sp, r7
 80014da:	bc80      	pop	{r7}
 80014dc:	4770      	bx	lr
 80014de:	bf00      	nop

080014e0 <ucQueueGetQueueType>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	unsigned char ucQueueGetQueueType( xQueueHandle pxQueue )
	{
 80014e0:	b480      	push	{r7}
 80014e2:	b083      	sub	sp, #12
 80014e4:	af00      	add	r7, sp, #0
 80014e6:	6078      	str	r0, [r7, #4]
		return pxQueue->ucQueueType;
 80014e8:	687b      	ldr	r3, [r7, #4]
 80014ea:	f893 304d 	ldrb.w	r3, [r3, #77]	; 0x4d
	}
 80014ee:	4618      	mov	r0, r3
 80014f0:	f107 070c 	add.w	r7, r7, #12
 80014f4:	46bd      	mov	sp, r7
 80014f6:	bc80      	pop	{r7}
 80014f8:	4770      	bx	lr
 80014fa:	bf00      	nop

080014fc <prvCopyDataToQueue>:

#endif
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
 80014fc:	b580      	push	{r7, lr}
 80014fe:	b084      	sub	sp, #16
 8001500:	af00      	add	r7, sp, #0
 8001502:	60f8      	str	r0, [r7, #12]
 8001504:	60b9      	str	r1, [r7, #8]
 8001506:	607a      	str	r2, [r7, #4]
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
 8001508:	68fb      	ldr	r3, [r7, #12]
 800150a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800150c:	2b00      	cmp	r3, #0
 800150e:	d10d      	bne.n	800152c <prvCopyDataToQueue+0x30>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8001510:	68fb      	ldr	r3, [r7, #12]
 8001512:	681b      	ldr	r3, [r3, #0]
 8001514:	2b00      	cmp	r3, #0
 8001516:	d148      	bne.n	80015aa <prvCopyDataToQueue+0xae>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
 8001518:	68fb      	ldr	r3, [r7, #12]
 800151a:	685b      	ldr	r3, [r3, #4]
 800151c:	4618      	mov	r0, r3
 800151e:	f001 fd7f 	bl	8003020 <vTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
 8001522:	68fb      	ldr	r3, [r7, #12]
 8001524:	f04f 0200 	mov.w	r2, #0
 8001528:	605a      	str	r2, [r3, #4]
 800152a:	e03e      	b.n	80015aa <prvCopyDataToQueue+0xae>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
 800152c:	687b      	ldr	r3, [r7, #4]
 800152e:	2b00      	cmp	r3, #0
 8001530:	d11a      	bne.n	8001568 <prvCopyDataToQueue+0x6c>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
 8001532:	68fb      	ldr	r3, [r7, #12]
 8001534:	689a      	ldr	r2, [r3, #8]
 8001536:	68fb      	ldr	r3, [r7, #12]
 8001538:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800153a:	4610      	mov	r0, r2
 800153c:	68b9      	ldr	r1, [r7, #8]
 800153e:	461a      	mov	r2, r3
 8001540:	f002 fa8f 	bl	8003a62 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 8001544:	68fb      	ldr	r3, [r7, #12]
 8001546:	689a      	ldr	r2, [r3, #8]
 8001548:	68fb      	ldr	r3, [r7, #12]
 800154a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800154c:	18d2      	adds	r2, r2, r3
 800154e:	68fb      	ldr	r3, [r7, #12]
 8001550:	609a      	str	r2, [r3, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
 8001552:	68fb      	ldr	r3, [r7, #12]
 8001554:	689a      	ldr	r2, [r3, #8]
 8001556:	68fb      	ldr	r3, [r7, #12]
 8001558:	685b      	ldr	r3, [r3, #4]
 800155a:	429a      	cmp	r2, r3
 800155c:	d325      	bcc.n	80015aa <prvCopyDataToQueue+0xae>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
 800155e:	68fb      	ldr	r3, [r7, #12]
 8001560:	681a      	ldr	r2, [r3, #0]
 8001562:	68fb      	ldr	r3, [r7, #12]
 8001564:	609a      	str	r2, [r3, #8]
 8001566:	e020      	b.n	80015aa <prvCopyDataToQueue+0xae>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
 8001568:	68fb      	ldr	r3, [r7, #12]
 800156a:	68da      	ldr	r2, [r3, #12]
 800156c:	68fb      	ldr	r3, [r7, #12]
 800156e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8001570:	4610      	mov	r0, r2
 8001572:	68b9      	ldr	r1, [r7, #8]
 8001574:	461a      	mov	r2, r3
 8001576:	f002 fa74 	bl	8003a62 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
 800157a:	68fb      	ldr	r3, [r7, #12]
 800157c:	68da      	ldr	r2, [r3, #12]
 800157e:	68fb      	ldr	r3, [r7, #12]
 8001580:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8001582:	f1c3 0300 	rsb	r3, r3, #0
 8001586:	18d2      	adds	r2, r2, r3
 8001588:	68fb      	ldr	r3, [r7, #12]
 800158a:	60da      	str	r2, [r3, #12]
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
 800158c:	68fb      	ldr	r3, [r7, #12]
 800158e:	68da      	ldr	r2, [r3, #12]
 8001590:	68fb      	ldr	r3, [r7, #12]
 8001592:	681b      	ldr	r3, [r3, #0]
 8001594:	429a      	cmp	r2, r3
 8001596:	d208      	bcs.n	80015aa <prvCopyDataToQueue+0xae>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
 8001598:	68fb      	ldr	r3, [r7, #12]
 800159a:	685a      	ldr	r2, [r3, #4]
 800159c:	68fb      	ldr	r3, [r7, #12]
 800159e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80015a0:	f1c3 0300 	rsb	r3, r3, #0
 80015a4:	18d2      	adds	r2, r2, r3
 80015a6:	68fb      	ldr	r3, [r7, #12]
 80015a8:	60da      	str	r2, [r3, #12]
		}
	}

	++( pxQueue->uxMessagesWaiting );
 80015aa:	68fb      	ldr	r3, [r7, #12]
 80015ac:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80015ae:	f103 0201 	add.w	r2, r3, #1
 80015b2:	68fb      	ldr	r3, [r7, #12]
 80015b4:	639a      	str	r2, [r3, #56]	; 0x38
}
 80015b6:	f107 0710 	add.w	r7, r7, #16
 80015ba:	46bd      	mov	sp, r7
 80015bc:	bd80      	pop	{r7, pc}
 80015be:	bf00      	nop

080015c0 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
 80015c0:	b580      	push	{r7, lr}
 80015c2:	b082      	sub	sp, #8
 80015c4:	af00      	add	r7, sp, #0
 80015c6:	6078      	str	r0, [r7, #4]
 80015c8:	6039      	str	r1, [r7, #0]
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
 80015ca:	687b      	ldr	r3, [r7, #4]
 80015cc:	681b      	ldr	r3, [r3, #0]
 80015ce:	2b00      	cmp	r3, #0
 80015d0:	d019      	beq.n	8001606 <prvCopyDataFromQueue+0x46>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
 80015d2:	687b      	ldr	r3, [r7, #4]
 80015d4:	68da      	ldr	r2, [r3, #12]
 80015d6:	687b      	ldr	r3, [r7, #4]
 80015d8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80015da:	18d2      	adds	r2, r2, r3
 80015dc:	687b      	ldr	r3, [r7, #4]
 80015de:	60da      	str	r2, [r3, #12]
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
 80015e0:	687b      	ldr	r3, [r7, #4]
 80015e2:	68da      	ldr	r2, [r3, #12]
 80015e4:	687b      	ldr	r3, [r7, #4]
 80015e6:	685b      	ldr	r3, [r3, #4]
 80015e8:	429a      	cmp	r2, r3
 80015ea:	d303      	bcc.n	80015f4 <prvCopyDataFromQueue+0x34>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
 80015ec:	687b      	ldr	r3, [r7, #4]
 80015ee:	681a      	ldr	r2, [r3, #0]
 80015f0:	687b      	ldr	r3, [r7, #4]
 80015f2:	60da      	str	r2, [r3, #12]
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
 80015f4:	687b      	ldr	r3, [r7, #4]
 80015f6:	68da      	ldr	r2, [r3, #12]
 80015f8:	687b      	ldr	r3, [r7, #4]
 80015fa:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80015fc:	6838      	ldr	r0, [r7, #0]
 80015fe:	4611      	mov	r1, r2
 8001600:	461a      	mov	r2, r3
 8001602:	f002 fa2e 	bl	8003a62 <memcpy>
	}
}
 8001606:	f107 0708 	add.w	r7, r7, #8
 800160a:	46bd      	mov	sp, r7
 800160c:	bd80      	pop	{r7, pc}
 800160e:	bf00      	nop

08001610 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
 8001610:	b580      	push	{r7, lr}
 8001612:	b082      	sub	sp, #8
 8001614:	af00      	add	r7, sp, #0
 8001616:	6078      	str	r0, [r7, #4]

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
 8001618:	f7ff faa2 	bl	8000b60 <vPortEnterCritical>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
 800161c:	e014      	b.n	8001648 <prvUnlockQueue+0x38>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800161e:	687b      	ldr	r3, [r7, #4]
 8001620:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001622:	2b00      	cmp	r3, #0
 8001624:	d015      	beq.n	8001652 <prvUnlockQueue+0x42>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8001626:	687b      	ldr	r3, [r7, #4]
 8001628:	f103 0324 	add.w	r3, r3, #36	; 0x24
 800162c:	4618      	mov	r0, r3
 800162e:	f001 f943 	bl	80028b8 <xTaskRemoveFromEventList>
 8001632:	4603      	mov	r3, r0
 8001634:	2b00      	cmp	r3, #0
 8001636:	d001      	beq.n	800163c <prvUnlockQueue+0x2c>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
 8001638:	f001 fa20 	bl	8002a7c <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
 800163c:	687b      	ldr	r3, [r7, #4]
 800163e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8001640:	f103 32ff 	add.w	r2, r3, #4294967295	; 0xffffffff
 8001644:	687b      	ldr	r3, [r7, #4]
 8001646:	649a      	str	r2, [r3, #72]	; 0x48
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
 8001648:	687b      	ldr	r3, [r7, #4]
 800164a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800164c:	2b00      	cmp	r3, #0
 800164e:	dce6      	bgt.n	800161e <prvUnlockQueue+0xe>
 8001650:	e000      	b.n	8001654 <prvUnlockQueue+0x44>

				--( pxQueue->xTxLock );
			}
			else
			{
				break;
 8001652:	bf00      	nop
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
 8001654:	687b      	ldr	r3, [r7, #4]
 8001656:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800165a:	649a      	str	r2, [r3, #72]	; 0x48
	}
	taskEXIT_CRITICAL();
 800165c:	f7ff fa92 	bl	8000b84 <vPortExitCritical>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
 8001660:	f7ff fa7e 	bl	8000b60 <vPortEnterCritical>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
 8001664:	e014      	b.n	8001690 <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8001666:	687b      	ldr	r3, [r7, #4]
 8001668:	691b      	ldr	r3, [r3, #16]
 800166a:	2b00      	cmp	r3, #0
 800166c:	d015      	beq.n	800169a <prvUnlockQueue+0x8a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800166e:	687b      	ldr	r3, [r7, #4]
 8001670:	f103 0310 	add.w	r3, r3, #16
 8001674:	4618      	mov	r0, r3
 8001676:	f001 f91f 	bl	80028b8 <xTaskRemoveFromEventList>
 800167a:	4603      	mov	r3, r0
 800167c:	2b00      	cmp	r3, #0
 800167e:	d001      	beq.n	8001684 <prvUnlockQueue+0x74>
				{
					vTaskMissedYield();
 8001680:	f001 f9fc 	bl	8002a7c <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
 8001684:	687b      	ldr	r3, [r7, #4]
 8001686:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8001688:	f103 32ff 	add.w	r2, r3, #4294967295	; 0xffffffff
 800168c:	687b      	ldr	r3, [r7, #4]
 800168e:	645a      	str	r2, [r3, #68]	; 0x44
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
 8001690:	687b      	ldr	r3, [r7, #4]
 8001692:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8001694:	2b00      	cmp	r3, #0
 8001696:	dce6      	bgt.n	8001666 <prvUnlockQueue+0x56>
 8001698:	e000      	b.n	800169c <prvUnlockQueue+0x8c>

				--( pxQueue->xRxLock );
			}
			else
			{
				break;
 800169a:	bf00      	nop
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
 800169c:	687b      	ldr	r3, [r7, #4]
 800169e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 80016a2:	645a      	str	r2, [r3, #68]	; 0x44
	}
	taskEXIT_CRITICAL();
 80016a4:	f7ff fa6e 	bl	8000b84 <vPortExitCritical>
}
 80016a8:	f107 0708 	add.w	r7, r7, #8
 80016ac:	46bd      	mov	sp, r7
 80016ae:	bd80      	pop	{r7, pc}

080016b0 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
 80016b0:	b580      	push	{r7, lr}
 80016b2:	b084      	sub	sp, #16
 80016b4:	af00      	add	r7, sp, #0
 80016b6:	6078      	str	r0, [r7, #4]
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
 80016b8:	f7ff fa52 	bl	8000b60 <vPortEnterCritical>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
 80016bc:	687b      	ldr	r3, [r7, #4]
 80016be:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80016c0:	2b00      	cmp	r3, #0
 80016c2:	bf14      	ite	ne
 80016c4:	2300      	movne	r3, #0
 80016c6:	2301      	moveq	r3, #1
 80016c8:	b2db      	uxtb	r3, r3
 80016ca:	60fb      	str	r3, [r7, #12]
	taskEXIT_CRITICAL();
 80016cc:	f7ff fa5a 	bl	8000b84 <vPortExitCritical>

	return xReturn;
 80016d0:	68fb      	ldr	r3, [r7, #12]
}
 80016d2:	4618      	mov	r0, r3
 80016d4:	f107 0710 	add.w	r7, r7, #16
 80016d8:	46bd      	mov	sp, r7
 80016da:	bd80      	pop	{r7, pc}

080016dc <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
 80016dc:	b580      	push	{r7, lr}
 80016de:	b084      	sub	sp, #16
 80016e0:	af00      	add	r7, sp, #0
 80016e2:	6078      	str	r0, [r7, #4]
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
 80016e4:	687b      	ldr	r3, [r7, #4]
 80016e6:	2b00      	cmp	r3, #0
 80016e8:	d102      	bne.n	80016f0 <xQueueIsQueueEmptyFromISR+0x14>
 80016ea:	f7ff fa65 	bl	8000bb8 <ulPortSetInterruptMask>
 80016ee:	e7fe      	b.n	80016ee <xQueueIsQueueEmptyFromISR+0x12>
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
 80016f0:	687b      	ldr	r3, [r7, #4]
 80016f2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80016f4:	2b00      	cmp	r3, #0
 80016f6:	bf14      	ite	ne
 80016f8:	2300      	movne	r3, #0
 80016fa:	2301      	moveq	r3, #1
 80016fc:	b2db      	uxtb	r3, r3
 80016fe:	60fb      	str	r3, [r7, #12]

	return xReturn;
 8001700:	68fb      	ldr	r3, [r7, #12]
}
 8001702:	4618      	mov	r0, r3
 8001704:	f107 0710 	add.w	r7, r7, #16
 8001708:	46bd      	mov	sp, r7
 800170a:	bd80      	pop	{r7, pc}

0800170c <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
 800170c:	b580      	push	{r7, lr}
 800170e:	b084      	sub	sp, #16
 8001710:	af00      	add	r7, sp, #0
 8001712:	6078      	str	r0, [r7, #4]
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
 8001714:	f7ff fa24 	bl	8000b60 <vPortEnterCritical>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
 8001718:	687b      	ldr	r3, [r7, #4]
 800171a:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800171c:	687b      	ldr	r3, [r7, #4]
 800171e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8001720:	429a      	cmp	r2, r3
 8001722:	bf14      	ite	ne
 8001724:	2300      	movne	r3, #0
 8001726:	2301      	moveq	r3, #1
 8001728:	b2db      	uxtb	r3, r3
 800172a:	60fb      	str	r3, [r7, #12]
	taskEXIT_CRITICAL();
 800172c:	f7ff fa2a 	bl	8000b84 <vPortExitCritical>

	return xReturn;
 8001730:	68fb      	ldr	r3, [r7, #12]
}
 8001732:	4618      	mov	r0, r3
 8001734:	f107 0710 	add.w	r7, r7, #16
 8001738:	46bd      	mov	sp, r7
 800173a:	bd80      	pop	{r7, pc}

0800173c <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
 800173c:	b580      	push	{r7, lr}
 800173e:	b084      	sub	sp, #16
 8001740:	af00      	add	r7, sp, #0
 8001742:	6078      	str	r0, [r7, #4]
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
 8001744:	687b      	ldr	r3, [r7, #4]
 8001746:	2b00      	cmp	r3, #0
 8001748:	d102      	bne.n	8001750 <xQueueIsQueueFullFromISR+0x14>
 800174a:	f7ff fa35 	bl	8000bb8 <ulPortSetInterruptMask>
 800174e:	e7fe      	b.n	800174e <xQueueIsQueueFullFromISR+0x12>
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
 8001750:	687b      	ldr	r3, [r7, #4]
 8001752:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8001754:	687b      	ldr	r3, [r7, #4]
 8001756:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8001758:	429a      	cmp	r2, r3
 800175a:	bf14      	ite	ne
 800175c:	2300      	movne	r3, #0
 800175e:	2301      	moveq	r3, #1
 8001760:	b2db      	uxtb	r3, r3
 8001762:	60fb      	str	r3, [r7, #12]

	return xReturn;
 8001764:	68fb      	ldr	r3, [r7, #12]
}
 8001766:	4618      	mov	r0, r3
 8001768:	f107 0710 	add.w	r7, r7, #16
 800176c:	46bd      	mov	sp, r7
 800176e:	bd80      	pop	{r7, pc}

08001770 <vQueueAddToRegistry>:
/*-----------------------------------------------------------*/

#if configQUEUE_REGISTRY_SIZE > 0

	void vQueueAddToRegistry( xQueueHandle xQueue, signed char *pcQueueName )
	{
 8001770:	b480      	push	{r7}
 8001772:	b085      	sub	sp, #20
 8001774:	af00      	add	r7, sp, #0
 8001776:	6078      	str	r0, [r7, #4]
 8001778:	6039      	str	r1, [r7, #0]
	unsigned portBASE_TYPE ux;

		/* See if there is an empty space in the registry.  A NULL name denotes
		a free slot. */
		for( ux = ( unsigned portBASE_TYPE ) 0U; ux < ( unsigned portBASE_TYPE ) configQUEUE_REGISTRY_SIZE; ux++ )
 800177a:	f04f 0300 	mov.w	r3, #0
 800177e:	60fb      	str	r3, [r7, #12]
 8001780:	e01f      	b.n	80017c2 <vQueueAddToRegistry+0x52>
		{
			if( xQueueRegistry[ ux ].pcQueueName == NULL )
 8001782:	f642 6318 	movw	r3, #11800	; 0x2e18
 8001786:	f2c2 0301 	movt	r3, #8193	; 0x2001
 800178a:	68fa      	ldr	r2, [r7, #12]
 800178c:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 8001790:	2b00      	cmp	r3, #0
 8001792:	d112      	bne.n	80017ba <vQueueAddToRegistry+0x4a>
			{
				/* Store the information on this queue. */
				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
 8001794:	f642 6318 	movw	r3, #11800	; 0x2e18
 8001798:	f2c2 0301 	movt	r3, #8193	; 0x2001
 800179c:	68fa      	ldr	r2, [r7, #12]
 800179e:	6839      	ldr	r1, [r7, #0]
 80017a0:	f843 1032 	str.w	r1, [r3, r2, lsl #3]
				xQueueRegistry[ ux ].xHandle = xQueue;
 80017a4:	f642 6218 	movw	r2, #11800	; 0x2e18
 80017a8:	f2c2 0201 	movt	r2, #8193	; 0x2001
 80017ac:	68fb      	ldr	r3, [r7, #12]
 80017ae:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 80017b2:	18d3      	adds	r3, r2, r3
 80017b4:	687a      	ldr	r2, [r7, #4]
 80017b6:	605a      	str	r2, [r3, #4]
				break;
 80017b8:	e006      	b.n	80017c8 <vQueueAddToRegistry+0x58>
	{
	unsigned portBASE_TYPE ux;

		/* See if there is an empty space in the registry.  A NULL name denotes
		a free slot. */
		for( ux = ( unsigned portBASE_TYPE ) 0U; ux < ( unsigned portBASE_TYPE ) configQUEUE_REGISTRY_SIZE; ux++ )
 80017ba:	68fb      	ldr	r3, [r7, #12]
 80017bc:	f103 0301 	add.w	r3, r3, #1
 80017c0:	60fb      	str	r3, [r7, #12]
 80017c2:	68fb      	ldr	r3, [r7, #12]
 80017c4:	2b07      	cmp	r3, #7
 80017c6:	d9dc      	bls.n	8001782 <vQueueAddToRegistry+0x12>
				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
				xQueueRegistry[ ux ].xHandle = xQueue;
				break;
			}
		}
	}
 80017c8:	f107 0714 	add.w	r7, r7, #20
 80017cc:	46bd      	mov	sp, r7
 80017ce:	bc80      	pop	{r7}
 80017d0:	4770      	bx	lr
 80017d2:	bf00      	nop

080017d4 <vQueueUnregisterQueue>:
/*-----------------------------------------------------------*/

#if configQUEUE_REGISTRY_SIZE > 0

	static void vQueueUnregisterQueue( xQueueHandle xQueue )
	{
 80017d4:	b480      	push	{r7}
 80017d6:	b085      	sub	sp, #20
 80017d8:	af00      	add	r7, sp, #0
 80017da:	6078      	str	r0, [r7, #4]
	unsigned portBASE_TYPE ux;

		/* See if the handle of the queue being unregistered in actually in the
		registry. */
		for( ux = ( unsigned portBASE_TYPE ) 0U; ux < ( unsigned portBASE_TYPE ) configQUEUE_REGISTRY_SIZE; ux++ )
 80017dc:	f04f 0300 	mov.w	r3, #0
 80017e0:	60fb      	str	r3, [r7, #12]
 80017e2:	e019      	b.n	8001818 <vQueueUnregisterQueue+0x44>
		{
			if( xQueueRegistry[ ux ].xHandle == xQueue )
 80017e4:	f642 6218 	movw	r2, #11800	; 0x2e18
 80017e8:	f2c2 0201 	movt	r2, #8193	; 0x2001
 80017ec:	68fb      	ldr	r3, [r7, #12]
 80017ee:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 80017f2:	18d3      	adds	r3, r2, r3
 80017f4:	685a      	ldr	r2, [r3, #4]
 80017f6:	687b      	ldr	r3, [r7, #4]
 80017f8:	429a      	cmp	r2, r3
 80017fa:	d109      	bne.n	8001810 <vQueueUnregisterQueue+0x3c>
			{
				/* Set the name to NULL to show that this slot if free again. */
				xQueueRegistry[ ux ].pcQueueName = NULL;
 80017fc:	f642 6318 	movw	r3, #11800	; 0x2e18
 8001800:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8001804:	68fa      	ldr	r2, [r7, #12]
 8001806:	f04f 0100 	mov.w	r1, #0
 800180a:	f843 1032 	str.w	r1, [r3, r2, lsl #3]
				break;
 800180e:	e006      	b.n	800181e <vQueueUnregisterQueue+0x4a>
	{
	unsigned portBASE_TYPE ux;

		/* See if the handle of the queue being unregistered in actually in the
		registry. */
		for( ux = ( unsigned portBASE_TYPE ) 0U; ux < ( unsigned portBASE_TYPE ) configQUEUE_REGISTRY_SIZE; ux++ )
 8001810:	68fb      	ldr	r3, [r7, #12]
 8001812:	f103 0301 	add.w	r3, r3, #1
 8001816:	60fb      	str	r3, [r7, #12]
 8001818:	68fb      	ldr	r3, [r7, #12]
 800181a:	2b07      	cmp	r3, #7
 800181c:	d9e2      	bls.n	80017e4 <vQueueUnregisterQueue+0x10>
				xQueueRegistry[ ux ].pcQueueName = NULL;
				break;
			}
		}

	}
 800181e:	f107 0714 	add.w	r7, r7, #20
 8001822:	46bd      	mov	sp, r7
 8001824:	bc80      	pop	{r7}
 8001826:	4770      	bx	lr

08001828 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if configUSE_TIMERS == 1

	void vQueueWaitForMessageRestricted( xQueueHandle pxQueue, portTickType xTicksToWait )
	{
 8001828:	b580      	push	{r7, lr}
 800182a:	b082      	sub	sp, #8
 800182c:	af00      	add	r7, sp, #0
 800182e:	6078      	str	r0, [r7, #4]
 8001830:	6039      	str	r1, [r7, #0]
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
 8001832:	f7ff f995 	bl	8000b60 <vPortEnterCritical>
 8001836:	687b      	ldr	r3, [r7, #4]
 8001838:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800183a:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 800183e:	d103      	bne.n	8001848 <vQueueWaitForMessageRestricted+0x20>
 8001840:	687b      	ldr	r3, [r7, #4]
 8001842:	f04f 0200 	mov.w	r2, #0
 8001846:	645a      	str	r2, [r3, #68]	; 0x44
 8001848:	687b      	ldr	r3, [r7, #4]
 800184a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800184c:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8001850:	d103      	bne.n	800185a <vQueueWaitForMessageRestricted+0x32>
 8001852:	687b      	ldr	r3, [r7, #4]
 8001854:	f04f 0200 	mov.w	r2, #0
 8001858:	649a      	str	r2, [r3, #72]	; 0x48
 800185a:	f7ff f993 	bl	8000b84 <vPortExitCritical>
		if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0U )
 800185e:	687b      	ldr	r3, [r7, #4]
 8001860:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8001862:	2b00      	cmp	r3, #0
 8001864:	d106      	bne.n	8001874 <vQueueWaitForMessageRestricted+0x4c>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 8001866:	687b      	ldr	r3, [r7, #4]
 8001868:	f103 0324 	add.w	r3, r3, #36	; 0x24
 800186c:	4618      	mov	r0, r3
 800186e:	6839      	ldr	r1, [r7, #0]
 8001870:	f000 fff2 	bl	8002858 <vTaskPlaceOnEventListRestricted>
		}
		prvUnlockQueue( pxQueue );
 8001874:	6878      	ldr	r0, [r7, #4]
 8001876:	f7ff fecb 	bl	8001610 <prvUnlockQueue>
	}
 800187a:	f107 0708 	add.w	r7, r7, #8
 800187e:	46bd      	mov	sp, r7
 8001880:	bd80      	pop	{r7, pc}
 8001882:	bf00      	nop

08001884 <_sbrk>:
/*
 sbrk
 Increase program data space.
 Malloc and related functions depend on this
 */
caddr_t _sbrk(int incr) {
 8001884:	b590      	push	{r4, r7, lr}
 8001886:	b085      	sub	sp, #20
 8001888:	af00      	add	r7, sp, #0
 800188a:	6078      	str	r0, [r7, #4]

    extern char _ebss; // Defined by the linker
    static char *heap_end;
    char *prev_heap_end;

    if (heap_end == 0) {
 800188c:	f642 43b0 	movw	r3, #11440	; 0x2cb0
 8001890:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8001894:	681b      	ldr	r3, [r3, #0]
 8001896:	2b00      	cmp	r3, #0
 8001898:	d108      	bne.n	80018ac <_sbrk+0x28>
        heap_end = &_ebss;
 800189a:	f642 43b0 	movw	r3, #11440	; 0x2cb0
 800189e:	f2c2 0301 	movt	r3, #8193	; 0x2001
 80018a2:	f642 625c 	movw	r2, #11868	; 0x2e5c
 80018a6:	f2c2 0201 	movt	r2, #8193	; 0x2001
 80018aa:	601a      	str	r2, [r3, #0]
    }
    prev_heap_end = heap_end;
 80018ac:	f642 43b0 	movw	r3, #11440	; 0x2cb0
 80018b0:	f2c2 0301 	movt	r3, #8193	; 0x2001
 80018b4:	681b      	ldr	r3, [r3, #0]
 80018b6:	60fb      	str	r3, [r7, #12]
 */
__attribute__( ( always_inline ) ) static __INLINE uint32_t __get_MSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, msp\n" : "=r" (result) );
 80018b8:	f3ef 8408 	mrs	r4, MSP
  return(result);
 80018bc:	4623      	mov	r3, r4

    char * stack = (char*) __get_MSP();
 80018be:	60bb      	str	r3, [r7, #8]
     if (heap_end + incr >  stack)
 80018c0:	f642 43b0 	movw	r3, #11440	; 0x2cb0
 80018c4:	f2c2 0301 	movt	r3, #8193	; 0x2001
 80018c8:	681a      	ldr	r2, [r3, #0]
 80018ca:	687b      	ldr	r3, [r7, #4]
 80018cc:	18d2      	adds	r2, r2, r3
 80018ce:	68bb      	ldr	r3, [r7, #8]
 80018d0:	429a      	cmp	r2, r3
 80018d2:	d908      	bls.n	80018e6 <_sbrk+0x62>
     {
         //_write (STDERR_FILENO, "Heap and stack collision\n", 25);
         errno = ENOMEM;
 80018d4:	f002 f8b0 	bl	8003a38 <__errno>
 80018d8:	4603      	mov	r3, r0
 80018da:	f04f 020c 	mov.w	r2, #12
 80018de:	601a      	str	r2, [r3, #0]
         return  (caddr_t) -1;
 80018e0:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 80018e4:	e00c      	b.n	8001900 <_sbrk+0x7c>
         //abort ();
     }

    heap_end += incr;
 80018e6:	f642 43b0 	movw	r3, #11440	; 0x2cb0
 80018ea:	f2c2 0301 	movt	r3, #8193	; 0x2001
 80018ee:	681a      	ldr	r2, [r3, #0]
 80018f0:	687b      	ldr	r3, [r7, #4]
 80018f2:	18d2      	adds	r2, r2, r3
 80018f4:	f642 43b0 	movw	r3, #11440	; 0x2cb0
 80018f8:	f2c2 0301 	movt	r3, #8193	; 0x2001
 80018fc:	601a      	str	r2, [r3, #0]
    return (caddr_t) prev_heap_end;
 80018fe:	68fb      	ldr	r3, [r7, #12]

}
 8001900:	4618      	mov	r0, r3
 8001902:	f107 0714 	add.w	r7, r7, #20
 8001906:	46bd      	mov	sp, r7
 8001908:	bd90      	pop	{r4, r7, pc}
 800190a:	bf00      	nop

0800190c <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
 800190c:	b580      	push	{r7, lr}
 800190e:	b08a      	sub	sp, #40	; 0x28
 8001910:	af02      	add	r7, sp, #8
 8001912:	60f8      	str	r0, [r7, #12]
 8001914:	60b9      	str	r1, [r7, #8]
 8001916:	603b      	str	r3, [r7, #0]
 8001918:	4613      	mov	r3, r2
 800191a:	80fb      	strh	r3, [r7, #6]
signed portBASE_TYPE xReturn;
tskTCB * pxNewTCB;

	configASSERT( pxTaskCode );
 800191c:	68fb      	ldr	r3, [r7, #12]
 800191e:	2b00      	cmp	r3, #0
 8001920:	d102      	bne.n	8001928 <xTaskGenericCreate+0x1c>
 8001922:	f7ff f949 	bl	8000bb8 <ulPortSetInterruptMask>
 8001926:	e7fe      	b.n	8001926 <xTaskGenericCreate+0x1a>
	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );
 8001928:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800192a:	2b04      	cmp	r3, #4
 800192c:	d902      	bls.n	8001934 <xTaskGenericCreate+0x28>
 800192e:	f7ff f943 	bl	8000bb8 <ulPortSetInterruptMask>
 8001932:	e7fe      	b.n	8001932 <xTaskGenericCreate+0x26>

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
 8001934:	88fb      	ldrh	r3, [r7, #6]
 8001936:	4618      	mov	r0, r3
 8001938:	6b39      	ldr	r1, [r7, #48]	; 0x30
 800193a:	f001 fa09 	bl	8002d50 <prvAllocateTCBAndStack>
 800193e:	61b8      	str	r0, [r7, #24]

	if( pxNewTCB != NULL )
 8001940:	69bb      	ldr	r3, [r7, #24]
 8001942:	2b00      	cmp	r3, #0
 8001944:	f000 80b3 	beq.w	8001aae <xTaskGenericCreate+0x1a2>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
 8001948:	69bb      	ldr	r3, [r7, #24]
 800194a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800194c:	88fb      	ldrh	r3, [r7, #6]
 800194e:	f103 33ff 	add.w	r3, r3, #4294967295	; 0xffffffff
 8001952:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8001956:	18d3      	adds	r3, r2, r3
 8001958:	617b      	str	r3, [r7, #20]
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK  ) );
 800195a:	697b      	ldr	r3, [r7, #20]
 800195c:	f023 0307 	bic.w	r3, r3, #7
 8001960:	617b      	str	r3, [r7, #20]

			/* Check the alignment of the calculated top of stack is correct. */
			configASSERT( ( ( ( unsigned long ) pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
 8001962:	697b      	ldr	r3, [r7, #20]
 8001964:	f003 0307 	and.w	r3, r3, #7
 8001968:	2b00      	cmp	r3, #0
 800196a:	d002      	beq.n	8001972 <xTaskGenericCreate+0x66>
 800196c:	f7ff f924 	bl	8000bb8 <ulPortSetInterruptMask>
 8001970:	e7fe      	b.n	8001970 <xTaskGenericCreate+0x64>
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
 8001972:	88fb      	ldrh	r3, [r7, #6]
 8001974:	9300      	str	r3, [sp, #0]
 8001976:	69b8      	ldr	r0, [r7, #24]
 8001978:	68b9      	ldr	r1, [r7, #8]
 800197a:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800197c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800197e:	f001 f8c5 	bl	8002b0c <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8001982:	6978      	ldr	r0, [r7, #20]
 8001984:	68f9      	ldr	r1, [r7, #12]
 8001986:	683a      	ldr	r2, [r7, #0]
 8001988:	f7ff f852 	bl	8000a30 <pxPortInitialiseStack>
 800198c:	4602      	mov	r2, r0
 800198e:	69bb      	ldr	r3, [r7, #24]
 8001990:	601a      	str	r2, [r3, #0]
		#endif

		/* Check the alignment of the initialised stack. */
		portALIGNMENT_ASSERT_pxCurrentTCB( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
 8001992:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8001994:	2b00      	cmp	r3, #0
 8001996:	d002      	beq.n	800199e <xTaskGenericCreate+0x92>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
 8001998:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800199a:	69ba      	ldr	r2, [r7, #24]
 800199c:	601a      	str	r2, [r3, #0]
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
 800199e:	f7ff f8df 	bl	8000b60 <vPortEnterCritical>
		{
			uxCurrentNumberOfTasks++;
 80019a2:	f642 538c 	movw	r3, #11660	; 0x2d8c
 80019a6:	f2c2 0301 	movt	r3, #8193	; 0x2001
 80019aa:	681b      	ldr	r3, [r3, #0]
 80019ac:	f103 0201 	add.w	r2, r3, #1
 80019b0:	f642 538c 	movw	r3, #11660	; 0x2d8c
 80019b4:	f2c2 0301 	movt	r3, #8193	; 0x2001
 80019b8:	601a      	str	r2, [r3, #0]
			if( pxCurrentTCB == NULL )
 80019ba:	f642 43b4 	movw	r3, #11444	; 0x2cb4
 80019be:	f2c2 0301 	movt	r3, #8193	; 0x2001
 80019c2:	681b      	ldr	r3, [r3, #0]
 80019c4:	2b00      	cmp	r3, #0
 80019c6:	d10f      	bne.n	80019e8 <xTaskGenericCreate+0xdc>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
 80019c8:	f642 43b4 	movw	r3, #11444	; 0x2cb4
 80019cc:	f2c2 0301 	movt	r3, #8193	; 0x2001
 80019d0:	69ba      	ldr	r2, [r7, #24]
 80019d2:	601a      	str	r2, [r3, #0]

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
 80019d4:	f642 538c 	movw	r3, #11660	; 0x2d8c
 80019d8:	f2c2 0301 	movt	r3, #8193	; 0x2001
 80019dc:	681b      	ldr	r3, [r3, #0]
 80019de:	2b01      	cmp	r3, #1
 80019e0:	d118      	bne.n	8001a14 <xTaskGenericCreate+0x108>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
 80019e2:	f001 f8cf 	bl	8002b84 <prvInitialiseTaskLists>
 80019e6:	e015      	b.n	8001a14 <xTaskGenericCreate+0x108>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
 80019e8:	f642 539c 	movw	r3, #11676	; 0x2d9c
 80019ec:	f2c2 0301 	movt	r3, #8193	; 0x2001
 80019f0:	681b      	ldr	r3, [r3, #0]
 80019f2:	2b00      	cmp	r3, #0
 80019f4:	d10e      	bne.n	8001a14 <xTaskGenericCreate+0x108>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
 80019f6:	f642 43b4 	movw	r3, #11444	; 0x2cb4
 80019fa:	f2c2 0301 	movt	r3, #8193	; 0x2001
 80019fe:	681b      	ldr	r3, [r3, #0]
 8001a00:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001a02:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8001a04:	429a      	cmp	r2, r3
 8001a06:	d805      	bhi.n	8001a14 <xTaskGenericCreate+0x108>
					{
						pxCurrentTCB = pxNewTCB;
 8001a08:	f642 43b4 	movw	r3, #11444	; 0x2cb4
 8001a0c:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8001a10:	69ba      	ldr	r2, [r7, #24]
 8001a12:	601a      	str	r2, [r3, #0]
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
 8001a14:	69bb      	ldr	r3, [r7, #24]
 8001a16:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001a18:	f642 5394 	movw	r3, #11668	; 0x2d94
 8001a1c:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8001a20:	681b      	ldr	r3, [r3, #0]
 8001a22:	429a      	cmp	r2, r3
 8001a24:	d906      	bls.n	8001a34 <xTaskGenericCreate+0x128>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
 8001a26:	69bb      	ldr	r3, [r7, #24]
 8001a28:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001a2a:	f642 5394 	movw	r3, #11668	; 0x2d94
 8001a2e:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8001a32:	601a      	str	r2, [r3, #0]
			}

			#if ( configUSE_TRACE_FACILITY == 1 )
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
 8001a34:	f642 53b0 	movw	r3, #11696	; 0x2db0
 8001a38:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8001a3c:	681a      	ldr	r2, [r3, #0]
 8001a3e:	69bb      	ldr	r3, [r7, #24]
 8001a40:	641a      	str	r2, [r3, #64]	; 0x40
			}
			#endif
			uxTaskNumber++;
 8001a42:	f642 53b0 	movw	r3, #11696	; 0x2db0
 8001a46:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8001a4a:	681b      	ldr	r3, [r3, #0]
 8001a4c:	f103 0201 	add.w	r2, r3, #1
 8001a50:	f642 53b0 	movw	r3, #11696	; 0x2db0
 8001a54:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8001a58:	601a      	str	r2, [r3, #0]

			prvAddTaskToReadyQueue( pxNewTCB );
 8001a5a:	69bb      	ldr	r3, [r7, #24]
 8001a5c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001a5e:	f642 5398 	movw	r3, #11672	; 0x2d98
 8001a62:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8001a66:	681b      	ldr	r3, [r3, #0]
 8001a68:	429a      	cmp	r2, r3
 8001a6a:	d906      	bls.n	8001a7a <xTaskGenericCreate+0x16e>
 8001a6c:	69bb      	ldr	r3, [r7, #24]
 8001a6e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001a70:	f642 5398 	movw	r3, #11672	; 0x2d98
 8001a74:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8001a78:	601a      	str	r2, [r3, #0]
 8001a7a:	69bb      	ldr	r3, [r7, #24]
 8001a7c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001a7e:	4613      	mov	r3, r2
 8001a80:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8001a84:	189b      	adds	r3, r3, r2
 8001a86:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8001a8a:	f642 42b8 	movw	r2, #11448	; 0x2cb8
 8001a8e:	f2c2 0201 	movt	r2, #8193	; 0x2001
 8001a92:	189a      	adds	r2, r3, r2
 8001a94:	69bb      	ldr	r3, [r7, #24]
 8001a96:	f103 0304 	add.w	r3, r3, #4
 8001a9a:	4610      	mov	r0, r2
 8001a9c:	4619      	mov	r1, r3
 8001a9e:	f7fe fd19 	bl	80004d4 <vListInsertEnd>

			xReturn = pdPASS;
 8001aa2:	f04f 0301 	mov.w	r3, #1
 8001aa6:	61fb      	str	r3, [r7, #28]
			portSETUP_TCB( pxNewTCB );
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
 8001aa8:	f7ff f86c 	bl	8000b84 <vPortExitCritical>
 8001aac:	e002      	b.n	8001ab4 <xTaskGenericCreate+0x1a8>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 8001aae:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8001ab2:	61fb      	str	r3, [r7, #28]
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
 8001ab4:	69fb      	ldr	r3, [r7, #28]
 8001ab6:	2b01      	cmp	r3, #1
 8001ab8:	d111      	bne.n	8001ade <xTaskGenericCreate+0x1d2>
	{
		if( xSchedulerRunning != pdFALSE )
 8001aba:	f642 539c 	movw	r3, #11676	; 0x2d9c
 8001abe:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8001ac2:	681b      	ldr	r3, [r3, #0]
 8001ac4:	2b00      	cmp	r3, #0
 8001ac6:	d00a      	beq.n	8001ade <xTaskGenericCreate+0x1d2>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
 8001ac8:	f642 43b4 	movw	r3, #11444	; 0x2cb4
 8001acc:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8001ad0:	681b      	ldr	r3, [r3, #0]
 8001ad2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001ad4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8001ad6:	429a      	cmp	r2, r3
 8001ad8:	d201      	bcs.n	8001ade <xTaskGenericCreate+0x1d2>
			{
				portYIELD_WITHIN_API();
 8001ada:	f7ff f835 	bl	8000b48 <vPortYieldFromISR>
			}
		}
	}

	return xReturn;
 8001ade:	69fb      	ldr	r3, [r7, #28]
}
 8001ae0:	4618      	mov	r0, r3
 8001ae2:	f107 0720 	add.w	r7, r7, #32
 8001ae6:	46bd      	mov	sp, r7
 8001ae8:	bd80      	pop	{r7, pc}
 8001aea:	bf00      	nop

08001aec <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
 8001aec:	b580      	push	{r7, lr}
 8001aee:	b084      	sub	sp, #16
 8001af0:	af00      	add	r7, sp, #0
 8001af2:	6078      	str	r0, [r7, #4]
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
 8001af4:	f7ff f834 	bl	8000b60 <vPortEnterCritical>
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
 8001af8:	f642 43b4 	movw	r3, #11444	; 0x2cb4
 8001afc:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8001b00:	681b      	ldr	r3, [r3, #0]
 8001b02:	687a      	ldr	r2, [r7, #4]
 8001b04:	429a      	cmp	r2, r3
 8001b06:	d102      	bne.n	8001b0e <vTaskDelete+0x22>
			{
				pxTaskToDelete = NULL;
 8001b08:	f04f 0300 	mov.w	r3, #0
 8001b0c:	607b      	str	r3, [r7, #4]
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
 8001b0e:	687b      	ldr	r3, [r7, #4]
 8001b10:	2b00      	cmp	r3, #0
 8001b12:	d105      	bne.n	8001b20 <vTaskDelete+0x34>
 8001b14:	f642 43b4 	movw	r3, #11444	; 0x2cb4
 8001b18:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8001b1c:	681b      	ldr	r3, [r3, #0]
 8001b1e:	e000      	b.n	8001b22 <vTaskDelete+0x36>
 8001b20:	687b      	ldr	r3, [r7, #4]
 8001b22:	60fb      	str	r3, [r7, #12]

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
 8001b24:	68fb      	ldr	r3, [r7, #12]
 8001b26:	f103 0304 	add.w	r3, r3, #4
 8001b2a:	4618      	mov	r0, r3
 8001b2c:	f7fe fd34 	bl	8000598 <uxListRemove>
			{
				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
			}

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
 8001b30:	68fb      	ldr	r3, [r7, #12]
 8001b32:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8001b34:	2b00      	cmp	r3, #0
 8001b36:	d005      	beq.n	8001b44 <vTaskDelete+0x58>
			{
				uxListRemove( &( pxTCB->xEventListItem ) );
 8001b38:	68fb      	ldr	r3, [r7, #12]
 8001b3a:	f103 0318 	add.w	r3, r3, #24
 8001b3e:	4618      	mov	r0, r3
 8001b40:	f7fe fd2a 	bl	8000598 <uxListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
 8001b44:	68fb      	ldr	r3, [r7, #12]
 8001b46:	f103 0304 	add.w	r3, r3, #4
 8001b4a:	f642 5060 	movw	r0, #11616	; 0x2d60
 8001b4e:	f2c2 0001 	movt	r0, #8193	; 0x2001
 8001b52:	4619      	mov	r1, r3
 8001b54:	f7fe fcbe 	bl	80004d4 <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
 8001b58:	f642 5374 	movw	r3, #11636	; 0x2d74
 8001b5c:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8001b60:	681b      	ldr	r3, [r3, #0]
 8001b62:	f103 0201 	add.w	r2, r3, #1
 8001b66:	f642 5374 	movw	r3, #11636	; 0x2d74
 8001b6a:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8001b6e:	601a      	str	r2, [r3, #0]

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
 8001b70:	f642 53b0 	movw	r3, #11696	; 0x2db0
 8001b74:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8001b78:	681b      	ldr	r3, [r3, #0]
 8001b7a:	f103 0201 	add.w	r2, r3, #1
 8001b7e:	f642 53b0 	movw	r3, #11696	; 0x2db0
 8001b82:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8001b86:	601a      	str	r2, [r3, #0]

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
 8001b88:	f7fe fffc 	bl	8000b84 <vPortExitCritical>

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
 8001b8c:	f642 539c 	movw	r3, #11676	; 0x2d9c
 8001b90:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8001b94:	681b      	ldr	r3, [r3, #0]
 8001b96:	2b00      	cmp	r3, #0
 8001b98:	d004      	beq.n	8001ba4 <vTaskDelete+0xb8>
		{
			if( ( void * ) pxTaskToDelete == NULL )
 8001b9a:	687b      	ldr	r3, [r7, #4]
 8001b9c:	2b00      	cmp	r3, #0
 8001b9e:	d101      	bne.n	8001ba4 <vTaskDelete+0xb8>
			{
				portYIELD_WITHIN_API();
 8001ba0:	f7fe ffd2 	bl	8000b48 <vPortYieldFromISR>
			}
		}
	}
 8001ba4:	f107 0710 	add.w	r7, r7, #16
 8001ba8:	46bd      	mov	sp, r7
 8001baa:	bd80      	pop	{r7, pc}

08001bac <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
 8001bac:	b580      	push	{r7, lr}
 8001bae:	b086      	sub	sp, #24
 8001bb0:	af00      	add	r7, sp, #0
 8001bb2:	6078      	str	r0, [r7, #4]
 8001bb4:	6039      	str	r1, [r7, #0]
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
 8001bb6:	f04f 0300 	mov.w	r3, #0
 8001bba:	617b      	str	r3, [r7, #20]

		configASSERT( pxPreviousWakeTime );
 8001bbc:	687b      	ldr	r3, [r7, #4]
 8001bbe:	2b00      	cmp	r3, #0
 8001bc0:	d102      	bne.n	8001bc8 <vTaskDelayUntil+0x1c>
 8001bc2:	f7fe fff9 	bl	8000bb8 <ulPortSetInterruptMask>
 8001bc6:	e7fe      	b.n	8001bc6 <vTaskDelayUntil+0x1a>
		configASSERT( ( xTimeIncrement > 0U ) );
 8001bc8:	683b      	ldr	r3, [r7, #0]
 8001bca:	2b00      	cmp	r3, #0
 8001bcc:	d102      	bne.n	8001bd4 <vTaskDelayUntil+0x28>
 8001bce:	f7fe fff3 	bl	8000bb8 <ulPortSetInterruptMask>
 8001bd2:	e7fe      	b.n	8001bd2 <vTaskDelayUntil+0x26>

		vTaskSuspendAll();
 8001bd4:	f000 fadc 	bl	8002190 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 8001bd8:	687b      	ldr	r3, [r7, #4]
 8001bda:	681a      	ldr	r2, [r3, #0]
 8001bdc:	683b      	ldr	r3, [r7, #0]
 8001bde:	18d3      	adds	r3, r2, r3
 8001be0:	613b      	str	r3, [r7, #16]

			if( xTickCount < *pxPreviousWakeTime )
 8001be2:	687b      	ldr	r3, [r7, #4]
 8001be4:	681a      	ldr	r2, [r3, #0]
 8001be6:	f642 5390 	movw	r3, #11664	; 0x2d90
 8001bea:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8001bee:	681b      	ldr	r3, [r3, #0]
 8001bf0:	429a      	cmp	r2, r3
 8001bf2:	d910      	bls.n	8001c16 <vTaskDelayUntil+0x6a>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
 8001bf4:	687b      	ldr	r3, [r7, #4]
 8001bf6:	681a      	ldr	r2, [r3, #0]
 8001bf8:	693b      	ldr	r3, [r7, #16]
 8001bfa:	429a      	cmp	r2, r3
 8001bfc:	d91b      	bls.n	8001c36 <vTaskDelayUntil+0x8a>
 8001bfe:	f642 5390 	movw	r3, #11664	; 0x2d90
 8001c02:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8001c06:	681b      	ldr	r3, [r3, #0]
 8001c08:	693a      	ldr	r2, [r7, #16]
 8001c0a:	429a      	cmp	r2, r3
 8001c0c:	d913      	bls.n	8001c36 <vTaskDelayUntil+0x8a>
				{
					xShouldDelay = pdTRUE;
 8001c0e:	f04f 0301 	mov.w	r3, #1
 8001c12:	617b      	str	r3, [r7, #20]
 8001c14:	e00f      	b.n	8001c36 <vTaskDelayUntil+0x8a>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
 8001c16:	687b      	ldr	r3, [r7, #4]
 8001c18:	681a      	ldr	r2, [r3, #0]
 8001c1a:	693b      	ldr	r3, [r7, #16]
 8001c1c:	429a      	cmp	r2, r3
 8001c1e:	d807      	bhi.n	8001c30 <vTaskDelayUntil+0x84>
 8001c20:	f642 5390 	movw	r3, #11664	; 0x2d90
 8001c24:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8001c28:	681b      	ldr	r3, [r3, #0]
 8001c2a:	693a      	ldr	r2, [r7, #16]
 8001c2c:	429a      	cmp	r2, r3
 8001c2e:	d902      	bls.n	8001c36 <vTaskDelayUntil+0x8a>
				{
					xShouldDelay = pdTRUE;
 8001c30:	f04f 0301 	mov.w	r3, #1
 8001c34:	617b      	str	r3, [r7, #20]
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
 8001c36:	687b      	ldr	r3, [r7, #4]
 8001c38:	693a      	ldr	r2, [r7, #16]
 8001c3a:	601a      	str	r2, [r3, #0]

			if( xShouldDelay != pdFALSE )
 8001c3c:	697b      	ldr	r3, [r7, #20]
 8001c3e:	2b00      	cmp	r3, #0
 8001c40:	d00c      	beq.n	8001c5c <vTaskDelayUntil+0xb0>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
 8001c42:	f642 43b4 	movw	r3, #11444	; 0x2cb4
 8001c46:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8001c4a:	681b      	ldr	r3, [r3, #0]
 8001c4c:	f103 0304 	add.w	r3, r3, #4
 8001c50:	4618      	mov	r0, r3
 8001c52:	f7fe fca1 	bl	8000598 <uxListRemove>
					no need to check, and the port reset macro can be called
					directly. */
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
				}

				prvAddCurrentTaskToDelayedList( xTimeToWake );
 8001c56:	6938      	ldr	r0, [r7, #16]
 8001c58:	f001 f834 	bl	8002cc4 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
 8001c5c:	f000 faaa 	bl	80021b4 <xTaskResumeAll>
 8001c60:	60f8      	str	r0, [r7, #12]

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
 8001c62:	68fb      	ldr	r3, [r7, #12]
 8001c64:	2b00      	cmp	r3, #0
 8001c66:	d101      	bne.n	8001c6c <vTaskDelayUntil+0xc0>
		{
			portYIELD_WITHIN_API();
 8001c68:	f7fe ff6e 	bl	8000b48 <vPortYieldFromISR>
		}
	}
 8001c6c:	f107 0718 	add.w	r7, r7, #24
 8001c70:	46bd      	mov	sp, r7
 8001c72:	bd80      	pop	{r7, pc}

08001c74 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
 8001c74:	b580      	push	{r7, lr}
 8001c76:	b084      	sub	sp, #16
 8001c78:	af00      	add	r7, sp, #0
 8001c7a:	6078      	str	r0, [r7, #4]
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 8001c7c:	f04f 0300 	mov.w	r3, #0
 8001c80:	60fb      	str	r3, [r7, #12]

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
 8001c82:	687b      	ldr	r3, [r7, #4]
 8001c84:	2b00      	cmp	r3, #0
 8001c86:	d019      	beq.n	8001cbc <vTaskDelay+0x48>
		{
			vTaskSuspendAll();
 8001c88:	f000 fa82 	bl	8002190 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
 8001c8c:	f642 5390 	movw	r3, #11664	; 0x2d90
 8001c90:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8001c94:	681a      	ldr	r2, [r3, #0]
 8001c96:	687b      	ldr	r3, [r7, #4]
 8001c98:	18d3      	adds	r3, r2, r3
 8001c9a:	60bb      	str	r3, [r7, #8]

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
 8001c9c:	f642 43b4 	movw	r3, #11444	; 0x2cb4
 8001ca0:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8001ca4:	681b      	ldr	r3, [r3, #0]
 8001ca6:	f103 0304 	add.w	r3, r3, #4
 8001caa:	4618      	mov	r0, r3
 8001cac:	f7fe fc74 	bl	8000598 <uxListRemove>
					/* The current task must be in a ready list, so there is
					no need to check, and the port reset macro can be called
					directly. */
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
 8001cb0:	68b8      	ldr	r0, [r7, #8]
 8001cb2:	f001 f807 	bl	8002cc4 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
 8001cb6:	f000 fa7d 	bl	80021b4 <xTaskResumeAll>
 8001cba:	60f8      	str	r0, [r7, #12]
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
 8001cbc:	68fb      	ldr	r3, [r7, #12]
 8001cbe:	2b00      	cmp	r3, #0
 8001cc0:	d101      	bne.n	8001cc6 <vTaskDelay+0x52>
		{
			portYIELD_WITHIN_API();
 8001cc2:	f7fe ff41 	bl	8000b48 <vPortYieldFromISR>
		}
	}
 8001cc6:	f107 0710 	add.w	r7, r7, #16
 8001cca:	46bd      	mov	sp, r7
 8001ccc:	bd80      	pop	{r7, pc}
 8001cce:	bf00      	nop

08001cd0 <uxTaskPriorityGet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

	unsigned portBASE_TYPE uxTaskPriorityGet( xTaskHandle pxTask )
	{
 8001cd0:	b580      	push	{r7, lr}
 8001cd2:	b084      	sub	sp, #16
 8001cd4:	af00      	add	r7, sp, #0
 8001cd6:	6078      	str	r0, [r7, #4]
	tskTCB *pxTCB;
	unsigned portBASE_TYPE uxReturn;

		taskENTER_CRITICAL();
 8001cd8:	f7fe ff42 	bl	8000b60 <vPortEnterCritical>
		{
			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( pxTask );
 8001cdc:	687b      	ldr	r3, [r7, #4]
 8001cde:	2b00      	cmp	r3, #0
 8001ce0:	d105      	bne.n	8001cee <uxTaskPriorityGet+0x1e>
 8001ce2:	f642 43b4 	movw	r3, #11444	; 0x2cb4
 8001ce6:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8001cea:	681b      	ldr	r3, [r3, #0]
 8001cec:	e000      	b.n	8001cf0 <uxTaskPriorityGet+0x20>
 8001cee:	687b      	ldr	r3, [r7, #4]
 8001cf0:	60fb      	str	r3, [r7, #12]
			uxReturn = pxTCB->uxPriority;
 8001cf2:	68fb      	ldr	r3, [r7, #12]
 8001cf4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001cf6:	60bb      	str	r3, [r7, #8]
		}
		taskEXIT_CRITICAL();
 8001cf8:	f7fe ff44 	bl	8000b84 <vPortExitCritical>

		return uxReturn;
 8001cfc:	68bb      	ldr	r3, [r7, #8]
	}
 8001cfe:	4618      	mov	r0, r3
 8001d00:	f107 0710 	add.w	r7, r7, #16
 8001d04:	46bd      	mov	sp, r7
 8001d06:	bd80      	pop	{r7, pc}

08001d08 <vTaskPrioritySet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( xTaskHandle pxTask, unsigned portBASE_TYPE uxNewPriority )
	{
 8001d08:	b580      	push	{r7, lr}
 8001d0a:	b086      	sub	sp, #24
 8001d0c:	af00      	add	r7, sp, #0
 8001d0e:	6078      	str	r0, [r7, #4]
 8001d10:	6039      	str	r1, [r7, #0]
	tskTCB *pxTCB;
	unsigned portBASE_TYPE uxCurrentPriority, uxPriorityUsedOnEntry;
	portBASE_TYPE xYieldRequired = pdFALSE;
 8001d12:	f04f 0300 	mov.w	r3, #0
 8001d16:	617b      	str	r3, [r7, #20]

		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
 8001d18:	683b      	ldr	r3, [r7, #0]
 8001d1a:	2b04      	cmp	r3, #4
 8001d1c:	d902      	bls.n	8001d24 <vTaskPrioritySet+0x1c>
 8001d1e:	f7fe ff4b 	bl	8000bb8 <ulPortSetInterruptMask>
 8001d22:	e7fe      	b.n	8001d22 <vTaskPrioritySet+0x1a>

		/* Ensure the new priority is valid. */
		if( uxNewPriority >= configMAX_PRIORITIES )
 8001d24:	683b      	ldr	r3, [r7, #0]
 8001d26:	2b04      	cmp	r3, #4
 8001d28:	d902      	bls.n	8001d30 <vTaskPrioritySet+0x28>
		{
			uxNewPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
 8001d2a:	f04f 0304 	mov.w	r3, #4
 8001d2e:	603b      	str	r3, [r7, #0]
		}

		taskENTER_CRITICAL();
 8001d30:	f7fe ff16 	bl	8000b60 <vPortEnterCritical>
		{
			if( pxTask == pxCurrentTCB )
 8001d34:	f642 43b4 	movw	r3, #11444	; 0x2cb4
 8001d38:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8001d3c:	681b      	ldr	r3, [r3, #0]
 8001d3e:	687a      	ldr	r2, [r7, #4]
 8001d40:	429a      	cmp	r2, r3
 8001d42:	d102      	bne.n	8001d4a <vTaskPrioritySet+0x42>
			{
				pxTask = NULL;
 8001d44:	f04f 0300 	mov.w	r3, #0
 8001d48:	607b      	str	r3, [r7, #4]
			}

			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( pxTask );
 8001d4a:	687b      	ldr	r3, [r7, #4]
 8001d4c:	2b00      	cmp	r3, #0
 8001d4e:	d105      	bne.n	8001d5c <vTaskPrioritySet+0x54>
 8001d50:	f642 43b4 	movw	r3, #11444	; 0x2cb4
 8001d54:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8001d58:	681b      	ldr	r3, [r3, #0]
 8001d5a:	e000      	b.n	8001d5e <vTaskPrioritySet+0x56>
 8001d5c:	687b      	ldr	r3, [r7, #4]
 8001d5e:	613b      	str	r3, [r7, #16]

			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );

			#if ( configUSE_MUTEXES == 1 )
			{
				uxCurrentPriority = pxTCB->uxBasePriority;
 8001d60:	693b      	ldr	r3, [r7, #16]
 8001d62:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8001d64:	60fb      	str	r3, [r7, #12]
			{
				uxCurrentPriority = pxTCB->uxPriority;
			}
			#endif

			if( uxCurrentPriority != uxNewPriority )
 8001d66:	68fa      	ldr	r2, [r7, #12]
 8001d68:	683b      	ldr	r3, [r7, #0]
 8001d6a:	429a      	cmp	r2, r3
 8001d6c:	d063      	beq.n	8001e36 <vTaskPrioritySet+0x12e>
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentPriority )
 8001d6e:	683a      	ldr	r2, [r7, #0]
 8001d70:	68fb      	ldr	r3, [r7, #12]
 8001d72:	429a      	cmp	r2, r3
 8001d74:	d906      	bls.n	8001d84 <vTaskPrioritySet+0x7c>
				{
					if( pxTask != NULL )
 8001d76:	687b      	ldr	r3, [r7, #4]
 8001d78:	2b00      	cmp	r3, #0
 8001d7a:	d009      	beq.n	8001d90 <vTaskPrioritySet+0x88>
					{
						/* The priority of another task is being raised.  If we
						were raising the priority of the currently running task
						there would be no need to switch as it must have already
						been the highest priority task. */
						xYieldRequired = pdTRUE;
 8001d7c:	f04f 0301 	mov.w	r3, #1
 8001d80:	617b      	str	r3, [r7, #20]
 8001d82:	e005      	b.n	8001d90 <vTaskPrioritySet+0x88>
					}
				}
				else if( pxTask == NULL )
 8001d84:	687b      	ldr	r3, [r7, #4]
 8001d86:	2b00      	cmp	r3, #0
 8001d88:	d102      	bne.n	8001d90 <vTaskPrioritySet+0x88>
				{
					/* Setting our own priority down means there may now be another
					task of higher priority that is ready to execute. */
					xYieldRequired = pdTRUE;
 8001d8a:	f04f 0301 	mov.w	r3, #1
 8001d8e:	617b      	str	r3, [r7, #20]
				}

				/* Remember the ready list the task might be referenced from
				before its uxPriority member is changed so the
				taskRESET_READY_PRIORITY() macro can function correctly. */
				uxPriorityUsedOnEntry = pxTCB->uxPriority;
 8001d90:	693b      	ldr	r3, [r7, #16]
 8001d92:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001d94:	60bb      	str	r3, [r7, #8]

				#if ( configUSE_MUTEXES == 1 )
				{
					/* Only change the priority being used if the task is not
					currently using an inherited priority. */
					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
 8001d96:	693b      	ldr	r3, [r7, #16]
 8001d98:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 8001d9a:	693b      	ldr	r3, [r7, #16]
 8001d9c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001d9e:	429a      	cmp	r2, r3
 8001da0:	d102      	bne.n	8001da8 <vTaskPrioritySet+0xa0>
					{
						pxTCB->uxPriority = uxNewPriority;
 8001da2:	693b      	ldr	r3, [r7, #16]
 8001da4:	683a      	ldr	r2, [r7, #0]
 8001da6:	62da      	str	r2, [r3, #44]	; 0x2c
					}

					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;
 8001da8:	693b      	ldr	r3, [r7, #16]
 8001daa:	683a      	ldr	r2, [r7, #0]
 8001dac:	649a      	str	r2, [r3, #72]	; 0x48
				{
					pxTCB->uxPriority = uxNewPriority;
				}
				#endif

				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( configMAX_PRIORITIES - ( portTickType ) uxNewPriority ) );
 8001dae:	683b      	ldr	r3, [r7, #0]
 8001db0:	f1c3 0205 	rsb	r2, r3, #5
 8001db4:	693b      	ldr	r3, [r7, #16]
 8001db6:	619a      	str	r2, [r3, #24]

				/* If the task is in the blocked or suspended list we need do
				nothing more than change it's priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the queue appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxCurrentPriority ] ), &( pxTCB->xGenericListItem ) ) )
 8001db8:	693b      	ldr	r3, [r7, #16]
 8001dba:	6959      	ldr	r1, [r3, #20]
 8001dbc:	68fa      	ldr	r2, [r7, #12]
 8001dbe:	4613      	mov	r3, r2
 8001dc0:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8001dc4:	189b      	adds	r3, r3, r2
 8001dc6:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8001dca:	f642 42b8 	movw	r2, #11448	; 0x2cb8
 8001dce:	f2c2 0201 	movt	r2, #8193	; 0x2001
 8001dd2:	189b      	adds	r3, r3, r2
 8001dd4:	4299      	cmp	r1, r3
 8001dd6:	d129      	bne.n	8001e2c <vTaskPrioritySet+0x124>
				{
					/* The task is currently in its ready list - remove before adding
					it to it's new ready list.  As we are in a critical section we
					can do this even if the scheduler is suspended. */
					if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
 8001dd8:	693b      	ldr	r3, [r7, #16]
 8001dda:	f103 0304 	add.w	r3, r3, #4
 8001dde:	4618      	mov	r0, r3
 8001de0:	f7fe fbda 	bl	8000598 <uxListRemove>
					{
						taskRESET_READY_PRIORITY( uxPriorityUsedOnEntry );
					}
					prvAddTaskToReadyQueue( pxTCB );
 8001de4:	693b      	ldr	r3, [r7, #16]
 8001de6:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001de8:	f642 5398 	movw	r3, #11672	; 0x2d98
 8001dec:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8001df0:	681b      	ldr	r3, [r3, #0]
 8001df2:	429a      	cmp	r2, r3
 8001df4:	d906      	bls.n	8001e04 <vTaskPrioritySet+0xfc>
 8001df6:	693b      	ldr	r3, [r7, #16]
 8001df8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001dfa:	f642 5398 	movw	r3, #11672	; 0x2d98
 8001dfe:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8001e02:	601a      	str	r2, [r3, #0]
 8001e04:	693b      	ldr	r3, [r7, #16]
 8001e06:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001e08:	4613      	mov	r3, r2
 8001e0a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8001e0e:	189b      	adds	r3, r3, r2
 8001e10:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8001e14:	f642 42b8 	movw	r2, #11448	; 0x2cb8
 8001e18:	f2c2 0201 	movt	r2, #8193	; 0x2001
 8001e1c:	189a      	adds	r2, r3, r2
 8001e1e:	693b      	ldr	r3, [r7, #16]
 8001e20:	f103 0304 	add.w	r3, r3, #4
 8001e24:	4610      	mov	r0, r2
 8001e26:	4619      	mov	r1, r3
 8001e28:	f7fe fb54 	bl	80004d4 <vListInsertEnd>
				}

				if( xYieldRequired == pdTRUE )
 8001e2c:	697b      	ldr	r3, [r7, #20]
 8001e2e:	2b01      	cmp	r3, #1
 8001e30:	d101      	bne.n	8001e36 <vTaskPrioritySet+0x12e>
				{
					portYIELD_WITHIN_API();
 8001e32:	f7fe fe89 	bl	8000b48 <vPortYieldFromISR>
				}
			}
		}
		taskEXIT_CRITICAL();
 8001e36:	f7fe fea5 	bl	8000b84 <vPortExitCritical>

		/* Remove compiler warning about unused parameter when the port
		optimised task selection is not being used. */
		( void ) uxPriorityUsedOnEntry;
	}
 8001e3a:	f107 0718 	add.w	r7, r7, #24
 8001e3e:	46bd      	mov	sp, r7
 8001e40:	bd80      	pop	{r7, pc}
 8001e42:	bf00      	nop

08001e44 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( xTaskHandle pxTaskToSuspend )
	{
 8001e44:	b580      	push	{r7, lr}
 8001e46:	b084      	sub	sp, #16
 8001e48:	af00      	add	r7, sp, #0
 8001e4a:	6078      	str	r0, [r7, #4]
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
 8001e4c:	f7fe fe88 	bl	8000b60 <vPortEnterCritical>
		{
			/* Ensure a yield is performed if the current task is being
			suspended. */
			if( pxTaskToSuspend == pxCurrentTCB )
 8001e50:	f642 43b4 	movw	r3, #11444	; 0x2cb4
 8001e54:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8001e58:	681b      	ldr	r3, [r3, #0]
 8001e5a:	687a      	ldr	r2, [r7, #4]
 8001e5c:	429a      	cmp	r2, r3
 8001e5e:	d102      	bne.n	8001e66 <vTaskSuspend+0x22>
			{
				pxTaskToSuspend = NULL;
 8001e60:	f04f 0300 	mov.w	r3, #0
 8001e64:	607b      	str	r3, [r7, #4]
			}

			/* If null is passed in here then we are suspending ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
 8001e66:	687b      	ldr	r3, [r7, #4]
 8001e68:	2b00      	cmp	r3, #0
 8001e6a:	d105      	bne.n	8001e78 <vTaskSuspend+0x34>
 8001e6c:	f642 43b4 	movw	r3, #11444	; 0x2cb4
 8001e70:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8001e74:	681b      	ldr	r3, [r3, #0]
 8001e76:	e000      	b.n	8001e7a <vTaskSuspend+0x36>
 8001e78:	687b      	ldr	r3, [r7, #4]
 8001e7a:	60fb      	str	r3, [r7, #12]

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the	suspended list. */
			if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
 8001e7c:	68fb      	ldr	r3, [r7, #12]
 8001e7e:	f103 0304 	add.w	r3, r3, #4
 8001e82:	4618      	mov	r0, r3
 8001e84:	f7fe fb88 	bl	8000598 <uxListRemove>
			{
				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
			}

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
 8001e88:	68fb      	ldr	r3, [r7, #12]
 8001e8a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8001e8c:	2b00      	cmp	r3, #0
 8001e8e:	d005      	beq.n	8001e9c <vTaskSuspend+0x58>
			{
				uxListRemove( &( pxTCB->xEventListItem ) );
 8001e90:	68fb      	ldr	r3, [r7, #12]
 8001e92:	f103 0318 	add.w	r3, r3, #24
 8001e96:	4618      	mov	r0, r3
 8001e98:	f7fe fb7e 	bl	8000598 <uxListRemove>
			}

			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
 8001e9c:	68fb      	ldr	r3, [r7, #12]
 8001e9e:	f103 0304 	add.w	r3, r3, #4
 8001ea2:	f642 5078 	movw	r0, #11640	; 0x2d78
 8001ea6:	f2c2 0001 	movt	r0, #8193	; 0x2001
 8001eaa:	4619      	mov	r1, r3
 8001eac:	f7fe fb12 	bl	80004d4 <vListInsertEnd>
		}
		taskEXIT_CRITICAL();
 8001eb0:	f7fe fe68 	bl	8000b84 <vPortExitCritical>

		if( ( void * ) pxTaskToSuspend == NULL )
 8001eb4:	687b      	ldr	r3, [r7, #4]
 8001eb6:	2b00      	cmp	r3, #0
 8001eb8:	d11f      	bne.n	8001efa <vTaskSuspend+0xb6>
		{
			if( xSchedulerRunning != pdFALSE )
 8001eba:	f642 539c 	movw	r3, #11676	; 0x2d9c
 8001ebe:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8001ec2:	681b      	ldr	r3, [r3, #0]
 8001ec4:	2b00      	cmp	r3, #0
 8001ec6:	d002      	beq.n	8001ece <vTaskSuspend+0x8a>
			{
				/* We have just suspended the current task. */
				portYIELD_WITHIN_API();
 8001ec8:	f7fe fe3e 	bl	8000b48 <vPortYieldFromISR>
 8001ecc:	e015      	b.n	8001efa <vTaskSuspend+0xb6>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
 8001ece:	f642 5378 	movw	r3, #11640	; 0x2d78
 8001ed2:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8001ed6:	681a      	ldr	r2, [r3, #0]
 8001ed8:	f642 538c 	movw	r3, #11660	; 0x2d8c
 8001edc:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8001ee0:	681b      	ldr	r3, [r3, #0]
 8001ee2:	429a      	cmp	r2, r3
 8001ee4:	d107      	bne.n	8001ef6 <vTaskSuspend+0xb2>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
 8001ee6:	f642 43b4 	movw	r3, #11444	; 0x2cb4
 8001eea:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8001eee:	f04f 0200 	mov.w	r2, #0
 8001ef2:	601a      	str	r2, [r3, #0]
 8001ef4:	e001      	b.n	8001efa <vTaskSuspend+0xb6>
				}
				else
				{
					vTaskSwitchContext();
 8001ef6:	f000 fbc3 	bl	8002680 <vTaskSwitchContext>
				}
			}
		}
	}
 8001efa:	f107 0710 	add.w	r7, r7, #16
 8001efe:	46bd      	mov	sp, r7
 8001f00:	bd80      	pop	{r7, pc}
 8001f02:	bf00      	nop

08001f04 <xTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
	{
 8001f04:	b580      	push	{r7, lr}
 8001f06:	b084      	sub	sp, #16
 8001f08:	af00      	add	r7, sp, #0
 8001f0a:	6078      	str	r0, [r7, #4]
	portBASE_TYPE xReturn = pdFALSE;
 8001f0c:	f04f 0300 	mov.w	r3, #0
 8001f10:	60fb      	str	r3, [r7, #12]
	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
 8001f12:	687b      	ldr	r3, [r7, #4]
 8001f14:	60bb      	str	r3, [r7, #8]

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );
 8001f16:	687b      	ldr	r3, [r7, #4]
 8001f18:	2b00      	cmp	r3, #0
 8001f1a:	d102      	bne.n	8001f22 <xTaskIsTaskSuspended+0x1e>
 8001f1c:	f7fe fe4c 	bl	8000bb8 <ulPortSetInterruptMask>
 8001f20:	e7fe      	b.n	8001f20 <xTaskIsTaskSuspended+0x1c>

		/* Is the task we are attempting to resume actually in the
		suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
 8001f22:	68bb      	ldr	r3, [r7, #8]
 8001f24:	695a      	ldr	r2, [r3, #20]
 8001f26:	f642 5378 	movw	r3, #11640	; 0x2d78
 8001f2a:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8001f2e:	429a      	cmp	r2, r3
 8001f30:	d10e      	bne.n	8001f50 <xTaskIsTaskSuspended+0x4c>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
 8001f32:	68bb      	ldr	r3, [r7, #8]
 8001f34:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8001f36:	f642 534c 	movw	r3, #11596	; 0x2d4c
 8001f3a:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8001f3e:	429a      	cmp	r2, r3
 8001f40:	d006      	beq.n	8001f50 <xTaskIsTaskSuspended+0x4c>
			{
				/* Is it in the suspended list because it is in the
				Suspended state?  It is possible to be in the suspended
				list because it is blocked on a task with no timeout
				specified. */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) == pdTRUE )
 8001f42:	68bb      	ldr	r3, [r7, #8]
 8001f44:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8001f46:	2b00      	cmp	r3, #0
 8001f48:	d102      	bne.n	8001f50 <xTaskIsTaskSuspended+0x4c>
				{
					xReturn = pdTRUE;
 8001f4a:	f04f 0301 	mov.w	r3, #1
 8001f4e:	60fb      	str	r3, [r7, #12]
				}
			}
		}

		return xReturn;
 8001f50:	68fb      	ldr	r3, [r7, #12]
	}
 8001f52:	4618      	mov	r0, r3
 8001f54:	f107 0710 	add.w	r7, r7, #16
 8001f58:	46bd      	mov	sp, r7
 8001f5a:	bd80      	pop	{r7, pc}

08001f5c <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( xTaskHandle pxTaskToResume )
	{
 8001f5c:	b580      	push	{r7, lr}
 8001f5e:	b084      	sub	sp, #16
 8001f60:	af00      	add	r7, sp, #0
 8001f62:	6078      	str	r0, [r7, #4]
	tskTCB *pxTCB;

		/* It does not make sense to resume the calling task. */
		configASSERT( pxTaskToResume );
 8001f64:	687b      	ldr	r3, [r7, #4]
 8001f66:	2b00      	cmp	r3, #0
 8001f68:	d102      	bne.n	8001f70 <vTaskResume+0x14>
 8001f6a:	f7fe fe25 	bl	8000bb8 <ulPortSetInterruptMask>
 8001f6e:	e7fe      	b.n	8001f6e <vTaskResume+0x12>

		/* Remove the task from whichever list it is currently in, and place
		it in the ready list. */
		pxTCB = ( tskTCB * ) pxTaskToResume;
 8001f70:	687b      	ldr	r3, [r7, #4]
 8001f72:	60fb      	str	r3, [r7, #12]

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
 8001f74:	68fb      	ldr	r3, [r7, #12]
 8001f76:	2b00      	cmp	r3, #0
 8001f78:	d047      	beq.n	800200a <vTaskResume+0xae>
 8001f7a:	f642 43b4 	movw	r3, #11444	; 0x2cb4
 8001f7e:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8001f82:	681b      	ldr	r3, [r3, #0]
 8001f84:	68fa      	ldr	r2, [r7, #12]
 8001f86:	429a      	cmp	r2, r3
 8001f88:	d03f      	beq.n	800200a <vTaskResume+0xae>
		{
			taskENTER_CRITICAL();
 8001f8a:	f7fe fde9 	bl	8000b60 <vPortEnterCritical>
			{
				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 8001f8e:	68f8      	ldr	r0, [r7, #12]
 8001f90:	f7ff ffb8 	bl	8001f04 <xTaskIsTaskSuspended>
 8001f94:	4603      	mov	r3, r0
 8001f96:	2b01      	cmp	r3, #1
 8001f98:	d135      	bne.n	8002006 <vTaskResume+0xaa>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					uxListRemove(  &( pxTCB->xGenericListItem ) );
 8001f9a:	68fb      	ldr	r3, [r7, #12]
 8001f9c:	f103 0304 	add.w	r3, r3, #4
 8001fa0:	4618      	mov	r0, r3
 8001fa2:	f7fe faf9 	bl	8000598 <uxListRemove>
					prvAddTaskToReadyQueue( pxTCB );
 8001fa6:	68fb      	ldr	r3, [r7, #12]
 8001fa8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001faa:	f642 5398 	movw	r3, #11672	; 0x2d98
 8001fae:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8001fb2:	681b      	ldr	r3, [r3, #0]
 8001fb4:	429a      	cmp	r2, r3
 8001fb6:	d906      	bls.n	8001fc6 <vTaskResume+0x6a>
 8001fb8:	68fb      	ldr	r3, [r7, #12]
 8001fba:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001fbc:	f642 5398 	movw	r3, #11672	; 0x2d98
 8001fc0:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8001fc4:	601a      	str	r2, [r3, #0]
 8001fc6:	68fb      	ldr	r3, [r7, #12]
 8001fc8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001fca:	4613      	mov	r3, r2
 8001fcc:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8001fd0:	189b      	adds	r3, r3, r2
 8001fd2:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8001fd6:	f642 42b8 	movw	r2, #11448	; 0x2cb8
 8001fda:	f2c2 0201 	movt	r2, #8193	; 0x2001
 8001fde:	189a      	adds	r2, r3, r2
 8001fe0:	68fb      	ldr	r3, [r7, #12]
 8001fe2:	f103 0304 	add.w	r3, r3, #4
 8001fe6:	4610      	mov	r0, r2
 8001fe8:	4619      	mov	r1, r3
 8001fea:	f7fe fa73 	bl	80004d4 <vListInsertEnd>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8001fee:	68fb      	ldr	r3, [r7, #12]
 8001ff0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001ff2:	f642 43b4 	movw	r3, #11444	; 0x2cb4
 8001ff6:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8001ffa:	681b      	ldr	r3, [r3, #0]
 8001ffc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001ffe:	429a      	cmp	r2, r3
 8002000:	d301      	bcc.n	8002006 <vTaskResume+0xaa>
					{
						/* This yield may not cause the task just resumed to run, but
						will leave the lists in the correct state for the next yield. */
						portYIELD_WITHIN_API();
 8002002:	f7fe fda1 	bl	8000b48 <vPortYieldFromISR>
					}
				}
			}
			taskEXIT_CRITICAL();
 8002006:	f7fe fdbd 	bl	8000b84 <vPortExitCritical>
		}
	}
 800200a:	f107 0710 	add.w	r7, r7, #16
 800200e:	46bd      	mov	sp, r7
 8002010:	bd80      	pop	{r7, pc}
 8002012:	bf00      	nop

08002014 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
	{
 8002014:	b580      	push	{r7, lr}
 8002016:	b086      	sub	sp, #24
 8002018:	af00      	add	r7, sp, #0
 800201a:	6078      	str	r0, [r7, #4]
	portBASE_TYPE xYieldRequired = pdFALSE;
 800201c:	f04f 0300 	mov.w	r3, #0
 8002020:	617b      	str	r3, [r7, #20]
	tskTCB *pxTCB;
	unsigned portBASE_TYPE uxSavedInterruptStatus;

		configASSERT( pxTaskToResume );
 8002022:	687b      	ldr	r3, [r7, #4]
 8002024:	2b00      	cmp	r3, #0
 8002026:	d102      	bne.n	800202e <xTaskResumeFromISR+0x1a>
 8002028:	f7fe fdc6 	bl	8000bb8 <ulPortSetInterruptMask>
 800202c:	e7fe      	b.n	800202c <xTaskResumeFromISR+0x18>

		pxTCB = ( tskTCB * ) pxTaskToResume;
 800202e:	687b      	ldr	r3, [r7, #4]
 8002030:	613b      	str	r3, [r7, #16]

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 8002032:	f7fe fdc1 	bl	8000bb8 <ulPortSetInterruptMask>
 8002036:	60f8      	str	r0, [r7, #12]
		{
			if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 8002038:	6938      	ldr	r0, [r7, #16]
 800203a:	f7ff ff63 	bl	8001f04 <xTaskIsTaskSuspended>
 800203e:	4603      	mov	r3, r0
 8002040:	2b01      	cmp	r3, #1
 8002042:	d149      	bne.n	80020d8 <xTaskResumeFromISR+0xc4>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 8002044:	f642 53a0 	movw	r3, #11680	; 0x2da0
 8002048:	f2c2 0301 	movt	r3, #8193	; 0x2001
 800204c:	681b      	ldr	r3, [r3, #0]
 800204e:	2b00      	cmp	r3, #0
 8002050:	d138      	bne.n	80020c4 <xTaskResumeFromISR+0xb0>
				{
					xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
 8002052:	693b      	ldr	r3, [r7, #16]
 8002054:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8002056:	f642 43b4 	movw	r3, #11444	; 0x2cb4
 800205a:	f2c2 0301 	movt	r3, #8193	; 0x2001
 800205e:	681b      	ldr	r3, [r3, #0]
 8002060:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8002062:	429a      	cmp	r2, r3
 8002064:	bf34      	ite	cc
 8002066:	2300      	movcc	r3, #0
 8002068:	2301      	movcs	r3, #1
 800206a:	b2db      	uxtb	r3, r3
 800206c:	617b      	str	r3, [r7, #20]
					uxListRemove(  &( pxTCB->xGenericListItem ) );
 800206e:	693b      	ldr	r3, [r7, #16]
 8002070:	f103 0304 	add.w	r3, r3, #4
 8002074:	4618      	mov	r0, r3
 8002076:	f7fe fa8f 	bl	8000598 <uxListRemove>
					prvAddTaskToReadyQueue( pxTCB );
 800207a:	693b      	ldr	r3, [r7, #16]
 800207c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800207e:	f642 5398 	movw	r3, #11672	; 0x2d98
 8002082:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8002086:	681b      	ldr	r3, [r3, #0]
 8002088:	429a      	cmp	r2, r3
 800208a:	d906      	bls.n	800209a <xTaskResumeFromISR+0x86>
 800208c:	693b      	ldr	r3, [r7, #16]
 800208e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8002090:	f642 5398 	movw	r3, #11672	; 0x2d98
 8002094:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8002098:	601a      	str	r2, [r3, #0]
 800209a:	693b      	ldr	r3, [r7, #16]
 800209c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800209e:	4613      	mov	r3, r2
 80020a0:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80020a4:	189b      	adds	r3, r3, r2
 80020a6:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80020aa:	f642 42b8 	movw	r2, #11448	; 0x2cb8
 80020ae:	f2c2 0201 	movt	r2, #8193	; 0x2001
 80020b2:	189a      	adds	r2, r3, r2
 80020b4:	693b      	ldr	r3, [r7, #16]
 80020b6:	f103 0304 	add.w	r3, r3, #4
 80020ba:	4610      	mov	r0, r2
 80020bc:	4619      	mov	r1, r3
 80020be:	f7fe fa09 	bl	80004d4 <vListInsertEnd>
 80020c2:	e009      	b.n	80020d8 <xTaskResumeFromISR+0xc4>
				else
				{
					/* We cannot access the delayed or ready lists, so will hold this
					task pending until the scheduler is resumed, at which point a
					yield will be performed if necessary. */
					vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 80020c4:	693b      	ldr	r3, [r7, #16]
 80020c6:	f103 0318 	add.w	r3, r3, #24
 80020ca:	f642 504c 	movw	r0, #11596	; 0x2d4c
 80020ce:	f2c2 0001 	movt	r0, #8193	; 0x2001
 80020d2:	4619      	mov	r1, r3
 80020d4:	f7fe f9fe 	bl	80004d4 <vListInsertEnd>
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 80020d8:	68f8      	ldr	r0, [r7, #12]
 80020da:	f7fe fd77 	bl	8000bcc <vPortClearInterruptMask>

		return xYieldRequired;
 80020de:	697b      	ldr	r3, [r7, #20]
	}
 80020e0:	4618      	mov	r0, r3
 80020e2:	f107 0718 	add.w	r7, r7, #24
 80020e6:	46bd      	mov	sp, r7
 80020e8:	bd80      	pop	{r7, pc}
 80020ea:	bf00      	nop

080020ec <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
 80020ec:	b580      	push	{r7, lr}
 80020ee:	b086      	sub	sp, #24
 80020f0:	af04      	add	r7, sp, #16
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
 80020f2:	f04f 0300 	mov.w	r3, #0
 80020f6:	9300      	str	r3, [sp, #0]
 80020f8:	f04f 0300 	mov.w	r3, #0
 80020fc:	9301      	str	r3, [sp, #4]
 80020fe:	f04f 0300 	mov.w	r3, #0
 8002102:	9302      	str	r3, [sp, #8]
 8002104:	f04f 0300 	mov.w	r3, #0
 8002108:	9303      	str	r3, [sp, #12]
 800210a:	f642 20e9 	movw	r0, #10985	; 0x2ae9
 800210e:	f6c0 0000 	movt	r0, #2048	; 0x800
 8002112:	f244 21b4 	movw	r1, #17076	; 0x42b4
 8002116:	f6c0 0100 	movt	r1, #2048	; 0x800
 800211a:	f04f 0282 	mov.w	r2, #130	; 0x82
 800211e:	f04f 0300 	mov.w	r3, #0
 8002122:	f7ff fbf3 	bl	800190c <xTaskGenericCreate>
 8002126:	6078      	str	r0, [r7, #4]
	}
	#endif

	#if ( configUSE_TIMERS == 1 )
	{
		if( xReturn == pdPASS )
 8002128:	687b      	ldr	r3, [r7, #4]
 800212a:	2b01      	cmp	r3, #1
 800212c:	d102      	bne.n	8002134 <vTaskStartScheduler+0x48>
		{
			xReturn = xTimerCreateTimerTask();
 800212e:	f000 ffbf 	bl	80030b0 <xTimerCreateTimerTask>
 8002132:	6078      	str	r0, [r7, #4]
		}
	}
	#endif

	if( xReturn == pdPASS )
 8002134:	687b      	ldr	r3, [r7, #4]
 8002136:	2b01      	cmp	r3, #1
 8002138:	d111      	bne.n	800215e <vTaskStartScheduler+0x72>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
 800213a:	f7fe fd3d 	bl	8000bb8 <ulPortSetInterruptMask>

		xSchedulerRunning = pdTRUE;
 800213e:	f642 539c 	movw	r3, #11676	; 0x2d9c
 8002142:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8002146:	f04f 0201 	mov.w	r2, #1
 800214a:	601a      	str	r2, [r3, #0]
		xTickCount = ( portTickType ) 0U;
 800214c:	f642 5390 	movw	r3, #11664	; 0x2d90
 8002150:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8002154:	f04f 0200 	mov.w	r2, #0
 8002158:	601a      	str	r2, [r3, #0]
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
 800215a:	f7fe fcb7 	bl	8000acc <xPortStartScheduler>
			/* Should only reach here if a task calls xTaskEndScheduler(). */
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
 800215e:	687b      	ldr	r3, [r7, #4]
 8002160:	2b00      	cmp	r3, #0
 8002162:	d102      	bne.n	800216a <vTaskStartScheduler+0x7e>
 8002164:	f7fe fd28 	bl	8000bb8 <ulPortSetInterruptMask>
 8002168:	e7fe      	b.n	8002168 <vTaskStartScheduler+0x7c>
}
 800216a:	f107 0708 	add.w	r7, r7, #8
 800216e:	46bd      	mov	sp, r7
 8002170:	bd80      	pop	{r7, pc}
 8002172:	bf00      	nop

08002174 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
 8002174:	b580      	push	{r7, lr}
 8002176:	af00      	add	r7, sp, #0
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
 8002178:	f7fe fd1e 	bl	8000bb8 <ulPortSetInterruptMask>
	xSchedulerRunning = pdFALSE;
 800217c:	f642 539c 	movw	r3, #11676	; 0x2d9c
 8002180:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8002184:	f04f 0200 	mov.w	r2, #0
 8002188:	601a      	str	r2, [r3, #0]
	vPortEndScheduler();
 800218a:	f7fe fcd7 	bl	8000b3c <vPortEndScheduler>
}
 800218e:	bd80      	pop	{r7, pc}

08002190 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
 8002190:	b480      	push	{r7}
 8002192:	af00      	add	r7, sp, #0
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
 8002194:	f642 53a0 	movw	r3, #11680	; 0x2da0
 8002198:	f2c2 0301 	movt	r3, #8193	; 0x2001
 800219c:	681b      	ldr	r3, [r3, #0]
 800219e:	f103 0201 	add.w	r2, r3, #1
 80021a2:	f642 53a0 	movw	r3, #11680	; 0x2da0
 80021a6:	f2c2 0301 	movt	r3, #8193	; 0x2001
 80021aa:	601a      	str	r2, [r3, #0]
}
 80021ac:	46bd      	mov	sp, r7
 80021ae:	bc80      	pop	{r7}
 80021b0:	4770      	bx	lr
 80021b2:	bf00      	nop

080021b4 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE != 0  */
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
 80021b4:	b590      	push	{r4, r7, lr}
 80021b6:	b083      	sub	sp, #12
 80021b8:	af00      	add	r7, sp, #0
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 80021ba:	f04f 0300 	mov.w	r3, #0
 80021be:	607b      	str	r3, [r7, #4]

	/* If uxSchedulerSuspended is zero then this function does not match a
	previous call to vTaskSuspendAll(). */
	configASSERT( uxSchedulerSuspended );
 80021c0:	f642 53a0 	movw	r3, #11680	; 0x2da0
 80021c4:	f2c2 0301 	movt	r3, #8193	; 0x2001
 80021c8:	681b      	ldr	r3, [r3, #0]
 80021ca:	2b00      	cmp	r3, #0
 80021cc:	d102      	bne.n	80021d4 <xTaskResumeAll+0x20>
 80021ce:	f7fe fcf3 	bl	8000bb8 <ulPortSetInterruptMask>
 80021d2:	e7fe      	b.n	80021d2 <xTaskResumeAll+0x1e>
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
 80021d4:	f7fe fcc4 	bl	8000b60 <vPortEnterCritical>
	{
		--uxSchedulerSuspended;
 80021d8:	f642 53a0 	movw	r3, #11680	; 0x2da0
 80021dc:	f2c2 0301 	movt	r3, #8193	; 0x2001
 80021e0:	681b      	ldr	r3, [r3, #0]
 80021e2:	f103 32ff 	add.w	r2, r3, #4294967295	; 0xffffffff
 80021e6:	f642 53a0 	movw	r3, #11680	; 0x2da0
 80021ea:	f2c2 0301 	movt	r3, #8193	; 0x2001
 80021ee:	601a      	str	r2, [r3, #0]

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 80021f0:	f642 53a0 	movw	r3, #11680	; 0x2da0
 80021f4:	f2c2 0301 	movt	r3, #8193	; 0x2001
 80021f8:	681b      	ldr	r3, [r3, #0]
 80021fa:	2b00      	cmp	r3, #0
 80021fc:	f040 8084 	bne.w	8002308 <xTaskResumeAll+0x154>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
 8002200:	f642 538c 	movw	r3, #11660	; 0x2d8c
 8002204:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8002208:	681b      	ldr	r3, [r3, #0]
 800220a:	2b00      	cmp	r3, #0
 800220c:	d07c      	beq.n	8002308 <xTaskResumeAll+0x154>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
 800220e:	f04f 0300 	mov.w	r3, #0
 8002212:	603b      	str	r3, [r7, #0]

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
 8002214:	e03b      	b.n	800228e <xTaskResumeAll+0xda>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
 8002216:	f642 534c 	movw	r3, #11596	; 0x2d4c
 800221a:	f2c2 0301 	movt	r3, #8193	; 0x2001
 800221e:	68db      	ldr	r3, [r3, #12]
 8002220:	68dc      	ldr	r4, [r3, #12]
					uxListRemove( &( pxTCB->xEventListItem ) );
 8002222:	f104 0318 	add.w	r3, r4, #24
 8002226:	4618      	mov	r0, r3
 8002228:	f7fe f9b6 	bl	8000598 <uxListRemove>
					uxListRemove( &( pxTCB->xGenericListItem ) );
 800222c:	f104 0304 	add.w	r3, r4, #4
 8002230:	4618      	mov	r0, r3
 8002232:	f7fe f9b1 	bl	8000598 <uxListRemove>
					prvAddTaskToReadyQueue( pxTCB );
 8002236:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8002238:	f642 5398 	movw	r3, #11672	; 0x2d98
 800223c:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8002240:	681b      	ldr	r3, [r3, #0]
 8002242:	429a      	cmp	r2, r3
 8002244:	d905      	bls.n	8002252 <xTaskResumeAll+0x9e>
 8002246:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8002248:	f642 5398 	movw	r3, #11672	; 0x2d98
 800224c:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8002250:	601a      	str	r2, [r3, #0]
 8002252:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8002254:	4613      	mov	r3, r2
 8002256:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800225a:	189b      	adds	r3, r3, r2
 800225c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002260:	f642 42b8 	movw	r2, #11448	; 0x2cb8
 8002264:	f2c2 0201 	movt	r2, #8193	; 0x2001
 8002268:	189a      	adds	r2, r3, r2
 800226a:	f104 0304 	add.w	r3, r4, #4
 800226e:	4610      	mov	r0, r2
 8002270:	4619      	mov	r1, r3
 8002272:	f7fe f92f 	bl	80004d4 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8002276:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8002278:	f642 43b4 	movw	r3, #11444	; 0x2cb4
 800227c:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8002280:	681b      	ldr	r3, [r3, #0]
 8002282:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8002284:	429a      	cmp	r2, r3
 8002286:	d302      	bcc.n	800228e <xTaskResumeAll+0xda>
					{
						xYieldRequired = pdTRUE;
 8002288:	f04f 0301 	mov.w	r3, #1
 800228c:	603b      	str	r3, [r7, #0]
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
 800228e:	f642 534c 	movw	r3, #11596	; 0x2d4c
 8002292:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8002296:	681b      	ldr	r3, [r3, #0]
 8002298:	2b00      	cmp	r3, #0
 800229a:	d1bc      	bne.n	8002216 <xTaskResumeAll+0x62>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
 800229c:	f642 53a4 	movw	r3, #11684	; 0x2da4
 80022a0:	f2c2 0301 	movt	r3, #8193	; 0x2001
 80022a4:	681b      	ldr	r3, [r3, #0]
 80022a6:	2b00      	cmp	r3, #0
 80022a8:	d018      	beq.n	80022dc <xTaskResumeAll+0x128>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
 80022aa:	e00d      	b.n	80022c8 <xTaskResumeAll+0x114>
					{
						vTaskIncrementTick();
 80022ac:	f000 f8f8 	bl	80024a0 <vTaskIncrementTick>
						--uxMissedTicks;
 80022b0:	f642 53a4 	movw	r3, #11684	; 0x2da4
 80022b4:	f2c2 0301 	movt	r3, #8193	; 0x2001
 80022b8:	681b      	ldr	r3, [r3, #0]
 80022ba:	f103 32ff 	add.w	r2, r3, #4294967295	; 0xffffffff
 80022be:	f642 53a4 	movw	r3, #11684	; 0x2da4
 80022c2:	f2c2 0301 	movt	r3, #8193	; 0x2001
 80022c6:	601a      	str	r2, [r3, #0]
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
 80022c8:	f642 53a4 	movw	r3, #11684	; 0x2da4
 80022cc:	f2c2 0301 	movt	r3, #8193	; 0x2001
 80022d0:	681b      	ldr	r3, [r3, #0]
 80022d2:	2b00      	cmp	r3, #0
 80022d4:	d1ea      	bne.n	80022ac <xTaskResumeAll+0xf8>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
 80022d6:	f04f 0301 	mov.w	r3, #1
 80022da:	603b      	str	r3, [r7, #0]
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
 80022dc:	683b      	ldr	r3, [r7, #0]
 80022de:	2b01      	cmp	r3, #1
 80022e0:	d006      	beq.n	80022f0 <xTaskResumeAll+0x13c>
 80022e2:	f642 53a8 	movw	r3, #11688	; 0x2da8
 80022e6:	f2c2 0301 	movt	r3, #8193	; 0x2001
 80022ea:	681b      	ldr	r3, [r3, #0]
 80022ec:	2b01      	cmp	r3, #1
 80022ee:	d10b      	bne.n	8002308 <xTaskResumeAll+0x154>
				{
					xAlreadyYielded = pdTRUE;
 80022f0:	f04f 0301 	mov.w	r3, #1
 80022f4:	607b      	str	r3, [r7, #4]
					xMissedYield = pdFALSE;
 80022f6:	f642 53a8 	movw	r3, #11688	; 0x2da8
 80022fa:	f2c2 0301 	movt	r3, #8193	; 0x2001
 80022fe:	f04f 0200 	mov.w	r2, #0
 8002302:	601a      	str	r2, [r3, #0]
					portYIELD_WITHIN_API();
 8002304:	f7fe fc20 	bl	8000b48 <vPortYieldFromISR>
				}
			}
		}
	}
	taskEXIT_CRITICAL();
 8002308:	f7fe fc3c 	bl	8000b84 <vPortExitCritical>

	return xAlreadyYielded;
 800230c:	687b      	ldr	r3, [r7, #4]
}
 800230e:	4618      	mov	r0, r3
 8002310:	f107 070c 	add.w	r7, r7, #12
 8002314:	46bd      	mov	sp, r7
 8002316:	bd90      	pop	{r4, r7, pc}

08002318 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
 8002318:	b580      	push	{r7, lr}
 800231a:	b082      	sub	sp, #8
 800231c:	af00      	add	r7, sp, #0
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
 800231e:	f7fe fc1f 	bl	8000b60 <vPortEnterCritical>
	{
		xTicks = xTickCount;
 8002322:	f642 5390 	movw	r3, #11664	; 0x2d90
 8002326:	f2c2 0301 	movt	r3, #8193	; 0x2001
 800232a:	681b      	ldr	r3, [r3, #0]
 800232c:	607b      	str	r3, [r7, #4]
	}
	taskEXIT_CRITICAL();
 800232e:	f7fe fc29 	bl	8000b84 <vPortExitCritical>

	return xTicks;
 8002332:	687b      	ldr	r3, [r7, #4]
}
 8002334:	4618      	mov	r0, r3
 8002336:	f107 0708 	add.w	r7, r7, #8
 800233a:	46bd      	mov	sp, r7
 800233c:	bd80      	pop	{r7, pc}
 800233e:	bf00      	nop

08002340 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
 8002340:	b580      	push	{r7, lr}
 8002342:	b082      	sub	sp, #8
 8002344:	af00      	add	r7, sp, #0
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 8002346:	f7fe fc37 	bl	8000bb8 <ulPortSetInterruptMask>
 800234a:	6078      	str	r0, [r7, #4]
	xReturn = xTickCount;
 800234c:	f642 5390 	movw	r3, #11664	; 0x2d90
 8002350:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8002354:	681b      	ldr	r3, [r3, #0]
 8002356:	603b      	str	r3, [r7, #0]
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 8002358:	6878      	ldr	r0, [r7, #4]
 800235a:	f7fe fc37 	bl	8000bcc <vPortClearInterruptMask>

	return xReturn;
 800235e:	683b      	ldr	r3, [r7, #0]
}
 8002360:	4618      	mov	r0, r3
 8002362:	f107 0708 	add.w	r7, r7, #8
 8002366:	46bd      	mov	sp, r7
 8002368:	bd80      	pop	{r7, pc}
 800236a:	bf00      	nop

0800236c <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
 800236c:	b480      	push	{r7}
 800236e:	af00      	add	r7, sp, #0
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
 8002370:	f642 538c 	movw	r3, #11660	; 0x2d8c
 8002374:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8002378:	681b      	ldr	r3, [r3, #0]
}
 800237a:	4618      	mov	r0, r3
 800237c:	46bd      	mov	sp, r7
 800237e:	bc80      	pop	{r7}
 8002380:	4770      	bx	lr
 8002382:	bf00      	nop

08002384 <vTaskList>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	void vTaskList( signed char *pcWriteBuffer )
	{
 8002384:	b580      	push	{r7, lr}
 8002386:	b084      	sub	sp, #16
 8002388:	af00      	add	r7, sp, #0
 800238a:	6078      	str	r0, [r7, #4]
	unsigned portBASE_TYPE uxQueue;

		/* This is a VERY costly function that should be used for debug only.
		It leaves interrupts disabled for a LONG time. */

		vTaskSuspendAll();
 800238c:	f7ff ff00 	bl	8002190 <vTaskSuspendAll>
		{
			/* Run through all the lists that could potentially contain a TCB and
			report the task name, state and stack high water mark. */

			*pcWriteBuffer = ( signed char ) 0x00;
 8002390:	687b      	ldr	r3, [r7, #4]
 8002392:	f04f 0200 	mov.w	r2, #0
 8002396:	701a      	strb	r2, [r3, #0]
			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
 8002398:	6878      	ldr	r0, [r7, #4]
 800239a:	f244 21bc 	movw	r1, #17084	; 0x42bc
 800239e:	f6c0 0100 	movt	r1, #2048	; 0x800
 80023a2:	f001 fb93 	bl	8003acc <strcat>

			uxQueue = uxTopUsedPriority + ( unsigned portBASE_TYPE ) 1U;
 80023a6:	f642 5394 	movw	r3, #11668	; 0x2d94
 80023aa:	f2c2 0301 	movt	r3, #8193	; 0x2001
 80023ae:	681b      	ldr	r3, [r3, #0]
 80023b0:	f103 0301 	add.w	r3, r3, #1
 80023b4:	60fb      	str	r3, [r7, #12]

			do
			{
				uxQueue--;
 80023b6:	68fb      	ldr	r3, [r7, #12]
 80023b8:	f103 33ff 	add.w	r3, r3, #4294967295	; 0xffffffff
 80023bc:	60fb      	str	r3, [r7, #12]

				if( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) == pdFALSE )
 80023be:	f642 42b8 	movw	r2, #11448	; 0x2cb8
 80023c2:	f2c2 0201 	movt	r2, #8193	; 0x2001
 80023c6:	68f9      	ldr	r1, [r7, #12]
 80023c8:	460b      	mov	r3, r1
 80023ca:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80023ce:	185b      	adds	r3, r3, r1
 80023d0:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80023d4:	18d3      	adds	r3, r2, r3
 80023d6:	681b      	ldr	r3, [r3, #0]
 80023d8:	2b00      	cmp	r3, #0
 80023da:	d011      	beq.n	8002400 <vTaskList+0x7c>
				{
					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueue ] ), tskREADY_CHAR );
 80023dc:	68fa      	ldr	r2, [r7, #12]
 80023de:	4613      	mov	r3, r2
 80023e0:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80023e4:	189b      	adds	r3, r3, r2
 80023e6:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80023ea:	f642 42b8 	movw	r2, #11448	; 0x2cb8
 80023ee:	f2c2 0201 	movt	r2, #8193	; 0x2001
 80023f2:	189b      	adds	r3, r3, r2
 80023f4:	6878      	ldr	r0, [r7, #4]
 80023f6:	4619      	mov	r1, r3
 80023f8:	f04f 0252 	mov.w	r2, #82	; 0x52
 80023fc:	f000 fce0 	bl	8002dc0 <prvListTaskWithinSingleList>
				}
			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
 8002400:	68fb      	ldr	r3, [r7, #12]
 8002402:	2b00      	cmp	r3, #0
 8002404:	d1d7      	bne.n	80023b6 <vTaskList+0x32>

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) == pdFALSE )
 8002406:	f642 5344 	movw	r3, #11588	; 0x2d44
 800240a:	f2c2 0301 	movt	r3, #8193	; 0x2001
 800240e:	681b      	ldr	r3, [r3, #0]
 8002410:	681b      	ldr	r3, [r3, #0]
 8002412:	2b00      	cmp	r3, #0
 8002414:	d00a      	beq.n	800242c <vTaskList+0xa8>
			{
				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, tskBLOCKED_CHAR );
 8002416:	f642 5344 	movw	r3, #11588	; 0x2d44
 800241a:	f2c2 0301 	movt	r3, #8193	; 0x2001
 800241e:	681b      	ldr	r3, [r3, #0]
 8002420:	6878      	ldr	r0, [r7, #4]
 8002422:	4619      	mov	r1, r3
 8002424:	f04f 0242 	mov.w	r2, #66	; 0x42
 8002428:	f000 fcca 	bl	8002dc0 <prvListTaskWithinSingleList>
			}

			if( listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) == pdFALSE )
 800242c:	f642 5348 	movw	r3, #11592	; 0x2d48
 8002430:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8002434:	681b      	ldr	r3, [r3, #0]
 8002436:	681b      	ldr	r3, [r3, #0]
 8002438:	2b00      	cmp	r3, #0
 800243a:	d00a      	beq.n	8002452 <vTaskList+0xce>
			{
				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, tskBLOCKED_CHAR );
 800243c:	f642 5348 	movw	r3, #11592	; 0x2d48
 8002440:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8002444:	681b      	ldr	r3, [r3, #0]
 8002446:	6878      	ldr	r0, [r7, #4]
 8002448:	4619      	mov	r1, r3
 800244a:	f04f 0242 	mov.w	r2, #66	; 0x42
 800244e:	f000 fcb7 	bl	8002dc0 <prvListTaskWithinSingleList>
			}

			#if( INCLUDE_vTaskDelete == 1 )
			{
				if( listLIST_IS_EMPTY( &xTasksWaitingTermination ) == pdFALSE )
 8002452:	f642 5360 	movw	r3, #11616	; 0x2d60
 8002456:	f2c2 0301 	movt	r3, #8193	; 0x2001
 800245a:	681b      	ldr	r3, [r3, #0]
 800245c:	2b00      	cmp	r3, #0
 800245e:	d008      	beq.n	8002472 <vTaskList+0xee>
				{
					prvListTaskWithinSingleList( pcWriteBuffer, &xTasksWaitingTermination, tskDELETED_CHAR );
 8002460:	6878      	ldr	r0, [r7, #4]
 8002462:	f642 5160 	movw	r1, #11616	; 0x2d60
 8002466:	f2c2 0101 	movt	r1, #8193	; 0x2001
 800246a:	f04f 0244 	mov.w	r2, #68	; 0x44
 800246e:	f000 fca7 	bl	8002dc0 <prvListTaskWithinSingleList>
			}
			#endif

			#if ( INCLUDE_vTaskSuspend == 1 )
			{
				if( listLIST_IS_EMPTY( &xSuspendedTaskList ) == pdFALSE )
 8002472:	f642 5378 	movw	r3, #11640	; 0x2d78
 8002476:	f2c2 0301 	movt	r3, #8193	; 0x2001
 800247a:	681b      	ldr	r3, [r3, #0]
 800247c:	2b00      	cmp	r3, #0
 800247e:	d008      	beq.n	8002492 <vTaskList+0x10e>
				{
					prvListTaskWithinSingleList( pcWriteBuffer, &xSuspendedTaskList, tskSUSPENDED_CHAR );
 8002480:	6878      	ldr	r0, [r7, #4]
 8002482:	f642 5178 	movw	r1, #11640	; 0x2d78
 8002486:	f2c2 0101 	movt	r1, #8193	; 0x2001
 800248a:	f04f 0253 	mov.w	r2, #83	; 0x53
 800248e:	f000 fc97 	bl	8002dc0 <prvListTaskWithinSingleList>
				}
			}
			#endif
		}
		xTaskResumeAll();
 8002492:	f7ff fe8f 	bl	80021b4 <xTaskResumeAll>
	}
 8002496:	f107 0710 	add.w	r7, r7, #16
 800249a:	46bd      	mov	sp, r7
 800249c:	bd80      	pop	{r7, pc}
 800249e:	bf00      	nop

080024a0 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
 80024a0:	b580      	push	{r7, lr}
 80024a2:	b084      	sub	sp, #16
 80024a4:	af00      	add	r7, sp, #0

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 80024a6:	f642 53a0 	movw	r3, #11680	; 0x2da0
 80024aa:	f2c2 0301 	movt	r3, #8193	; 0x2001
 80024ae:	681b      	ldr	r3, [r3, #0]
 80024b0:	2b00      	cmp	r3, #0
 80024b2:	f040 80ca 	bne.w	800264a <vTaskIncrementTick+0x1aa>
	{
		++xTickCount;
 80024b6:	f642 5390 	movw	r3, #11664	; 0x2d90
 80024ba:	f2c2 0301 	movt	r3, #8193	; 0x2001
 80024be:	681b      	ldr	r3, [r3, #0]
 80024c0:	f103 0201 	add.w	r2, r3, #1
 80024c4:	f642 5390 	movw	r3, #11664	; 0x2d90
 80024c8:	f2c2 0301 	movt	r3, #8193	; 0x2001
 80024cc:	601a      	str	r2, [r3, #0]
		if( xTickCount == ( portTickType ) 0U )
 80024ce:	f642 5390 	movw	r3, #11664	; 0x2d90
 80024d2:	f2c2 0301 	movt	r3, #8193	; 0x2001
 80024d6:	681b      	ldr	r3, [r3, #0]
 80024d8:	2b00      	cmp	r3, #0
 80024da:	d14b      	bne.n	8002574 <vTaskIncrementTick+0xd4>
			xList *pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
 80024dc:	f642 5344 	movw	r3, #11588	; 0x2d44
 80024e0:	f2c2 0301 	movt	r3, #8193	; 0x2001
 80024e4:	681b      	ldr	r3, [r3, #0]
 80024e6:	681b      	ldr	r3, [r3, #0]
 80024e8:	2b00      	cmp	r3, #0
 80024ea:	d002      	beq.n	80024f2 <vTaskIncrementTick+0x52>
 80024ec:	f7fe fb64 	bl	8000bb8 <ulPortSetInterruptMask>
 80024f0:	e7fe      	b.n	80024f0 <vTaskIncrementTick+0x50>

			pxTemp = pxDelayedTaskList;
 80024f2:	f642 5344 	movw	r3, #11588	; 0x2d44
 80024f6:	f2c2 0301 	movt	r3, #8193	; 0x2001
 80024fa:	681b      	ldr	r3, [r3, #0]
 80024fc:	60fb      	str	r3, [r7, #12]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
 80024fe:	f642 5348 	movw	r3, #11592	; 0x2d48
 8002502:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8002506:	681a      	ldr	r2, [r3, #0]
 8002508:	f642 5344 	movw	r3, #11588	; 0x2d44
 800250c:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8002510:	601a      	str	r2, [r3, #0]
			pxOverflowDelayedTaskList = pxTemp;
 8002512:	f642 5348 	movw	r3, #11592	; 0x2d48
 8002516:	f2c2 0301 	movt	r3, #8193	; 0x2001
 800251a:	68fa      	ldr	r2, [r7, #12]
 800251c:	601a      	str	r2, [r3, #0]
			xNumOfOverflows++;
 800251e:	f642 53ac 	movw	r3, #11692	; 0x2dac
 8002522:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8002526:	681b      	ldr	r3, [r3, #0]
 8002528:	f103 0201 	add.w	r2, r3, #1
 800252c:	f642 53ac 	movw	r3, #11692	; 0x2dac
 8002530:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8002534:	601a      	str	r2, [r3, #0]

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8002536:	f642 5344 	movw	r3, #11588	; 0x2d44
 800253a:	f2c2 0301 	movt	r3, #8193	; 0x2001
 800253e:	681b      	ldr	r3, [r3, #0]
 8002540:	681b      	ldr	r3, [r3, #0]
 8002542:	2b00      	cmp	r3, #0
 8002544:	d107      	bne.n	8002556 <vTaskIncrementTick+0xb6>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
 8002546:	f240 031c 	movw	r3, #28
 800254a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800254e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8002552:	601a      	str	r2, [r3, #0]
 8002554:	e00e      	b.n	8002574 <vTaskIncrementTick+0xd4>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 8002556:	f642 5344 	movw	r3, #11588	; 0x2d44
 800255a:	f2c2 0301 	movt	r3, #8193	; 0x2001
 800255e:	681b      	ldr	r3, [r3, #0]
 8002560:	68db      	ldr	r3, [r3, #12]
 8002562:	68db      	ldr	r3, [r3, #12]
 8002564:	60bb      	str	r3, [r7, #8]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
 8002566:	68bb      	ldr	r3, [r7, #8]
 8002568:	685a      	ldr	r2, [r3, #4]
 800256a:	f240 031c 	movw	r3, #28
 800256e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002572:	601a      	str	r2, [r3, #0]
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
 8002574:	f642 5390 	movw	r3, #11664	; 0x2d90
 8002578:	f2c2 0301 	movt	r3, #8193	; 0x2001
 800257c:	681a      	ldr	r2, [r3, #0]
 800257e:	f240 031c 	movw	r3, #28
 8002582:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002586:	681b      	ldr	r3, [r3, #0]
 8002588:	429a      	cmp	r2, r3
 800258a:	d36c      	bcc.n	8002666 <vTaskIncrementTick+0x1c6>
 800258c:	f642 5344 	movw	r3, #11588	; 0x2d44
 8002590:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8002594:	681b      	ldr	r3, [r3, #0]
 8002596:	681b      	ldr	r3, [r3, #0]
 8002598:	2b00      	cmp	r3, #0
 800259a:	d107      	bne.n	80025ac <vTaskIncrementTick+0x10c>
 800259c:	f240 031c 	movw	r3, #28
 80025a0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80025a4:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 80025a8:	601a      	str	r2, [r3, #0]
 80025aa:	e05c      	b.n	8002666 <vTaskIncrementTick+0x1c6>
 80025ac:	f642 5344 	movw	r3, #11588	; 0x2d44
 80025b0:	f2c2 0301 	movt	r3, #8193	; 0x2001
 80025b4:	681b      	ldr	r3, [r3, #0]
 80025b6:	68db      	ldr	r3, [r3, #12]
 80025b8:	68db      	ldr	r3, [r3, #12]
 80025ba:	60bb      	str	r3, [r7, #8]
 80025bc:	68bb      	ldr	r3, [r7, #8]
 80025be:	685b      	ldr	r3, [r3, #4]
 80025c0:	607b      	str	r3, [r7, #4]
 80025c2:	f642 5390 	movw	r3, #11664	; 0x2d90
 80025c6:	f2c2 0301 	movt	r3, #8193	; 0x2001
 80025ca:	681a      	ldr	r2, [r3, #0]
 80025cc:	687b      	ldr	r3, [r7, #4]
 80025ce:	429a      	cmp	r2, r3
 80025d0:	d206      	bcs.n	80025e0 <vTaskIncrementTick+0x140>
 80025d2:	f240 031c 	movw	r3, #28
 80025d6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80025da:	687a      	ldr	r2, [r7, #4]
 80025dc:	601a      	str	r2, [r3, #0]
 80025de:	e042      	b.n	8002666 <vTaskIncrementTick+0x1c6>
 80025e0:	68bb      	ldr	r3, [r7, #8]
 80025e2:	f103 0304 	add.w	r3, r3, #4
 80025e6:	4618      	mov	r0, r3
 80025e8:	f7fd ffd6 	bl	8000598 <uxListRemove>
 80025ec:	68bb      	ldr	r3, [r7, #8]
 80025ee:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80025f0:	2b00      	cmp	r3, #0
 80025f2:	d005      	beq.n	8002600 <vTaskIncrementTick+0x160>
 80025f4:	68bb      	ldr	r3, [r7, #8]
 80025f6:	f103 0318 	add.w	r3, r3, #24
 80025fa:	4618      	mov	r0, r3
 80025fc:	f7fd ffcc 	bl	8000598 <uxListRemove>
 8002600:	68bb      	ldr	r3, [r7, #8]
 8002602:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8002604:	f642 5398 	movw	r3, #11672	; 0x2d98
 8002608:	f2c2 0301 	movt	r3, #8193	; 0x2001
 800260c:	681b      	ldr	r3, [r3, #0]
 800260e:	429a      	cmp	r2, r3
 8002610:	d906      	bls.n	8002620 <vTaskIncrementTick+0x180>
 8002612:	68bb      	ldr	r3, [r7, #8]
 8002614:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8002616:	f642 5398 	movw	r3, #11672	; 0x2d98
 800261a:	f2c2 0301 	movt	r3, #8193	; 0x2001
 800261e:	601a      	str	r2, [r3, #0]
 8002620:	68bb      	ldr	r3, [r7, #8]
 8002622:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8002624:	4613      	mov	r3, r2
 8002626:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800262a:	189b      	adds	r3, r3, r2
 800262c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002630:	f642 42b8 	movw	r2, #11448	; 0x2cb8
 8002634:	f2c2 0201 	movt	r2, #8193	; 0x2001
 8002638:	189a      	adds	r2, r3, r2
 800263a:	68bb      	ldr	r3, [r7, #8]
 800263c:	f103 0304 	add.w	r3, r3, #4
 8002640:	4610      	mov	r0, r2
 8002642:	4619      	mov	r1, r3
 8002644:	f7fd ff46 	bl	80004d4 <vListInsertEnd>
 8002648:	e7a0      	b.n	800258c <vTaskIncrementTick+0xec>
	}
	else
	{
		++uxMissedTicks;
 800264a:	f642 53a4 	movw	r3, #11684	; 0x2da4
 800264e:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8002652:	681b      	ldr	r3, [r3, #0]
 8002654:	f103 0201 	add.w	r2, r3, #1
 8002658:	f642 53a4 	movw	r3, #11684	; 0x2da4
 800265c:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8002660:	601a      	str	r2, [r3, #0]

		/* The tick hook gets called at regular intervals, even if the
		scheduler is locked. */
		#if ( configUSE_TICK_HOOK == 1 )
		{
			vApplicationTickHook();
 8002662:	f7fd fee3 	bl	800042c <vApplicationTickHook>

	#if ( configUSE_TICK_HOOK == 1 )
	{
		/* Guard against the tick hook being called when the missed tick
		count is being unwound (when the scheduler is being unlocked. */
		if( uxMissedTicks == ( unsigned portBASE_TYPE ) 0U )
 8002666:	f642 53a4 	movw	r3, #11684	; 0x2da4
 800266a:	f2c2 0301 	movt	r3, #8193	; 0x2001
 800266e:	681b      	ldr	r3, [r3, #0]
 8002670:	2b00      	cmp	r3, #0
 8002672:	d101      	bne.n	8002678 <vTaskIncrementTick+0x1d8>
		{
			vApplicationTickHook();
 8002674:	f7fd feda 	bl	800042c <vApplicationTickHook>
		}
	}
	#endif
}
 8002678:	f107 0710 	add.w	r7, r7, #16
 800267c:	46bd      	mov	sp, r7
 800267e:	bd80      	pop	{r7, pc}

08002680 <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
 8002680:	b580      	push	{r7, lr}
 8002682:	b082      	sub	sp, #8
 8002684:	af00      	add	r7, sp, #0
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
 8002686:	f642 53a0 	movw	r3, #11680	; 0x2da0
 800268a:	f2c2 0301 	movt	r3, #8193	; 0x2001
 800268e:	681b      	ldr	r3, [r3, #0]
 8002690:	2b00      	cmp	r3, #0
 8002692:	d007      	beq.n	80026a4 <vTaskSwitchContext+0x24>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
 8002694:	f642 53a8 	movw	r3, #11688	; 0x2da8
 8002698:	f2c2 0301 	movt	r3, #8193	; 0x2001
 800269c:	f04f 0201 	mov.w	r2, #1
 80026a0:	601a      	str	r2, [r3, #0]
 80026a2:	e093      	b.n	80027cc <vTaskSwitchContext+0x14c>
				pxCurrentTCB->ulRunTimeCounter += ( ulTempCounter - ulTaskSwitchedInTime );
				ulTaskSwitchedInTime = ulTempCounter;
		}
		#endif

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
 80026a4:	f642 43b4 	movw	r3, #11444	; 0x2cb4
 80026a8:	f2c2 0301 	movt	r3, #8193	; 0x2001
 80026ac:	681b      	ldr	r3, [r3, #0]
 80026ae:	681a      	ldr	r2, [r3, #0]
 80026b0:	f642 43b4 	movw	r3, #11444	; 0x2cb4
 80026b4:	f2c2 0301 	movt	r3, #8193	; 0x2001
 80026b8:	681b      	ldr	r3, [r3, #0]
 80026ba:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80026bc:	429a      	cmp	r2, r3
 80026be:	d80f      	bhi.n	80026e0 <vTaskSwitchContext+0x60>
 80026c0:	f642 43b4 	movw	r3, #11444	; 0x2cb4
 80026c4:	f2c2 0301 	movt	r3, #8193	; 0x2001
 80026c8:	681a      	ldr	r2, [r3, #0]
 80026ca:	f642 43b4 	movw	r3, #11444	; 0x2cb4
 80026ce:	f2c2 0301 	movt	r3, #8193	; 0x2001
 80026d2:	681b      	ldr	r3, [r3, #0]
 80026d4:	f103 0334 	add.w	r3, r3, #52	; 0x34
 80026d8:	4610      	mov	r0, r2
 80026da:	4619      	mov	r1, r3
 80026dc:	f7fd fec4 	bl	8000468 <vApplicationStackOverflowHook>
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
 80026e0:	f642 43b4 	movw	r3, #11444	; 0x2cb4
 80026e4:	f2c2 0301 	movt	r3, #8193	; 0x2001
 80026e8:	681b      	ldr	r3, [r3, #0]
 80026ea:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80026ec:	4618      	mov	r0, r3
 80026ee:	f244 21d4 	movw	r1, #17108	; 0x42d4
 80026f2:	f6c0 0100 	movt	r1, #2048	; 0x800
 80026f6:	f04f 0214 	mov.w	r2, #20
 80026fa:	f001 f9a3 	bl	8003a44 <memcmp>
 80026fe:	4603      	mov	r3, r0
 8002700:	2b00      	cmp	r3, #0
 8002702:	d026      	beq.n	8002752 <vTaskSwitchContext+0xd2>
 8002704:	f642 43b4 	movw	r3, #11444	; 0x2cb4
 8002708:	f2c2 0301 	movt	r3, #8193	; 0x2001
 800270c:	681a      	ldr	r2, [r3, #0]
 800270e:	f642 43b4 	movw	r3, #11444	; 0x2cb4
 8002712:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8002716:	681b      	ldr	r3, [r3, #0]
 8002718:	f103 0334 	add.w	r3, r3, #52	; 0x34
 800271c:	4610      	mov	r0, r2
 800271e:	4619      	mov	r1, r3
 8002720:	f7fd fea2 	bl	8000468 <vApplicationStackOverflowHook>

		taskSELECT_HIGHEST_PRIORITY_TASK();
 8002724:	e015      	b.n	8002752 <vTaskSwitchContext+0xd2>
 8002726:	f642 5398 	movw	r3, #11672	; 0x2d98
 800272a:	f2c2 0301 	movt	r3, #8193	; 0x2001
 800272e:	681b      	ldr	r3, [r3, #0]
 8002730:	2b00      	cmp	r3, #0
 8002732:	d102      	bne.n	800273a <vTaskSwitchContext+0xba>
 8002734:	f7fe fa40 	bl	8000bb8 <ulPortSetInterruptMask>
 8002738:	e7fe      	b.n	8002738 <vTaskSwitchContext+0xb8>
 800273a:	f642 5398 	movw	r3, #11672	; 0x2d98
 800273e:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8002742:	681b      	ldr	r3, [r3, #0]
 8002744:	f103 32ff 	add.w	r2, r3, #4294967295	; 0xffffffff
 8002748:	f642 5398 	movw	r3, #11672	; 0x2d98
 800274c:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8002750:	601a      	str	r2, [r3, #0]
 8002752:	f642 5398 	movw	r3, #11672	; 0x2d98
 8002756:	f2c2 0301 	movt	r3, #8193	; 0x2001
 800275a:	6819      	ldr	r1, [r3, #0]
 800275c:	f642 42b8 	movw	r2, #11448	; 0x2cb8
 8002760:	f2c2 0201 	movt	r2, #8193	; 0x2001
 8002764:	460b      	mov	r3, r1
 8002766:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800276a:	185b      	adds	r3, r3, r1
 800276c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002770:	18d3      	adds	r3, r2, r3
 8002772:	681b      	ldr	r3, [r3, #0]
 8002774:	2b00      	cmp	r3, #0
 8002776:	d0d6      	beq.n	8002726 <vTaskSwitchContext+0xa6>
 8002778:	f642 5398 	movw	r3, #11672	; 0x2d98
 800277c:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8002780:	681a      	ldr	r2, [r3, #0]
 8002782:	4613      	mov	r3, r2
 8002784:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002788:	189b      	adds	r3, r3, r2
 800278a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800278e:	f642 42b8 	movw	r2, #11448	; 0x2cb8
 8002792:	f2c2 0201 	movt	r2, #8193	; 0x2001
 8002796:	189b      	adds	r3, r3, r2
 8002798:	607b      	str	r3, [r7, #4]
 800279a:	687b      	ldr	r3, [r7, #4]
 800279c:	685b      	ldr	r3, [r3, #4]
 800279e:	685a      	ldr	r2, [r3, #4]
 80027a0:	687b      	ldr	r3, [r7, #4]
 80027a2:	605a      	str	r2, [r3, #4]
 80027a4:	687b      	ldr	r3, [r7, #4]
 80027a6:	685a      	ldr	r2, [r3, #4]
 80027a8:	687b      	ldr	r3, [r7, #4]
 80027aa:	f103 0308 	add.w	r3, r3, #8
 80027ae:	429a      	cmp	r2, r3
 80027b0:	d104      	bne.n	80027bc <vTaskSwitchContext+0x13c>
 80027b2:	687b      	ldr	r3, [r7, #4]
 80027b4:	685b      	ldr	r3, [r3, #4]
 80027b6:	685a      	ldr	r2, [r3, #4]
 80027b8:	687b      	ldr	r3, [r7, #4]
 80027ba:	605a      	str	r2, [r3, #4]
 80027bc:	687b      	ldr	r3, [r7, #4]
 80027be:	685b      	ldr	r3, [r3, #4]
 80027c0:	68da      	ldr	r2, [r3, #12]
 80027c2:	f642 43b4 	movw	r3, #11444	; 0x2cb4
 80027c6:	f2c2 0301 	movt	r3, #8193	; 0x2001
 80027ca:	601a      	str	r2, [r3, #0]

		traceTASK_SWITCHED_IN();
	}
}
 80027cc:	f107 0708 	add.w	r7, r7, #8
 80027d0:	46bd      	mov	sp, r7
 80027d2:	bd80      	pop	{r7, pc}

080027d4 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
 80027d4:	b580      	push	{r7, lr}
 80027d6:	b084      	sub	sp, #16
 80027d8:	af00      	add	r7, sp, #0
 80027da:	6078      	str	r0, [r7, #4]
 80027dc:	6039      	str	r1, [r7, #0]
portTickType xTimeToWake;

	configASSERT( pxEventList );
 80027de:	687b      	ldr	r3, [r7, #4]
 80027e0:	2b00      	cmp	r3, #0
 80027e2:	d102      	bne.n	80027ea <vTaskPlaceOnEventList+0x16>
 80027e4:	f7fe f9e8 	bl	8000bb8 <ulPortSetInterruptMask>
 80027e8:	e7fe      	b.n	80027e8 <vTaskPlaceOnEventList+0x14>
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
 80027ea:	f642 43b4 	movw	r3, #11444	; 0x2cb4
 80027ee:	f2c2 0301 	movt	r3, #8193	; 0x2001
 80027f2:	681b      	ldr	r3, [r3, #0]
 80027f4:	f103 0318 	add.w	r3, r3, #24
 80027f8:	6878      	ldr	r0, [r7, #4]
 80027fa:	4619      	mov	r1, r3
 80027fc:	f7fd fe92 	bl	8000524 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
 8002800:	f642 43b4 	movw	r3, #11444	; 0x2cb4
 8002804:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8002808:	681b      	ldr	r3, [r3, #0]
 800280a:	f103 0304 	add.w	r3, r3, #4
 800280e:	4618      	mov	r0, r3
 8002810:	f7fd fec2 	bl	8000598 <uxListRemove>
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
 8002814:	683b      	ldr	r3, [r7, #0]
 8002816:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 800281a:	d10e      	bne.n	800283a <vTaskPlaceOnEventList+0x66>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 800281c:	f642 43b4 	movw	r3, #11444	; 0x2cb4
 8002820:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8002824:	681b      	ldr	r3, [r3, #0]
 8002826:	f103 0304 	add.w	r3, r3, #4
 800282a:	f642 5078 	movw	r0, #11640	; 0x2d78
 800282e:	f2c2 0001 	movt	r0, #8193	; 0x2001
 8002832:	4619      	mov	r1, r3
 8002834:	f7fd fe4e 	bl	80004d4 <vListInsertEnd>
 8002838:	e00a      	b.n	8002850 <vTaskPlaceOnEventList+0x7c>
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
 800283a:	f642 5390 	movw	r3, #11664	; 0x2d90
 800283e:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8002842:	681a      	ldr	r2, [r3, #0]
 8002844:	683b      	ldr	r3, [r7, #0]
 8002846:	18d3      	adds	r3, r2, r3
 8002848:	60fb      	str	r3, [r7, #12]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
 800284a:	68f8      	ldr	r0, [r7, #12]
 800284c:	f000 fa3a 	bl	8002cc4 <prvAddCurrentTaskToDelayedList>
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif
}
 8002850:	f107 0710 	add.w	r7, r7, #16
 8002854:	46bd      	mov	sp, r7
 8002856:	bd80      	pop	{r7, pc}

08002858 <vTaskPlaceOnEventListRestricted>:
/*-----------------------------------------------------------*/

#if configUSE_TIMERS == 1

	void vTaskPlaceOnEventListRestricted( const xList * const pxEventList, portTickType xTicksToWait )
	{
 8002858:	b580      	push	{r7, lr}
 800285a:	b084      	sub	sp, #16
 800285c:	af00      	add	r7, sp, #0
 800285e:	6078      	str	r0, [r7, #4]
 8002860:	6039      	str	r1, [r7, #0]
	portTickType xTimeToWake;

		configASSERT( pxEventList );
 8002862:	687b      	ldr	r3, [r7, #4]
 8002864:	2b00      	cmp	r3, #0
 8002866:	d102      	bne.n	800286e <vTaskPlaceOnEventListRestricted+0x16>
 8002868:	f7fe f9a6 	bl	8000bb8 <ulPortSetInterruptMask>
 800286c:	e7fe      	b.n	800286c <vTaskPlaceOnEventListRestricted+0x14>

		/* Place the event list item of the TCB in the appropriate event list.
		In this case it is assume that this is the only task that is going to
		be waiting on this event list, so the faster vListInsertEnd() function
		can be used in place of vListInsert. */
		vListInsertEnd( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
 800286e:	f642 43b4 	movw	r3, #11444	; 0x2cb4
 8002872:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8002876:	681b      	ldr	r3, [r3, #0]
 8002878:	f103 0318 	add.w	r3, r3, #24
 800287c:	6878      	ldr	r0, [r7, #4]
 800287e:	4619      	mov	r1, r3
 8002880:	f7fd fe28 	bl	80004d4 <vListInsertEnd>

		/* We must remove this task from the ready list before adding it to the
		blocked list as the same list item is used for both lists.  This
		function is called form a critical section. */
		if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
 8002884:	f642 43b4 	movw	r3, #11444	; 0x2cb4
 8002888:	f2c2 0301 	movt	r3, #8193	; 0x2001
 800288c:	681b      	ldr	r3, [r3, #0]
 800288e:	f103 0304 	add.w	r3, r3, #4
 8002892:	4618      	mov	r0, r3
 8002894:	f7fd fe80 	bl	8000598 <uxListRemove>
			portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
		}

		/* Calculate the time at which the task should be woken if the event does
		not occur.  This may overflow but this doesn't matter. */
		xTimeToWake = xTickCount + xTicksToWait;
 8002898:	f642 5390 	movw	r3, #11664	; 0x2d90
 800289c:	f2c2 0301 	movt	r3, #8193	; 0x2001
 80028a0:	681a      	ldr	r2, [r3, #0]
 80028a2:	683b      	ldr	r3, [r7, #0]
 80028a4:	18d3      	adds	r3, r2, r3
 80028a6:	60fb      	str	r3, [r7, #12]
		
		traceTASK_DELAY_UNTIL();
		prvAddCurrentTaskToDelayedList( xTimeToWake );
 80028a8:	68f8      	ldr	r0, [r7, #12]
 80028aa:	f000 fa0b 	bl	8002cc4 <prvAddCurrentTaskToDelayedList>
	}
 80028ae:	f107 0710 	add.w	r7, r7, #16
 80028b2:	46bd      	mov	sp, r7
 80028b4:	bd80      	pop	{r7, pc}
 80028b6:	bf00      	nop

080028b8 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
 80028b8:	b580      	push	{r7, lr}
 80028ba:	b084      	sub	sp, #16
 80028bc:	af00      	add	r7, sp, #0
 80028be:	6078      	str	r0, [r7, #4]
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 80028c0:	687b      	ldr	r3, [r7, #4]
 80028c2:	68db      	ldr	r3, [r3, #12]
 80028c4:	68db      	ldr	r3, [r3, #12]
 80028c6:	60bb      	str	r3, [r7, #8]
	configASSERT( pxUnblockedTCB );
 80028c8:	68bb      	ldr	r3, [r7, #8]
 80028ca:	2b00      	cmp	r3, #0
 80028cc:	d102      	bne.n	80028d4 <xTaskRemoveFromEventList+0x1c>
 80028ce:	f7fe f973 	bl	8000bb8 <ulPortSetInterruptMask>
 80028d2:	e7fe      	b.n	80028d2 <xTaskRemoveFromEventList+0x1a>
	uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 80028d4:	68bb      	ldr	r3, [r7, #8]
 80028d6:	f103 0318 	add.w	r3, r3, #24
 80028da:	4618      	mov	r0, r3
 80028dc:	f7fd fe5c 	bl	8000598 <uxListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 80028e0:	f642 53a0 	movw	r3, #11680	; 0x2da0
 80028e4:	f2c2 0301 	movt	r3, #8193	; 0x2001
 80028e8:	681b      	ldr	r3, [r3, #0]
 80028ea:	2b00      	cmp	r3, #0
 80028ec:	d12a      	bne.n	8002944 <xTaskRemoveFromEventList+0x8c>
	{
		uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
 80028ee:	68bb      	ldr	r3, [r7, #8]
 80028f0:	f103 0304 	add.w	r3, r3, #4
 80028f4:	4618      	mov	r0, r3
 80028f6:	f7fd fe4f 	bl	8000598 <uxListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
 80028fa:	68bb      	ldr	r3, [r7, #8]
 80028fc:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80028fe:	f642 5398 	movw	r3, #11672	; 0x2d98
 8002902:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8002906:	681b      	ldr	r3, [r3, #0]
 8002908:	429a      	cmp	r2, r3
 800290a:	d906      	bls.n	800291a <xTaskRemoveFromEventList+0x62>
 800290c:	68bb      	ldr	r3, [r7, #8]
 800290e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8002910:	f642 5398 	movw	r3, #11672	; 0x2d98
 8002914:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8002918:	601a      	str	r2, [r3, #0]
 800291a:	68bb      	ldr	r3, [r7, #8]
 800291c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800291e:	4613      	mov	r3, r2
 8002920:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002924:	189b      	adds	r3, r3, r2
 8002926:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800292a:	f642 42b8 	movw	r2, #11448	; 0x2cb8
 800292e:	f2c2 0201 	movt	r2, #8193	; 0x2001
 8002932:	189a      	adds	r2, r3, r2
 8002934:	68bb      	ldr	r3, [r7, #8]
 8002936:	f103 0304 	add.w	r3, r3, #4
 800293a:	4610      	mov	r0, r2
 800293c:	4619      	mov	r1, r3
 800293e:	f7fd fdc9 	bl	80004d4 <vListInsertEnd>
 8002942:	e009      	b.n	8002958 <xTaskRemoveFromEventList+0xa0>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 8002944:	68bb      	ldr	r3, [r7, #8]
 8002946:	f103 0318 	add.w	r3, r3, #24
 800294a:	f642 504c 	movw	r0, #11596	; 0x2d4c
 800294e:	f2c2 0001 	movt	r0, #8193	; 0x2001
 8002952:	4619      	mov	r1, r3
 8002954:	f7fd fdbe 	bl	80004d4 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8002958:	68bb      	ldr	r3, [r7, #8]
 800295a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800295c:	f642 43b4 	movw	r3, #11444	; 0x2cb4
 8002960:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8002964:	681b      	ldr	r3, [r3, #0]
 8002966:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8002968:	429a      	cmp	r2, r3
 800296a:	d303      	bcc.n	8002974 <xTaskRemoveFromEventList+0xbc>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
 800296c:	f04f 0301 	mov.w	r3, #1
 8002970:	60fb      	str	r3, [r7, #12]
 8002972:	e002      	b.n	800297a <xTaskRemoveFromEventList+0xc2>
	}
	else
	{
		xReturn = pdFALSE;
 8002974:	f04f 0300 	mov.w	r3, #0
 8002978:	60fb      	str	r3, [r7, #12]
	}

	return xReturn;
 800297a:	68fb      	ldr	r3, [r7, #12]
}
 800297c:	4618      	mov	r0, r3
 800297e:	f107 0710 	add.w	r7, r7, #16
 8002982:	46bd      	mov	sp, r7
 8002984:	bd80      	pop	{r7, pc}
 8002986:	bf00      	nop

08002988 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
 8002988:	b580      	push	{r7, lr}
 800298a:	b082      	sub	sp, #8
 800298c:	af00      	add	r7, sp, #0
 800298e:	6078      	str	r0, [r7, #4]
	configASSERT( pxTimeOut );
 8002990:	687b      	ldr	r3, [r7, #4]
 8002992:	2b00      	cmp	r3, #0
 8002994:	d102      	bne.n	800299c <vTaskSetTimeOutState+0x14>
 8002996:	f7fe f90f 	bl	8000bb8 <ulPortSetInterruptMask>
 800299a:	e7fe      	b.n	800299a <vTaskSetTimeOutState+0x12>
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 800299c:	f642 53ac 	movw	r3, #11692	; 0x2dac
 80029a0:	f2c2 0301 	movt	r3, #8193	; 0x2001
 80029a4:	681a      	ldr	r2, [r3, #0]
 80029a6:	687b      	ldr	r3, [r7, #4]
 80029a8:	601a      	str	r2, [r3, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
 80029aa:	f642 5390 	movw	r3, #11664	; 0x2d90
 80029ae:	f2c2 0301 	movt	r3, #8193	; 0x2001
 80029b2:	681a      	ldr	r2, [r3, #0]
 80029b4:	687b      	ldr	r3, [r7, #4]
 80029b6:	605a      	str	r2, [r3, #4]
}
 80029b8:	f107 0708 	add.w	r7, r7, #8
 80029bc:	46bd      	mov	sp, r7
 80029be:	bd80      	pop	{r7, pc}

080029c0 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
 80029c0:	b580      	push	{r7, lr}
 80029c2:	b084      	sub	sp, #16
 80029c4:	af00      	add	r7, sp, #0
 80029c6:	6078      	str	r0, [r7, #4]
 80029c8:	6039      	str	r1, [r7, #0]
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
 80029ca:	687b      	ldr	r3, [r7, #4]
 80029cc:	2b00      	cmp	r3, #0
 80029ce:	d102      	bne.n	80029d6 <xTaskCheckForTimeOut+0x16>
 80029d0:	f7fe f8f2 	bl	8000bb8 <ulPortSetInterruptMask>
 80029d4:	e7fe      	b.n	80029d4 <xTaskCheckForTimeOut+0x14>
	configASSERT( pxTicksToWait );
 80029d6:	683b      	ldr	r3, [r7, #0]
 80029d8:	2b00      	cmp	r3, #0
 80029da:	d102      	bne.n	80029e2 <xTaskCheckForTimeOut+0x22>
 80029dc:	f7fe f8ec 	bl	8000bb8 <ulPortSetInterruptMask>
 80029e0:	e7fe      	b.n	80029e0 <xTaskCheckForTimeOut+0x20>

	taskENTER_CRITICAL();
 80029e2:	f7fe f8bd 	bl	8000b60 <vPortEnterCritical>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
 80029e6:	683b      	ldr	r3, [r7, #0]
 80029e8:	681b      	ldr	r3, [r3, #0]
 80029ea:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 80029ee:	d103      	bne.n	80029f8 <xTaskCheckForTimeOut+0x38>
			{
				xReturn = pdFALSE;
 80029f0:	f04f 0300 	mov.w	r3, #0
 80029f4:	60fb      	str	r3, [r7, #12]
 80029f6:	e038      	b.n	8002a6a <xTaskCheckForTimeOut+0xaa>
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
 80029f8:	687b      	ldr	r3, [r7, #4]
 80029fa:	681a      	ldr	r2, [r3, #0]
 80029fc:	f642 53ac 	movw	r3, #11692	; 0x2dac
 8002a00:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8002a04:	681b      	ldr	r3, [r3, #0]
 8002a06:	429a      	cmp	r2, r3
 8002a08:	d00c      	beq.n	8002a24 <xTaskCheckForTimeOut+0x64>
 8002a0a:	687b      	ldr	r3, [r7, #4]
 8002a0c:	685a      	ldr	r2, [r3, #4]
 8002a0e:	f642 5390 	movw	r3, #11664	; 0x2d90
 8002a12:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8002a16:	681b      	ldr	r3, [r3, #0]
 8002a18:	429a      	cmp	r2, r3
 8002a1a:	d803      	bhi.n	8002a24 <xTaskCheckForTimeOut+0x64>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
 8002a1c:	f04f 0301 	mov.w	r3, #1
 8002a20:	60fb      	str	r3, [r7, #12]
 8002a22:	e022      	b.n	8002a6a <xTaskCheckForTimeOut+0xaa>
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
 8002a24:	f642 5390 	movw	r3, #11664	; 0x2d90
 8002a28:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8002a2c:	681a      	ldr	r2, [r3, #0]
 8002a2e:	687b      	ldr	r3, [r7, #4]
 8002a30:	685b      	ldr	r3, [r3, #4]
 8002a32:	1ad2      	subs	r2, r2, r3
 8002a34:	683b      	ldr	r3, [r7, #0]
 8002a36:	681b      	ldr	r3, [r3, #0]
 8002a38:	429a      	cmp	r2, r3
 8002a3a:	d213      	bcs.n	8002a64 <xTaskCheckForTimeOut+0xa4>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
 8002a3c:	683b      	ldr	r3, [r7, #0]
 8002a3e:	681a      	ldr	r2, [r3, #0]
 8002a40:	687b      	ldr	r3, [r7, #4]
 8002a42:	6859      	ldr	r1, [r3, #4]
 8002a44:	f642 5390 	movw	r3, #11664	; 0x2d90
 8002a48:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8002a4c:	681b      	ldr	r3, [r3, #0]
 8002a4e:	1acb      	subs	r3, r1, r3
 8002a50:	18d2      	adds	r2, r2, r3
 8002a52:	683b      	ldr	r3, [r7, #0]
 8002a54:	601a      	str	r2, [r3, #0]
			vTaskSetTimeOutState( pxTimeOut );
 8002a56:	6878      	ldr	r0, [r7, #4]
 8002a58:	f7ff ff96 	bl	8002988 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
 8002a5c:	f04f 0300 	mov.w	r3, #0
 8002a60:	60fb      	str	r3, [r7, #12]
 8002a62:	e002      	b.n	8002a6a <xTaskCheckForTimeOut+0xaa>
		}
		else
		{
			xReturn = pdTRUE;
 8002a64:	f04f 0301 	mov.w	r3, #1
 8002a68:	60fb      	str	r3, [r7, #12]
		}
	}
	taskEXIT_CRITICAL();
 8002a6a:	f7fe f88b 	bl	8000b84 <vPortExitCritical>

	return xReturn;
 8002a6e:	68fb      	ldr	r3, [r7, #12]
}
 8002a70:	4618      	mov	r0, r3
 8002a72:	f107 0710 	add.w	r7, r7, #16
 8002a76:	46bd      	mov	sp, r7
 8002a78:	bd80      	pop	{r7, pc}
 8002a7a:	bf00      	nop

08002a7c <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
 8002a7c:	b480      	push	{r7}
 8002a7e:	af00      	add	r7, sp, #0
	xMissedYield = pdTRUE;
 8002a80:	f642 53a8 	movw	r3, #11688	; 0x2da8
 8002a84:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8002a88:	f04f 0201 	mov.w	r2, #1
 8002a8c:	601a      	str	r2, [r3, #0]
}
 8002a8e:	46bd      	mov	sp, r7
 8002a90:	bc80      	pop	{r7}
 8002a92:	4770      	bx	lr

08002a94 <uxTaskGetTaskNumber>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )
	unsigned portBASE_TYPE uxTaskGetTaskNumber( xTaskHandle xTask )
	{
 8002a94:	b480      	push	{r7}
 8002a96:	b085      	sub	sp, #20
 8002a98:	af00      	add	r7, sp, #0
 8002a9a:	6078      	str	r0, [r7, #4]
	unsigned portBASE_TYPE uxReturn;
	tskTCB *pxTCB;

		if( xTask != NULL )
 8002a9c:	687b      	ldr	r3, [r7, #4]
 8002a9e:	2b00      	cmp	r3, #0
 8002aa0:	d005      	beq.n	8002aae <uxTaskGetTaskNumber+0x1a>
		{
			pxTCB = ( tskTCB * ) xTask;
 8002aa2:	687b      	ldr	r3, [r7, #4]
 8002aa4:	60bb      	str	r3, [r7, #8]
			uxReturn = pxTCB->uxTaskNumber;
 8002aa6:	68bb      	ldr	r3, [r7, #8]
 8002aa8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8002aaa:	60fb      	str	r3, [r7, #12]
 8002aac:	e002      	b.n	8002ab4 <uxTaskGetTaskNumber+0x20>
		}
		else
		{
			uxReturn = 0U;
 8002aae:	f04f 0300 	mov.w	r3, #0
 8002ab2:	60fb      	str	r3, [r7, #12]
		}

		return uxReturn;
 8002ab4:	68fb      	ldr	r3, [r7, #12]
	}
 8002ab6:	4618      	mov	r0, r3
 8002ab8:	f107 0714 	add.w	r7, r7, #20
 8002abc:	46bd      	mov	sp, r7
 8002abe:	bc80      	pop	{r7}
 8002ac0:	4770      	bx	lr
 8002ac2:	bf00      	nop

08002ac4 <vTaskSetTaskNumber>:
#endif
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )
	void vTaskSetTaskNumber( xTaskHandle xTask, unsigned portBASE_TYPE uxHandle )
	{
 8002ac4:	b480      	push	{r7}
 8002ac6:	b085      	sub	sp, #20
 8002ac8:	af00      	add	r7, sp, #0
 8002aca:	6078      	str	r0, [r7, #4]
 8002acc:	6039      	str	r1, [r7, #0]
	tskTCB *pxTCB;

		if( xTask != NULL )
 8002ace:	687b      	ldr	r3, [r7, #4]
 8002ad0:	2b00      	cmp	r3, #0
 8002ad2:	d004      	beq.n	8002ade <vTaskSetTaskNumber+0x1a>
		{
			pxTCB = ( tskTCB * ) xTask;
 8002ad4:	687b      	ldr	r3, [r7, #4]
 8002ad6:	60fb      	str	r3, [r7, #12]
			pxTCB->uxTaskNumber = uxHandle;
 8002ad8:	68fb      	ldr	r3, [r7, #12]
 8002ada:	683a      	ldr	r2, [r7, #0]
 8002adc:	645a      	str	r2, [r3, #68]	; 0x44
		}
	}
 8002ade:	f107 0714 	add.w	r7, r7, #20
 8002ae2:	46bd      	mov	sp, r7
 8002ae4:	bc80      	pop	{r7}
 8002ae6:	4770      	bx	lr

08002ae8 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
 8002ae8:	b580      	push	{r7, lr}
 8002aea:	b082      	sub	sp, #8
 8002aec:	af00      	add	r7, sp, #0
 8002aee:	6078      	str	r0, [r7, #4]
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
 8002af0:	f000 f89a 	bl	8002c28 <prvCheckTasksWaitingTermination>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
 8002af4:	f642 43b8 	movw	r3, #11448	; 0x2cb8
 8002af8:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8002afc:	681b      	ldr	r3, [r3, #0]
 8002afe:	2b01      	cmp	r3, #1
 8002b00:	d901      	bls.n	8002b06 <prvIdleTask+0x1e>
			{
				taskYIELD();
 8002b02:	f7fe f821 	bl	8000b48 <vPortYieldFromISR>
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
 8002b06:	f7fd fc9d 	bl	8000444 <vApplicationIdleHook>
				}
				xTaskResumeAll();
			}
		}
		#endif
	}
 8002b0a:	e7f1      	b.n	8002af0 <prvIdleTask+0x8>

08002b0c <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
 8002b0c:	b580      	push	{r7, lr}
 8002b0e:	b084      	sub	sp, #16
 8002b10:	af00      	add	r7, sp, #0
 8002b12:	60f8      	str	r0, [r7, #12]
 8002b14:	60b9      	str	r1, [r7, #8]
 8002b16:	607a      	str	r2, [r7, #4]
 8002b18:	603b      	str	r3, [r7, #0]
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
 8002b1a:	68fb      	ldr	r3, [r7, #12]
 8002b1c:	f103 0334 	add.w	r3, r3, #52	; 0x34
 8002b20:	4618      	mov	r0, r3
 8002b22:	68b9      	ldr	r1, [r7, #8]
 8002b24:	f04f 020a 	mov.w	r2, #10
 8002b28:	f000 ffdd 	bl	8003ae6 <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
 8002b2c:	68fb      	ldr	r3, [r7, #12]
 8002b2e:	f04f 0200 	mov.w	r2, #0
 8002b32:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
 8002b36:	687b      	ldr	r3, [r7, #4]
 8002b38:	2b04      	cmp	r3, #4
 8002b3a:	d902      	bls.n	8002b42 <prvInitialiseTCBVariables+0x36>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
 8002b3c:	f04f 0304 	mov.w	r3, #4
 8002b40:	607b      	str	r3, [r7, #4]
	}

	pxTCB->uxPriority = uxPriority;
 8002b42:	68fb      	ldr	r3, [r7, #12]
 8002b44:	687a      	ldr	r2, [r7, #4]
 8002b46:	62da      	str	r2, [r3, #44]	; 0x2c
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
 8002b48:	68fb      	ldr	r3, [r7, #12]
 8002b4a:	687a      	ldr	r2, [r7, #4]
 8002b4c:	649a      	str	r2, [r3, #72]	; 0x48
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 8002b4e:	68fb      	ldr	r3, [r7, #12]
 8002b50:	f103 0304 	add.w	r3, r3, #4
 8002b54:	4618      	mov	r0, r3
 8002b56:	f7fd fcaf 	bl	80004b8 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
 8002b5a:	68fb      	ldr	r3, [r7, #12]
 8002b5c:	f103 0318 	add.w	r3, r3, #24
 8002b60:	4618      	mov	r0, r3
 8002b62:	f7fd fca9 	bl	80004b8 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
 8002b66:	68fb      	ldr	r3, [r7, #12]
 8002b68:	68fa      	ldr	r2, [r7, #12]
 8002b6a:	611a      	str	r2, [r3, #16]

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
 8002b6c:	687b      	ldr	r3, [r7, #4]
 8002b6e:	f1c3 0205 	rsb	r2, r3, #5
 8002b72:	68fb      	ldr	r3, [r7, #12]
 8002b74:	619a      	str	r2, [r3, #24]
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
 8002b76:	68fb      	ldr	r3, [r7, #12]
 8002b78:	68fa      	ldr	r2, [r7, #12]
 8002b7a:	625a      	str	r2, [r3, #36]	; 0x24
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
 8002b7c:	f107 0710 	add.w	r7, r7, #16
 8002b80:	46bd      	mov	sp, r7
 8002b82:	bd80      	pop	{r7, pc}

08002b84 <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
 8002b84:	b580      	push	{r7, lr}
 8002b86:	b082      	sub	sp, #8
 8002b88:	af00      	add	r7, sp, #0
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
 8002b8a:	f04f 0300 	mov.w	r3, #0
 8002b8e:	607b      	str	r3, [r7, #4]
 8002b90:	e012      	b.n	8002bb8 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
 8002b92:	687a      	ldr	r2, [r7, #4]
 8002b94:	4613      	mov	r3, r2
 8002b96:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002b9a:	189b      	adds	r3, r3, r2
 8002b9c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002ba0:	f642 42b8 	movw	r2, #11448	; 0x2cb8
 8002ba4:	f2c2 0201 	movt	r2, #8193	; 0x2001
 8002ba8:	189b      	adds	r3, r3, r2
 8002baa:	4618      	mov	r0, r3
 8002bac:	f7fd fc64 	bl	8000478 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
 8002bb0:	687b      	ldr	r3, [r7, #4]
 8002bb2:	f103 0301 	add.w	r3, r3, #1
 8002bb6:	607b      	str	r3, [r7, #4]
 8002bb8:	687b      	ldr	r3, [r7, #4]
 8002bba:	2b04      	cmp	r3, #4
 8002bbc:	d9e9      	bls.n	8002b92 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
 8002bbe:	f642 501c 	movw	r0, #11548	; 0x2d1c
 8002bc2:	f2c2 0001 	movt	r0, #8193	; 0x2001
 8002bc6:	f7fd fc57 	bl	8000478 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
 8002bca:	f642 5030 	movw	r0, #11568	; 0x2d30
 8002bce:	f2c2 0001 	movt	r0, #8193	; 0x2001
 8002bd2:	f7fd fc51 	bl	8000478 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
 8002bd6:	f642 504c 	movw	r0, #11596	; 0x2d4c
 8002bda:	f2c2 0001 	movt	r0, #8193	; 0x2001
 8002bde:	f7fd fc4b 	bl	8000478 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
 8002be2:	f642 5060 	movw	r0, #11616	; 0x2d60
 8002be6:	f2c2 0001 	movt	r0, #8193	; 0x2001
 8002bea:	f7fd fc45 	bl	8000478 <vListInitialise>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
 8002bee:	f642 5078 	movw	r0, #11640	; 0x2d78
 8002bf2:	f2c2 0001 	movt	r0, #8193	; 0x2001
 8002bf6:	f7fd fc3f 	bl	8000478 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
 8002bfa:	f642 5344 	movw	r3, #11588	; 0x2d44
 8002bfe:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8002c02:	f642 521c 	movw	r2, #11548	; 0x2d1c
 8002c06:	f2c2 0201 	movt	r2, #8193	; 0x2001
 8002c0a:	601a      	str	r2, [r3, #0]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 8002c0c:	f642 5348 	movw	r3, #11592	; 0x2d48
 8002c10:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8002c14:	f642 5230 	movw	r2, #11568	; 0x2d30
 8002c18:	f2c2 0201 	movt	r2, #8193	; 0x2001
 8002c1c:	601a      	str	r2, [r3, #0]
}
 8002c1e:	f107 0708 	add.w	r7, r7, #8
 8002c22:	46bd      	mov	sp, r7
 8002c24:	bd80      	pop	{r7, pc}
 8002c26:	bf00      	nop

08002c28 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
 8002c28:	b580      	push	{r7, lr}
 8002c2a:	b082      	sub	sp, #8
 8002c2c:	af00      	add	r7, sp, #0
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
 8002c2e:	e03d      	b.n	8002cac <prvCheckTasksWaitingTermination+0x84>
		{
			vTaskSuspendAll();
 8002c30:	f7ff faae 	bl	8002190 <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 8002c34:	f642 5360 	movw	r3, #11616	; 0x2d60
 8002c38:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8002c3c:	681b      	ldr	r3, [r3, #0]
 8002c3e:	2b00      	cmp	r3, #0
 8002c40:	bf14      	ite	ne
 8002c42:	2300      	movne	r3, #0
 8002c44:	2301      	moveq	r3, #1
 8002c46:	b2db      	uxtb	r3, r3
 8002c48:	607b      	str	r3, [r7, #4]
			xTaskResumeAll();
 8002c4a:	f7ff fab3 	bl	80021b4 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
 8002c4e:	687b      	ldr	r3, [r7, #4]
 8002c50:	2b00      	cmp	r3, #0
 8002c52:	d12b      	bne.n	8002cac <prvCheckTasksWaitingTermination+0x84>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
 8002c54:	f7fd ff84 	bl	8000b60 <vPortEnterCritical>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
 8002c58:	f642 5360 	movw	r3, #11616	; 0x2d60
 8002c5c:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8002c60:	68db      	ldr	r3, [r3, #12]
 8002c62:	68db      	ldr	r3, [r3, #12]
 8002c64:	603b      	str	r3, [r7, #0]
					uxListRemove( &( pxTCB->xGenericListItem ) );
 8002c66:	683b      	ldr	r3, [r7, #0]
 8002c68:	f103 0304 	add.w	r3, r3, #4
 8002c6c:	4618      	mov	r0, r3
 8002c6e:	f7fd fc93 	bl	8000598 <uxListRemove>
					--uxCurrentNumberOfTasks;
 8002c72:	f642 538c 	movw	r3, #11660	; 0x2d8c
 8002c76:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8002c7a:	681b      	ldr	r3, [r3, #0]
 8002c7c:	f103 32ff 	add.w	r2, r3, #4294967295	; 0xffffffff
 8002c80:	f642 538c 	movw	r3, #11660	; 0x2d8c
 8002c84:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8002c88:	601a      	str	r2, [r3, #0]
					--uxTasksDeleted;
 8002c8a:	f642 5374 	movw	r3, #11636	; 0x2d74
 8002c8e:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8002c92:	681b      	ldr	r3, [r3, #0]
 8002c94:	f103 32ff 	add.w	r2, r3, #4294967295	; 0xffffffff
 8002c98:	f642 5374 	movw	r3, #11636	; 0x2d74
 8002c9c:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8002ca0:	601a      	str	r2, [r3, #0]
				}
				taskEXIT_CRITICAL();
 8002ca2:	f7fd ff6f 	bl	8000b84 <vPortExitCritical>

				prvDeleteTCB( pxTCB );
 8002ca6:	6838      	ldr	r0, [r7, #0]
 8002ca8:	f000 f908 	bl	8002ebc <prvDeleteTCB>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
 8002cac:	f642 5374 	movw	r3, #11636	; 0x2d74
 8002cb0:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8002cb4:	681b      	ldr	r3, [r3, #0]
 8002cb6:	2b00      	cmp	r3, #0
 8002cb8:	d1ba      	bne.n	8002c30 <prvCheckTasksWaitingTermination+0x8>
				prvDeleteTCB( pxTCB );
			}
		}
	}
	#endif
}
 8002cba:	f107 0708 	add.w	r7, r7, #8
 8002cbe:	46bd      	mov	sp, r7
 8002cc0:	bd80      	pop	{r7, pc}
 8002cc2:	bf00      	nop

08002cc4 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
 8002cc4:	b580      	push	{r7, lr}
 8002cc6:	b082      	sub	sp, #8
 8002cc8:	af00      	add	r7, sp, #0
 8002cca:	6078      	str	r0, [r7, #4]
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 8002ccc:	f642 43b4 	movw	r3, #11444	; 0x2cb4
 8002cd0:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8002cd4:	681b      	ldr	r3, [r3, #0]
 8002cd6:	687a      	ldr	r2, [r7, #4]
 8002cd8:	605a      	str	r2, [r3, #4]

	if( xTimeToWake < xTickCount )
 8002cda:	f642 5390 	movw	r3, #11664	; 0x2d90
 8002cde:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8002ce2:	681b      	ldr	r3, [r3, #0]
 8002ce4:	687a      	ldr	r2, [r7, #4]
 8002ce6:	429a      	cmp	r2, r3
 8002ce8:	d210      	bcs.n	8002d0c <prvAddCurrentTaskToDelayedList+0x48>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 8002cea:	f642 5348 	movw	r3, #11592	; 0x2d48
 8002cee:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8002cf2:	681a      	ldr	r2, [r3, #0]
 8002cf4:	f642 43b4 	movw	r3, #11444	; 0x2cb4
 8002cf8:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8002cfc:	681b      	ldr	r3, [r3, #0]
 8002cfe:	f103 0304 	add.w	r3, r3, #4
 8002d02:	4610      	mov	r0, r2
 8002d04:	4619      	mov	r1, r3
 8002d06:	f7fd fc0d 	bl	8000524 <vListInsert>
 8002d0a:	e01d      	b.n	8002d48 <prvAddCurrentTaskToDelayedList+0x84>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 8002d0c:	f642 5344 	movw	r3, #11588	; 0x2d44
 8002d10:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8002d14:	681a      	ldr	r2, [r3, #0]
 8002d16:	f642 43b4 	movw	r3, #11444	; 0x2cb4
 8002d1a:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8002d1e:	681b      	ldr	r3, [r3, #0]
 8002d20:	f103 0304 	add.w	r3, r3, #4
 8002d24:	4610      	mov	r0, r2
 8002d26:	4619      	mov	r1, r3
 8002d28:	f7fd fbfc 	bl	8000524 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
 8002d2c:	f240 031c 	movw	r3, #28
 8002d30:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002d34:	681b      	ldr	r3, [r3, #0]
 8002d36:	687a      	ldr	r2, [r7, #4]
 8002d38:	429a      	cmp	r2, r3
 8002d3a:	d205      	bcs.n	8002d48 <prvAddCurrentTaskToDelayedList+0x84>
		{
			xNextTaskUnblockTime = xTimeToWake;
 8002d3c:	f240 031c 	movw	r3, #28
 8002d40:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002d44:	687a      	ldr	r2, [r7, #4]
 8002d46:	601a      	str	r2, [r3, #0]
		}
	}
}
 8002d48:	f107 0708 	add.w	r7, r7, #8
 8002d4c:	46bd      	mov	sp, r7
 8002d4e:	bd80      	pop	{r7, pc}

08002d50 <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
 8002d50:	b580      	push	{r7, lr}
 8002d52:	b084      	sub	sp, #16
 8002d54:	af00      	add	r7, sp, #0
 8002d56:	4603      	mov	r3, r0
 8002d58:	6039      	str	r1, [r7, #0]
 8002d5a:	80fb      	strh	r3, [r7, #6]
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
 8002d5c:	f04f 004c 	mov.w	r0, #76	; 0x4c
 8002d60:	f7fd fa2e 	bl	80001c0 <pvPortMalloc>
 8002d64:	60f8      	str	r0, [r7, #12]

	if( pxNewTCB != NULL )
 8002d66:	68fb      	ldr	r3, [r7, #12]
 8002d68:	2b00      	cmp	r3, #0
 8002d6a:	d023      	beq.n	8002db4 <prvAllocateTCBAndStack+0x64>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
 8002d6c:	683b      	ldr	r3, [r7, #0]
 8002d6e:	2b00      	cmp	r3, #0
 8002d70:	d107      	bne.n	8002d82 <prvAllocateTCBAndStack+0x32>
 8002d72:	88fb      	ldrh	r3, [r7, #6]
 8002d74:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002d78:	4618      	mov	r0, r3
 8002d7a:	f7fd fa21 	bl	80001c0 <pvPortMalloc>
 8002d7e:	4603      	mov	r3, r0
 8002d80:	e000      	b.n	8002d84 <prvAllocateTCBAndStack+0x34>
 8002d82:	683b      	ldr	r3, [r7, #0]
 8002d84:	68fa      	ldr	r2, [r7, #12]
 8002d86:	6313      	str	r3, [r2, #48]	; 0x30

		if( pxNewTCB->pxStack == NULL )
 8002d88:	68fb      	ldr	r3, [r7, #12]
 8002d8a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002d8c:	2b00      	cmp	r3, #0
 8002d8e:	d106      	bne.n	8002d9e <prvAllocateTCBAndStack+0x4e>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
 8002d90:	68f8      	ldr	r0, [r7, #12]
 8002d92:	f7fd faf5 	bl	8000380 <vPortFree>
			pxNewTCB = NULL;
 8002d96:	f04f 0300 	mov.w	r3, #0
 8002d9a:	60fb      	str	r3, [r7, #12]
 8002d9c:	e00a      	b.n	8002db4 <prvAllocateTCBAndStack+0x64>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
 8002d9e:	68fb      	ldr	r3, [r7, #12]
 8002da0:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8002da2:	88fb      	ldrh	r3, [r7, #6]
 8002da4:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002da8:	4610      	mov	r0, r2
 8002daa:	f04f 01a5 	mov.w	r1, #165	; 0xa5
 8002dae:	461a      	mov	r2, r3
 8002db0:	f000 fe60 	bl	8003a74 <memset>
		}
	}

	return pxNewTCB;
 8002db4:	68fb      	ldr	r3, [r7, #12]
}
 8002db6:	4618      	mov	r0, r3
 8002db8:	f107 0710 	add.w	r7, r7, #16
 8002dbc:	46bd      	mov	sp, r7
 8002dbe:	bd80      	pop	{r7, pc}

08002dc0 <prvListTaskWithinSingleList>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	static void prvListTaskWithinSingleList( const signed char *pcWriteBuffer, xList *pxList, signed char cStatus )
	{
 8002dc0:	b590      	push	{r4, r7, lr}
 8002dc2:	b08f      	sub	sp, #60	; 0x3c
 8002dc4:	af04      	add	r7, sp, #16
 8002dc6:	60f8      	str	r0, [r7, #12]
 8002dc8:	60b9      	str	r1, [r7, #8]
 8002dca:	4613      	mov	r3, r2
 8002dcc:	71fb      	strb	r3, [r7, #7]
	volatile tskTCB *pxNextTCB, *pxFirstTCB;
	unsigned short usStackRemaining;
	PRIVILEGED_DATA static char pcStatusString[ configMAX_TASK_NAME_LEN + 30 ];

		/* Write the details of all the TCB's in pxList into the buffer. */
		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
 8002dce:	68bb      	ldr	r3, [r7, #8]
 8002dd0:	627b      	str	r3, [r7, #36]	; 0x24
 8002dd2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002dd4:	685b      	ldr	r3, [r3, #4]
 8002dd6:	685a      	ldr	r2, [r3, #4]
 8002dd8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002dda:	605a      	str	r2, [r3, #4]
 8002ddc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002dde:	685a      	ldr	r2, [r3, #4]
 8002de0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002de2:	f103 0308 	add.w	r3, r3, #8
 8002de6:	429a      	cmp	r2, r3
 8002de8:	d104      	bne.n	8002df4 <prvListTaskWithinSingleList+0x34>
 8002dea:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002dec:	685b      	ldr	r3, [r3, #4]
 8002dee:	685a      	ldr	r2, [r3, #4]
 8002df0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002df2:	605a      	str	r2, [r3, #4]
 8002df4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002df6:	685b      	ldr	r3, [r3, #4]
 8002df8:	68db      	ldr	r3, [r3, #12]
 8002dfa:	623b      	str	r3, [r7, #32]
		do
		{
			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
 8002dfc:	68bb      	ldr	r3, [r7, #8]
 8002dfe:	61fb      	str	r3, [r7, #28]
 8002e00:	69fb      	ldr	r3, [r7, #28]
 8002e02:	685b      	ldr	r3, [r3, #4]
 8002e04:	685a      	ldr	r2, [r3, #4]
 8002e06:	69fb      	ldr	r3, [r7, #28]
 8002e08:	605a      	str	r2, [r3, #4]
 8002e0a:	69fb      	ldr	r3, [r7, #28]
 8002e0c:	685a      	ldr	r2, [r3, #4]
 8002e0e:	69fb      	ldr	r3, [r7, #28]
 8002e10:	f103 0308 	add.w	r3, r3, #8
 8002e14:	429a      	cmp	r2, r3
 8002e16:	d104      	bne.n	8002e22 <prvListTaskWithinSingleList+0x62>
 8002e18:	69fb      	ldr	r3, [r7, #28]
 8002e1a:	685b      	ldr	r3, [r3, #4]
 8002e1c:	685a      	ldr	r2, [r3, #4]
 8002e1e:	69fb      	ldr	r3, [r7, #28]
 8002e20:	605a      	str	r2, [r3, #4]
 8002e22:	69fb      	ldr	r3, [r7, #28]
 8002e24:	685b      	ldr	r3, [r3, #4]
 8002e26:	68db      	ldr	r3, [r3, #12]
 8002e28:	61bb      	str	r3, [r7, #24]
			{
				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxEndOfStack );
			}
			#else
			{
				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxStack );
 8002e2a:	69bb      	ldr	r3, [r7, #24]
 8002e2c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002e2e:	4618      	mov	r0, r3
 8002e30:	f000 f828 	bl	8002e84 <usTaskCheckFreeStackSpace>
 8002e34:	4603      	mov	r3, r0
 8002e36:	82fb      	strh	r3, [r7, #22]
			}
			#endif

			sprintf( pcStatusString, ( char * ) "%s\t\t%c\t%u\t%u\t%u\r\n", pxNextTCB->pcTaskName, cStatus, ( unsigned int ) pxNextTCB->uxPriority, ( unsigned int ) usStackRemaining, ( unsigned int ) pxNextTCB->uxTCBNumber );
 8002e38:	69bb      	ldr	r3, [r7, #24]
 8002e3a:	f103 0234 	add.w	r2, r3, #52	; 0x34
 8002e3e:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8002e42:	69b9      	ldr	r1, [r7, #24]
 8002e44:	6acc      	ldr	r4, [r1, #44]	; 0x2c
 8002e46:	8af8      	ldrh	r0, [r7, #22]
 8002e48:	69b9      	ldr	r1, [r7, #24]
 8002e4a:	6c09      	ldr	r1, [r1, #64]	; 0x40
 8002e4c:	9400      	str	r4, [sp, #0]
 8002e4e:	9001      	str	r0, [sp, #4]
 8002e50:	9102      	str	r1, [sp, #8]
 8002e52:	f642 50b4 	movw	r0, #11700	; 0x2db4
 8002e56:	f2c2 0001 	movt	r0, #8193	; 0x2001
 8002e5a:	f244 21c0 	movw	r1, #17088	; 0x42c0
 8002e5e:	f6c0 0100 	movt	r1, #2048	; 0x800
 8002e62:	f000 fe0f 	bl	8003a84 <siprintf>
			strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatusString );
 8002e66:	68f8      	ldr	r0, [r7, #12]
 8002e68:	f642 51b4 	movw	r1, #11700	; 0x2db4
 8002e6c:	f2c2 0101 	movt	r1, #8193	; 0x2001
 8002e70:	f000 fe2c 	bl	8003acc <strcat>

		} while( pxNextTCB != pxFirstTCB );
 8002e74:	69ba      	ldr	r2, [r7, #24]
 8002e76:	6a3b      	ldr	r3, [r7, #32]
 8002e78:	429a      	cmp	r2, r3
 8002e7a:	d1bf      	bne.n	8002dfc <prvListTaskWithinSingleList+0x3c>
	}
 8002e7c:	f107 072c 	add.w	r7, r7, #44	; 0x2c
 8002e80:	46bd      	mov	sp, r7
 8002e82:	bd90      	pop	{r4, r7, pc}

08002e84 <usTaskCheckFreeStackSpace>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
 8002e84:	b490      	push	{r4, r7}
 8002e86:	b082      	sub	sp, #8
 8002e88:	af00      	add	r7, sp, #0
 8002e8a:	6078      	str	r0, [r7, #4]
	register unsigned short usCount = 0U;
 8002e8c:	f04f 0400 	mov.w	r4, #0

		while( *pucStackByte == tskSTACK_FILL_BYTE )
 8002e90:	e006      	b.n	8002ea0 <usTaskCheckFreeStackSpace+0x1c>
		{
			pucStackByte -= portSTACK_GROWTH;
 8002e92:	687b      	ldr	r3, [r7, #4]
 8002e94:	f103 0301 	add.w	r3, r3, #1
 8002e98:	607b      	str	r3, [r7, #4]
			usCount++;
 8002e9a:	f104 0301 	add.w	r3, r4, #1
 8002e9e:	b29c      	uxth	r4, r3

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
 8002ea0:	687b      	ldr	r3, [r7, #4]
 8002ea2:	781b      	ldrb	r3, [r3, #0]
 8002ea4:	2ba5      	cmp	r3, #165	; 0xa5
 8002ea6:	d0f4      	beq.n	8002e92 <usTaskCheckFreeStackSpace+0xe>
		{
			pucStackByte -= portSTACK_GROWTH;
			usCount++;
		}

		usCount /= sizeof( portSTACK_TYPE );
 8002ea8:	ea4f 0394 	mov.w	r3, r4, lsr #2
 8002eac:	b29c      	uxth	r4, r3

		return usCount;
 8002eae:	4623      	mov	r3, r4
	}
 8002eb0:	4618      	mov	r0, r3
 8002eb2:	f107 0708 	add.w	r7, r7, #8
 8002eb6:	46bd      	mov	sp, r7
 8002eb8:	bc90      	pop	{r4, r7}
 8002eba:	4770      	bx	lr

08002ebc <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
 8002ebc:	b580      	push	{r7, lr}
 8002ebe:	b082      	sub	sp, #8
 8002ec0:	af00      	add	r7, sp, #0
 8002ec2:	6078      	str	r0, [r7, #4]
		want to allocate and clean RAM statically. */
		portCLEAN_UP_TCB( pxTCB );

		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
 8002ec4:	687b      	ldr	r3, [r7, #4]
 8002ec6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002ec8:	4618      	mov	r0, r3
 8002eca:	f7fd fa59 	bl	8000380 <vPortFree>
		vPortFree( pxTCB );
 8002ece:	6878      	ldr	r0, [r7, #4]
 8002ed0:	f7fd fa56 	bl	8000380 <vPortFree>
	}
 8002ed4:	f107 0708 	add.w	r7, r7, #8
 8002ed8:	46bd      	mov	sp, r7
 8002eda:	bd80      	pop	{r7, pc}

08002edc <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	xTaskHandle xTaskGetCurrentTaskHandle( void )
	{
 8002edc:	b480      	push	{r7}
 8002ede:	b083      	sub	sp, #12
 8002ee0:	af00      	add	r7, sp, #0
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
 8002ee2:	f642 43b4 	movw	r3, #11444	; 0x2cb4
 8002ee6:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8002eea:	681b      	ldr	r3, [r3, #0]
 8002eec:	607b      	str	r3, [r7, #4]

		return xReturn;
 8002eee:	687b      	ldr	r3, [r7, #4]
	}
 8002ef0:	4618      	mov	r0, r3
 8002ef2:	f107 070c 	add.w	r7, r7, #12
 8002ef6:	46bd      	mov	sp, r7
 8002ef8:	bc80      	pop	{r7}
 8002efa:	4770      	bx	lr

08002efc <xTaskGetSchedulerState>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )

	portBASE_TYPE xTaskGetSchedulerState( void )
	{
 8002efc:	b480      	push	{r7}
 8002efe:	b083      	sub	sp, #12
 8002f00:	af00      	add	r7, sp, #0
	portBASE_TYPE xReturn;

		if( xSchedulerRunning == pdFALSE )
 8002f02:	f642 539c 	movw	r3, #11676	; 0x2d9c
 8002f06:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8002f0a:	681b      	ldr	r3, [r3, #0]
 8002f0c:	2b00      	cmp	r3, #0
 8002f0e:	d103      	bne.n	8002f18 <xTaskGetSchedulerState+0x1c>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
 8002f10:	f04f 0300 	mov.w	r3, #0
 8002f14:	607b      	str	r3, [r7, #4]
 8002f16:	e00d      	b.n	8002f34 <xTaskGetSchedulerState+0x38>
		}
		else
		{
			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 8002f18:	f642 53a0 	movw	r3, #11680	; 0x2da0
 8002f1c:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8002f20:	681b      	ldr	r3, [r3, #0]
 8002f22:	2b00      	cmp	r3, #0
 8002f24:	d103      	bne.n	8002f2e <xTaskGetSchedulerState+0x32>
			{
				xReturn = taskSCHEDULER_RUNNING;
 8002f26:	f04f 0301 	mov.w	r3, #1
 8002f2a:	607b      	str	r3, [r7, #4]
 8002f2c:	e002      	b.n	8002f34 <xTaskGetSchedulerState+0x38>
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
 8002f2e:	f04f 0302 	mov.w	r3, #2
 8002f32:	607b      	str	r3, [r7, #4]
			}
		}

		return xReturn;
 8002f34:	687b      	ldr	r3, [r7, #4]
	}
 8002f36:	4618      	mov	r0, r3
 8002f38:	f107 070c 	add.w	r7, r7, #12
 8002f3c:	46bd      	mov	sp, r7
 8002f3e:	bc80      	pop	{r7}
 8002f40:	4770      	bx	lr
 8002f42:	bf00      	nop

08002f44 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
 8002f44:	b580      	push	{r7, lr}
 8002f46:	b084      	sub	sp, #16
 8002f48:	af00      	add	r7, sp, #0
 8002f4a:	6078      	str	r0, [r7, #4]
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
 8002f4c:	687b      	ldr	r3, [r7, #4]
 8002f4e:	60fb      	str	r3, [r7, #12]

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
 8002f50:	687b      	ldr	r3, [r7, #4]
 8002f52:	2b00      	cmp	r3, #0
 8002f54:	d05f      	beq.n	8003016 <vTaskPriorityInherit+0xd2>
		{
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
 8002f56:	68fb      	ldr	r3, [r7, #12]
 8002f58:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8002f5a:	f642 43b4 	movw	r3, #11444	; 0x2cb4
 8002f5e:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8002f62:	681b      	ldr	r3, [r3, #0]
 8002f64:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8002f66:	429a      	cmp	r2, r3
 8002f68:	d255      	bcs.n	8003016 <vTaskPriorityInherit+0xd2>
			{
				/* Adjust the mutex holder state to account for its new priority. */
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
 8002f6a:	f642 43b4 	movw	r3, #11444	; 0x2cb4
 8002f6e:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8002f72:	681b      	ldr	r3, [r3, #0]
 8002f74:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8002f76:	f1c3 0205 	rsb	r2, r3, #5
 8002f7a:	68fb      	ldr	r3, [r7, #12]
 8002f7c:	619a      	str	r2, [r3, #24]

				/* If the task being modified is in the ready state it will need to
				be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
 8002f7e:	68fb      	ldr	r3, [r7, #12]
 8002f80:	6959      	ldr	r1, [r3, #20]
 8002f82:	68fb      	ldr	r3, [r7, #12]
 8002f84:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8002f86:	4613      	mov	r3, r2
 8002f88:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002f8c:	189b      	adds	r3, r3, r2
 8002f8e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002f92:	f642 42b8 	movw	r2, #11448	; 0x2cb8
 8002f96:	f2c2 0201 	movt	r2, #8193	; 0x2001
 8002f9a:	189b      	adds	r3, r3, r2
 8002f9c:	4299      	cmp	r1, r3
 8002f9e:	d132      	bne.n	8003006 <vTaskPriorityInherit+0xc2>
				{
					if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
 8002fa0:	68fb      	ldr	r3, [r7, #12]
 8002fa2:	f103 0304 	add.w	r3, r3, #4
 8002fa6:	4618      	mov	r0, r3
 8002fa8:	f7fd faf6 	bl	8000598 <uxListRemove>
					{
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 8002fac:	f642 43b4 	movw	r3, #11444	; 0x2cb4
 8002fb0:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8002fb4:	681b      	ldr	r3, [r3, #0]
 8002fb6:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8002fb8:	68fb      	ldr	r3, [r7, #12]
 8002fba:	62da      	str	r2, [r3, #44]	; 0x2c
					prvAddTaskToReadyQueue( pxTCB );
 8002fbc:	68fb      	ldr	r3, [r7, #12]
 8002fbe:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8002fc0:	f642 5398 	movw	r3, #11672	; 0x2d98
 8002fc4:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8002fc8:	681b      	ldr	r3, [r3, #0]
 8002fca:	429a      	cmp	r2, r3
 8002fcc:	d906      	bls.n	8002fdc <vTaskPriorityInherit+0x98>
 8002fce:	68fb      	ldr	r3, [r7, #12]
 8002fd0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8002fd2:	f642 5398 	movw	r3, #11672	; 0x2d98
 8002fd6:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8002fda:	601a      	str	r2, [r3, #0]
 8002fdc:	68fb      	ldr	r3, [r7, #12]
 8002fde:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8002fe0:	4613      	mov	r3, r2
 8002fe2:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002fe6:	189b      	adds	r3, r3, r2
 8002fe8:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002fec:	f642 42b8 	movw	r2, #11448	; 0x2cb8
 8002ff0:	f2c2 0201 	movt	r2, #8193	; 0x2001
 8002ff4:	189a      	adds	r2, r3, r2
 8002ff6:	68fb      	ldr	r3, [r7, #12]
 8002ff8:	f103 0304 	add.w	r3, r3, #4
 8002ffc:	4610      	mov	r0, r2
 8002ffe:	4619      	mov	r1, r3
 8003000:	f7fd fa68 	bl	80004d4 <vListInsertEnd>
 8003004:	e007      	b.n	8003016 <vTaskPriorityInherit+0xd2>
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 8003006:	f642 43b4 	movw	r3, #11444	; 0x2cb4
 800300a:	f2c2 0301 	movt	r3, #8193	; 0x2001
 800300e:	681b      	ldr	r3, [r3, #0]
 8003010:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8003012:	68fb      	ldr	r3, [r7, #12]
 8003014:	62da      	str	r2, [r3, #44]	; 0x2c
				}

				traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
			}
		}
	}
 8003016:	f107 0710 	add.w	r7, r7, #16
 800301a:	46bd      	mov	sp, r7
 800301c:	bd80      	pop	{r7, pc}
 800301e:	bf00      	nop

08003020 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
 8003020:	b580      	push	{r7, lr}
 8003022:	b084      	sub	sp, #16
 8003024:	af00      	add	r7, sp, #0
 8003026:	6078      	str	r0, [r7, #4]
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
 8003028:	687b      	ldr	r3, [r7, #4]
 800302a:	60fb      	str	r3, [r7, #12]

		if( pxMutexHolder != NULL )
 800302c:	687b      	ldr	r3, [r7, #4]
 800302e:	2b00      	cmp	r3, #0
 8003030:	d039      	beq.n	80030a6 <vTaskPriorityDisinherit+0x86>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 8003032:	68fb      	ldr	r3, [r7, #12]
 8003034:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8003036:	68fb      	ldr	r3, [r7, #12]
 8003038:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800303a:	429a      	cmp	r2, r3
 800303c:	d033      	beq.n	80030a6 <vTaskPriorityDisinherit+0x86>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
 800303e:	68fb      	ldr	r3, [r7, #12]
 8003040:	f103 0304 	add.w	r3, r3, #4
 8003044:	4618      	mov	r0, r3
 8003046:	f7fd faa7 	bl	8000598 <uxListRemove>
				}

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
 800304a:	68fb      	ldr	r3, [r7, #12]
 800304c:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 800304e:	68fb      	ldr	r3, [r7, #12]
 8003050:	62da      	str	r2, [r3, #44]	; 0x2c
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
 8003052:	68fb      	ldr	r3, [r7, #12]
 8003054:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8003056:	f1c3 0205 	rsb	r2, r3, #5
 800305a:	68fb      	ldr	r3, [r7, #12]
 800305c:	619a      	str	r2, [r3, #24]
				prvAddTaskToReadyQueue( pxTCB );
 800305e:	68fb      	ldr	r3, [r7, #12]
 8003060:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8003062:	f642 5398 	movw	r3, #11672	; 0x2d98
 8003066:	f2c2 0301 	movt	r3, #8193	; 0x2001
 800306a:	681b      	ldr	r3, [r3, #0]
 800306c:	429a      	cmp	r2, r3
 800306e:	d906      	bls.n	800307e <vTaskPriorityDisinherit+0x5e>
 8003070:	68fb      	ldr	r3, [r7, #12]
 8003072:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8003074:	f642 5398 	movw	r3, #11672	; 0x2d98
 8003078:	f2c2 0301 	movt	r3, #8193	; 0x2001
 800307c:	601a      	str	r2, [r3, #0]
 800307e:	68fb      	ldr	r3, [r7, #12]
 8003080:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8003082:	4613      	mov	r3, r2
 8003084:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8003088:	189b      	adds	r3, r3, r2
 800308a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800308e:	f642 42b8 	movw	r2, #11448	; 0x2cb8
 8003092:	f2c2 0201 	movt	r2, #8193	; 0x2001
 8003096:	189a      	adds	r2, r3, r2
 8003098:	68fb      	ldr	r3, [r7, #12]
 800309a:	f103 0304 	add.w	r3, r3, #4
 800309e:	4610      	mov	r0, r2
 80030a0:	4619      	mov	r1, r3
 80030a2:	f7fd fa17 	bl	80004d4 <vListInsertEnd>
			}
		}
	}
 80030a6:	f107 0710 	add.w	r7, r7, #16
 80030aa:	46bd      	mov	sp, r7
 80030ac:	bd80      	pop	{r7, pc}
 80030ae:	bf00      	nop

080030b0 <xTimerCreateTimerTask>:
static void prvProcessTimerOrBlockTask( portTickType xNextExpireTime, portBASE_TYPE xListWasEmpty ) PRIVILEGED_FUNCTION;

/*-----------------------------------------------------------*/

portBASE_TYPE xTimerCreateTimerTask( void )
{
 80030b0:	b580      	push	{r7, lr}
 80030b2:	b086      	sub	sp, #24
 80030b4:	af04      	add	r7, sp, #16
portBASE_TYPE xReturn = pdFAIL;
 80030b6:	f04f 0300 	mov.w	r3, #0
 80030ba:	607b      	str	r3, [r7, #4]

	/* This function is called when the scheduler is started if
	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
	timer service task has been created/initialised.  If timers have already
	been created then the initialisation will already have been performed. */
	prvCheckForValidListAndQueue();
 80030bc:	f000 fae0 	bl	8003680 <prvCheckForValidListAndQueue>

	if( xTimerQueue != NULL )
 80030c0:	f642 630c 	movw	r3, #11788	; 0x2e0c
 80030c4:	f2c2 0301 	movt	r3, #8193	; 0x2001
 80030c8:	681b      	ldr	r3, [r3, #0]
 80030ca:	2b00      	cmp	r3, #0
 80030cc:	d01a      	beq.n	8003104 <xTimerCreateTimerTask+0x54>
			xReturn = xTaskCreate( prvTimerTask, ( const signed char * ) "Tmr Svc", ( unsigned short ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( unsigned portBASE_TYPE ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, &xTimerTaskHandle );
		}
		#else
		{
			/* Create the timer task without storing its handle. */
			xReturn = xTaskCreate( prvTimerTask, ( const signed char * ) "Tmr Svc", ( unsigned short ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( unsigned portBASE_TYPE ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, NULL);
 80030ce:	f04f 0302 	mov.w	r3, #2
 80030d2:	9300      	str	r3, [sp, #0]
 80030d4:	f04f 0300 	mov.w	r3, #0
 80030d8:	9301      	str	r3, [sp, #4]
 80030da:	f04f 0300 	mov.w	r3, #0
 80030de:	9302      	str	r3, [sp, #8]
 80030e0:	f04f 0300 	mov.w	r3, #0
 80030e4:	9303      	str	r3, [sp, #12]
 80030e6:	f243 20b5 	movw	r0, #12981	; 0x32b5
 80030ea:	f6c0 0000 	movt	r0, #2048	; 0x800
 80030ee:	f244 21e8 	movw	r1, #17128	; 0x42e8
 80030f2:	f6c0 0100 	movt	r1, #2048	; 0x800
 80030f6:	f44f 7282 	mov.w	r2, #260	; 0x104
 80030fa:	f04f 0300 	mov.w	r3, #0
 80030fe:	f7fe fc05 	bl	800190c <xTaskGenericCreate>
 8003102:	6078      	str	r0, [r7, #4]
		}
		#endif
	}

	configASSERT( xReturn );
 8003104:	687b      	ldr	r3, [r7, #4]
 8003106:	2b00      	cmp	r3, #0
 8003108:	d102      	bne.n	8003110 <xTimerCreateTimerTask+0x60>
 800310a:	f7fd fd55 	bl	8000bb8 <ulPortSetInterruptMask>
 800310e:	e7fe      	b.n	800310e <xTimerCreateTimerTask+0x5e>
	return xReturn;
 8003110:	687b      	ldr	r3, [r7, #4]
}
 8003112:	4618      	mov	r0, r3
 8003114:	f107 0708 	add.w	r7, r7, #8
 8003118:	46bd      	mov	sp, r7
 800311a:	bd80      	pop	{r7, pc}

0800311c <xTimerCreate>:
/*-----------------------------------------------------------*/

xTimerHandle xTimerCreate( const signed char * const pcTimerName, portTickType xTimerPeriodInTicks, unsigned portBASE_TYPE uxAutoReload, void *pvTimerID, tmrTIMER_CALLBACK pxCallbackFunction )
{
 800311c:	b580      	push	{r7, lr}
 800311e:	b086      	sub	sp, #24
 8003120:	af00      	add	r7, sp, #0
 8003122:	60f8      	str	r0, [r7, #12]
 8003124:	60b9      	str	r1, [r7, #8]
 8003126:	607a      	str	r2, [r7, #4]
 8003128:	603b      	str	r3, [r7, #0]
xTIMER *pxNewTimer;

	/* Allocate the timer structure. */
	if( xTimerPeriodInTicks == ( portTickType ) 0U )
 800312a:	68bb      	ldr	r3, [r7, #8]
 800312c:	2b00      	cmp	r3, #0
 800312e:	d108      	bne.n	8003142 <xTimerCreate+0x26>
	{
		pxNewTimer = NULL;
 8003130:	f04f 0300 	mov.w	r3, #0
 8003134:	617b      	str	r3, [r7, #20]
		configASSERT( ( xTimerPeriodInTicks > 0 ) );
 8003136:	68bb      	ldr	r3, [r7, #8]
 8003138:	2b00      	cmp	r3, #0
 800313a:	d121      	bne.n	8003180 <xTimerCreate+0x64>
 800313c:	f7fd fd3c 	bl	8000bb8 <ulPortSetInterruptMask>
 8003140:	e7fe      	b.n	8003140 <xTimerCreate+0x24>
	}
	else
	{
		pxNewTimer = ( xTIMER * ) pvPortMalloc( sizeof( xTIMER ) );
 8003142:	f04f 0028 	mov.w	r0, #40	; 0x28
 8003146:	f7fd f83b 	bl	80001c0 <pvPortMalloc>
 800314a:	6178      	str	r0, [r7, #20]
		if( pxNewTimer != NULL )
 800314c:	697b      	ldr	r3, [r7, #20]
 800314e:	2b00      	cmp	r3, #0
 8003150:	d016      	beq.n	8003180 <xTimerCreate+0x64>
		{
			/* Ensure the infrastructure used by the timer service task has been
			created/initialised. */
			prvCheckForValidListAndQueue();
 8003152:	f000 fa95 	bl	8003680 <prvCheckForValidListAndQueue>

			/* Initialise the timer structure members using the function parameters. */
			pxNewTimer->pcTimerName = pcTimerName;
 8003156:	697b      	ldr	r3, [r7, #20]
 8003158:	68fa      	ldr	r2, [r7, #12]
 800315a:	601a      	str	r2, [r3, #0]
			pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
 800315c:	697b      	ldr	r3, [r7, #20]
 800315e:	68ba      	ldr	r2, [r7, #8]
 8003160:	619a      	str	r2, [r3, #24]
			pxNewTimer->uxAutoReload = uxAutoReload;
 8003162:	697b      	ldr	r3, [r7, #20]
 8003164:	687a      	ldr	r2, [r7, #4]
 8003166:	61da      	str	r2, [r3, #28]
			pxNewTimer->pvTimerID = pvTimerID;
 8003168:	697b      	ldr	r3, [r7, #20]
 800316a:	683a      	ldr	r2, [r7, #0]
 800316c:	621a      	str	r2, [r3, #32]
			pxNewTimer->pxCallbackFunction = pxCallbackFunction;
 800316e:	697b      	ldr	r3, [r7, #20]
 8003170:	6a3a      	ldr	r2, [r7, #32]
 8003172:	625a      	str	r2, [r3, #36]	; 0x24
			vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
 8003174:	697b      	ldr	r3, [r7, #20]
 8003176:	f103 0304 	add.w	r3, r3, #4
 800317a:	4618      	mov	r0, r3
 800317c:	f7fd f99c 	bl	80004b8 <vListInitialiseItem>
		{
			traceTIMER_CREATE_FAILED();
		}
	}

	return ( xTimerHandle ) pxNewTimer;
 8003180:	697b      	ldr	r3, [r7, #20]
}
 8003182:	4618      	mov	r0, r3
 8003184:	f107 0718 	add.w	r7, r7, #24
 8003188:	46bd      	mov	sp, r7
 800318a:	bd80      	pop	{r7, pc}

0800318c <xTimerGenericCommand>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTimerGenericCommand( xTimerHandle xTimer, portBASE_TYPE xCommandID, portTickType xOptionalValue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portTickType xBlockTime )
{
 800318c:	b580      	push	{r7, lr}
 800318e:	b088      	sub	sp, #32
 8003190:	af00      	add	r7, sp, #0
 8003192:	60f8      	str	r0, [r7, #12]
 8003194:	60b9      	str	r1, [r7, #8]
 8003196:	607a      	str	r2, [r7, #4]
 8003198:	603b      	str	r3, [r7, #0]
portBASE_TYPE xReturn = pdFAIL;
 800319a:	f04f 0300 	mov.w	r3, #0
 800319e:	61fb      	str	r3, [r7, #28]
xTIMER_MESSAGE xMessage;

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
 80031a0:	f642 630c 	movw	r3, #11788	; 0x2e0c
 80031a4:	f2c2 0301 	movt	r3, #8193	; 0x2001
 80031a8:	681b      	ldr	r3, [r3, #0]
 80031aa:	2b00      	cmp	r3, #0
 80031ac:	d03d      	beq.n	800322a <xTimerGenericCommand+0x9e>
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
 80031ae:	68bb      	ldr	r3, [r7, #8]
 80031b0:	613b      	str	r3, [r7, #16]
		xMessage.xMessageValue = xOptionalValue;
 80031b2:	687b      	ldr	r3, [r7, #4]
 80031b4:	617b      	str	r3, [r7, #20]
		xMessage.pxTimer = ( xTIMER * ) xTimer;
 80031b6:	68fb      	ldr	r3, [r7, #12]
 80031b8:	61bb      	str	r3, [r7, #24]

		if( pxHigherPriorityTaskWoken == NULL )
 80031ba:	683b      	ldr	r3, [r7, #0]
 80031bc:	2b00      	cmp	r3, #0
 80031be:	d125      	bne.n	800320c <xTimerGenericCommand+0x80>
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
 80031c0:	f7ff fe9c 	bl	8002efc <xTaskGetSchedulerState>
 80031c4:	4603      	mov	r3, r0
 80031c6:	2b01      	cmp	r3, #1
 80031c8:	d10f      	bne.n	80031ea <xTimerGenericCommand+0x5e>
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xBlockTime );
 80031ca:	f642 630c 	movw	r3, #11788	; 0x2e0c
 80031ce:	f2c2 0301 	movt	r3, #8193	; 0x2001
 80031d2:	681a      	ldr	r2, [r3, #0]
 80031d4:	f107 0310 	add.w	r3, r7, #16
 80031d8:	4610      	mov	r0, r2
 80031da:	4619      	mov	r1, r3
 80031dc:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80031de:	f04f 0300 	mov.w	r3, #0
 80031e2:	f7fd fedf 	bl	8000fa4 <xQueueGenericSend>
 80031e6:	61f8      	str	r0, [r7, #28]
 80031e8:	e01f      	b.n	800322a <xTimerGenericCommand+0x9e>
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
 80031ea:	f642 630c 	movw	r3, #11788	; 0x2e0c
 80031ee:	f2c2 0301 	movt	r3, #8193	; 0x2001
 80031f2:	681a      	ldr	r2, [r3, #0]
 80031f4:	f107 0310 	add.w	r3, r7, #16
 80031f8:	4610      	mov	r0, r2
 80031fa:	4619      	mov	r1, r3
 80031fc:	f04f 0200 	mov.w	r2, #0
 8003200:	f04f 0300 	mov.w	r3, #0
 8003204:	f7fd fece 	bl	8000fa4 <xQueueGenericSend>
 8003208:	61f8      	str	r0, [r7, #28]
 800320a:	e00e      	b.n	800322a <xTimerGenericCommand+0x9e>
			}
		}
		else
		{
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
 800320c:	f642 630c 	movw	r3, #11788	; 0x2e0c
 8003210:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8003214:	681a      	ldr	r2, [r3, #0]
 8003216:	f107 0310 	add.w	r3, r7, #16
 800321a:	4610      	mov	r0, r2
 800321c:	4619      	mov	r1, r3
 800321e:	683a      	ldr	r2, [r7, #0]
 8003220:	f04f 0300 	mov.w	r3, #0
 8003224:	f7fd ff64 	bl	80010f0 <xQueueGenericSendFromISR>
 8003228:	61f8      	str	r0, [r7, #28]
		}

		traceTIMER_COMMAND_SEND( xTimer, xCommandID, xOptionalValue, xReturn );
	}

	return xReturn;
 800322a:	69fb      	ldr	r3, [r7, #28]
}
 800322c:	4618      	mov	r0, r3
 800322e:	f107 0720 	add.w	r7, r7, #32
 8003232:	46bd      	mov	sp, r7
 8003234:	bd80      	pop	{r7, pc}
 8003236:	bf00      	nop

08003238 <prvProcessExpiredTimer>:

#endif
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( portTickType xNextExpireTime, portTickType xTimeNow )
{
 8003238:	b580      	push	{r7, lr}
 800323a:	b086      	sub	sp, #24
 800323c:	af02      	add	r7, sp, #8
 800323e:	6078      	str	r0, [r7, #4]
 8003240:	6039      	str	r1, [r7, #0]
xTIMER *pxTimer;
portBASE_TYPE xResult;

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	pxTimer = ( xTIMER * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
 8003242:	f642 6304 	movw	r3, #11780	; 0x2e04
 8003246:	f2c2 0301 	movt	r3, #8193	; 0x2001
 800324a:	681b      	ldr	r3, [r3, #0]
 800324c:	68db      	ldr	r3, [r3, #12]
 800324e:	68db      	ldr	r3, [r3, #12]
 8003250:	60fb      	str	r3, [r7, #12]
	uxListRemove( &( pxTimer->xTimerListItem ) );
 8003252:	68fb      	ldr	r3, [r7, #12]
 8003254:	f103 0304 	add.w	r3, r3, #4
 8003258:	4618      	mov	r0, r3
 800325a:	f7fd f99d 	bl	8000598 <uxListRemove>
	traceTIMER_EXPIRED( pxTimer );

	/* If the timer is an auto reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
 800325e:	68fb      	ldr	r3, [r7, #12]
 8003260:	69db      	ldr	r3, [r3, #28]
 8003262:	2b01      	cmp	r3, #1
 8003264:	d11e      	bne.n	80032a4 <prvProcessExpiredTimer+0x6c>
		a time relative to anything other than the current time.  It
		will therefore be inserted into the correct list relative to
		the time this task thinks it is now, even if a command to
		switch lists due to a tick count overflow is already waiting in
		the timer queue. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) == pdTRUE )
 8003266:	68fb      	ldr	r3, [r7, #12]
 8003268:	699a      	ldr	r2, [r3, #24]
 800326a:	687b      	ldr	r3, [r7, #4]
 800326c:	18d3      	adds	r3, r2, r3
 800326e:	68f8      	ldr	r0, [r7, #12]
 8003270:	4619      	mov	r1, r3
 8003272:	683a      	ldr	r2, [r7, #0]
 8003274:	687b      	ldr	r3, [r7, #4]
 8003276:	f000 f8bf 	bl	80033f8 <prvInsertTimerInActiveList>
 800327a:	4603      	mov	r3, r0
 800327c:	2b01      	cmp	r3, #1
 800327e:	d111      	bne.n	80032a4 <prvProcessExpiredTimer+0x6c>
		{
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xNextExpireTime, NULL, tmrNO_DELAY );
 8003280:	f04f 0300 	mov.w	r3, #0
 8003284:	9300      	str	r3, [sp, #0]
 8003286:	68f8      	ldr	r0, [r7, #12]
 8003288:	f04f 0100 	mov.w	r1, #0
 800328c:	687a      	ldr	r2, [r7, #4]
 800328e:	f04f 0300 	mov.w	r3, #0
 8003292:	f7ff ff7b 	bl	800318c <xTimerGenericCommand>
 8003296:	60b8      	str	r0, [r7, #8]
			configASSERT( xResult );
 8003298:	68bb      	ldr	r3, [r7, #8]
 800329a:	2b00      	cmp	r3, #0
 800329c:	d102      	bne.n	80032a4 <prvProcessExpiredTimer+0x6c>
 800329e:	f7fd fc8b 	bl	8000bb8 <ulPortSetInterruptMask>
 80032a2:	e7fe      	b.n	80032a2 <prvProcessExpiredTimer+0x6a>
			( void ) xResult;
		}
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
 80032a4:	68fb      	ldr	r3, [r7, #12]
 80032a6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80032a8:	68f8      	ldr	r0, [r7, #12]
 80032aa:	4798      	blx	r3
}
 80032ac:	f107 0710 	add.w	r7, r7, #16
 80032b0:	46bd      	mov	sp, r7
 80032b2:	bd80      	pop	{r7, pc}

080032b4 <prvTimerTask>:
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
 80032b4:	b580      	push	{r7, lr}
 80032b6:	b084      	sub	sp, #16
 80032b8:	af00      	add	r7, sp, #0
 80032ba:	6078      	str	r0, [r7, #4]

	for( ;; )
	{
		/* Query the timers list to see if it contains any timers, and if so,
		obtain the time at which the next timer will expire. */
		xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
 80032bc:	f107 0308 	add.w	r3, r7, #8
 80032c0:	4618      	mov	r0, r3
 80032c2:	f000 f843 	bl	800334c <prvGetNextExpireTime>
 80032c6:	60f8      	str	r0, [r7, #12]

		/* If a timer has expired, process it.  Otherwise, block this task
		until either a timer does expire, or a command is received. */
		prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
 80032c8:	68bb      	ldr	r3, [r7, #8]
 80032ca:	68f8      	ldr	r0, [r7, #12]
 80032cc:	4619      	mov	r1, r3
 80032ce:	f000 f803 	bl	80032d8 <prvProcessTimerOrBlockTask>

		/* Empty the command queue. */
		prvProcessReceivedCommands();
 80032d2:	f000 f8db 	bl	800348c <prvProcessReceivedCommands>
	}
 80032d6:	e7f1      	b.n	80032bc <prvTimerTask+0x8>

080032d8 <prvProcessTimerOrBlockTask>:
}
/*-----------------------------------------------------------*/

static void prvProcessTimerOrBlockTask( portTickType xNextExpireTime, portBASE_TYPE xListWasEmpty )
{
 80032d8:	b580      	push	{r7, lr}
 80032da:	b084      	sub	sp, #16
 80032dc:	af00      	add	r7, sp, #0
 80032de:	6078      	str	r0, [r7, #4]
 80032e0:	6039      	str	r1, [r7, #0]
portTickType xTimeNow;
portBASE_TYPE xTimerListsWereSwitched;

	vTaskSuspendAll();
 80032e2:	f7fe ff55 	bl	8002190 <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampelTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
 80032e6:	f107 0308 	add.w	r3, r7, #8
 80032ea:	4618      	mov	r0, r3
 80032ec:	f000 f858 	bl	80033a0 <prvSampleTimeNow>
 80032f0:	60f8      	str	r0, [r7, #12]
		if( xTimerListsWereSwitched == pdFALSE )
 80032f2:	68bb      	ldr	r3, [r7, #8]
 80032f4:	2b00      	cmp	r3, #0
 80032f6:	d121      	bne.n	800333c <prvProcessTimerOrBlockTask+0x64>
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
 80032f8:	683b      	ldr	r3, [r7, #0]
 80032fa:	2b00      	cmp	r3, #0
 80032fc:	d10a      	bne.n	8003314 <prvProcessTimerOrBlockTask+0x3c>
 80032fe:	687a      	ldr	r2, [r7, #4]
 8003300:	68fb      	ldr	r3, [r7, #12]
 8003302:	429a      	cmp	r2, r3
 8003304:	d806      	bhi.n	8003314 <prvProcessTimerOrBlockTask+0x3c>
			{
				xTaskResumeAll();
 8003306:	f7fe ff55 	bl	80021b4 <xTaskResumeAll>
				prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
 800330a:	6878      	ldr	r0, [r7, #4]
 800330c:	68f9      	ldr	r1, [r7, #12]
 800330e:	f7ff ff93 	bl	8003238 <prvProcessExpiredTimer>
 8003312:	e017      	b.n	8003344 <prvProcessTimerOrBlockTask+0x6c>
				time has not been reached yet.  This task should therefore
				block to wait for the next expire time or a command to be
				received - whichever comes first.  The following line cannot
				be reached unless xNextExpireTime > xTimeNow, except in the
				case when the current timer list is empty. */
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ) );
 8003314:	f642 630c 	movw	r3, #11788	; 0x2e0c
 8003318:	f2c2 0301 	movt	r3, #8193	; 0x2001
 800331c:	681a      	ldr	r2, [r3, #0]
 800331e:	6879      	ldr	r1, [r7, #4]
 8003320:	68fb      	ldr	r3, [r7, #12]
 8003322:	1acb      	subs	r3, r1, r3
 8003324:	4610      	mov	r0, r2
 8003326:	4619      	mov	r1, r3
 8003328:	f7fe fa7e 	bl	8001828 <vQueueWaitForMessageRestricted>

				if( xTaskResumeAll() == pdFALSE )
 800332c:	f7fe ff42 	bl	80021b4 <xTaskResumeAll>
 8003330:	4603      	mov	r3, r0
 8003332:	2b00      	cmp	r3, #0
 8003334:	d105      	bne.n	8003342 <prvProcessTimerOrBlockTask+0x6a>
				{
					/* Yield to wait for either a command to arrive, or the block time
					to expire.  If a command arrived between the critical section being
					exited and this yield then the yield will not cause the task
					to block. */
					portYIELD_WITHIN_API();
 8003336:	f7fd fc07 	bl	8000b48 <vPortYieldFromISR>
 800333a:	e002      	b.n	8003342 <prvProcessTimerOrBlockTask+0x6a>
				}
			}
		}
		else
		{
			xTaskResumeAll();
 800333c:	f7fe ff3a 	bl	80021b4 <xTaskResumeAll>
 8003340:	e000      	b.n	8003344 <prvProcessTimerOrBlockTask+0x6c>
				{
					/* Yield to wait for either a command to arrive, or the block time
					to expire.  If a command arrived between the critical section being
					exited and this yield then the yield will not cause the task
					to block. */
					portYIELD_WITHIN_API();
 8003342:	bf00      	nop
		else
		{
			xTaskResumeAll();
		}
	}
}
 8003344:	f107 0710 	add.w	r7, r7, #16
 8003348:	46bd      	mov	sp, r7
 800334a:	bd80      	pop	{r7, pc}

0800334c <prvGetNextExpireTime>:
/*-----------------------------------------------------------*/

static portTickType prvGetNextExpireTime( portBASE_TYPE *pxListWasEmpty )
{
 800334c:	b480      	push	{r7}
 800334e:	b085      	sub	sp, #20
 8003350:	af00      	add	r7, sp, #0
 8003352:	6078      	str	r0, [r7, #4]
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
 8003354:	f642 6304 	movw	r3, #11780	; 0x2e04
 8003358:	f2c2 0301 	movt	r3, #8193	; 0x2001
 800335c:	681b      	ldr	r3, [r3, #0]
 800335e:	681b      	ldr	r3, [r3, #0]
 8003360:	2b00      	cmp	r3, #0
 8003362:	bf14      	ite	ne
 8003364:	2300      	movne	r3, #0
 8003366:	2301      	moveq	r3, #1
 8003368:	b2db      	uxtb	r3, r3
 800336a:	461a      	mov	r2, r3
 800336c:	687b      	ldr	r3, [r7, #4]
 800336e:	601a      	str	r2, [r3, #0]
	if( *pxListWasEmpty == pdFALSE )
 8003370:	687b      	ldr	r3, [r7, #4]
 8003372:	681b      	ldr	r3, [r3, #0]
 8003374:	2b00      	cmp	r3, #0
 8003376:	d108      	bne.n	800338a <prvGetNextExpireTime+0x3e>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 8003378:	f642 6304 	movw	r3, #11780	; 0x2e04
 800337c:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8003380:	681b      	ldr	r3, [r3, #0]
 8003382:	68db      	ldr	r3, [r3, #12]
 8003384:	681b      	ldr	r3, [r3, #0]
 8003386:	60fb      	str	r3, [r7, #12]
 8003388:	e002      	b.n	8003390 <prvGetNextExpireTime+0x44>
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( portTickType ) 0U;
 800338a:	f04f 0300 	mov.w	r3, #0
 800338e:	60fb      	str	r3, [r7, #12]
	}

	return xNextExpireTime;
 8003390:	68fb      	ldr	r3, [r7, #12]
}
 8003392:	4618      	mov	r0, r3
 8003394:	f107 0714 	add.w	r7, r7, #20
 8003398:	46bd      	mov	sp, r7
 800339a:	bc80      	pop	{r7}
 800339c:	4770      	bx	lr
 800339e:	bf00      	nop

080033a0 <prvSampleTimeNow>:
/*-----------------------------------------------------------*/

static portTickType prvSampleTimeNow( portBASE_TYPE *pxTimerListsWereSwitched )
{
 80033a0:	b580      	push	{r7, lr}
 80033a2:	b084      	sub	sp, #16
 80033a4:	af00      	add	r7, sp, #0
 80033a6:	6078      	str	r0, [r7, #4]
portTickType xTimeNow;
PRIVILEGED_DATA static portTickType xLastTime = ( portTickType ) 0U;

	xTimeNow = xTaskGetTickCount();
 80033a8:	f7fe ffb6 	bl	8002318 <xTaskGetTickCount>
 80033ac:	60f8      	str	r0, [r7, #12]

	if( xTimeNow < xLastTime )
 80033ae:	f642 6310 	movw	r3, #11792	; 0x2e10
 80033b2:	f2c2 0301 	movt	r3, #8193	; 0x2001
 80033b6:	681b      	ldr	r3, [r3, #0]
 80033b8:	68fa      	ldr	r2, [r7, #12]
 80033ba:	429a      	cmp	r2, r3
 80033bc:	d20c      	bcs.n	80033d8 <prvSampleTimeNow+0x38>
	{
		prvSwitchTimerLists( xLastTime );
 80033be:	f642 6310 	movw	r3, #11792	; 0x2e10
 80033c2:	f2c2 0301 	movt	r3, #8193	; 0x2001
 80033c6:	681b      	ldr	r3, [r3, #0]
 80033c8:	4618      	mov	r0, r3
 80033ca:	f000 f8e5 	bl	8003598 <prvSwitchTimerLists>
		*pxTimerListsWereSwitched = pdTRUE;
 80033ce:	687b      	ldr	r3, [r7, #4]
 80033d0:	f04f 0201 	mov.w	r2, #1
 80033d4:	601a      	str	r2, [r3, #0]
 80033d6:	e003      	b.n	80033e0 <prvSampleTimeNow+0x40>
	}
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
 80033d8:	687b      	ldr	r3, [r7, #4]
 80033da:	f04f 0200 	mov.w	r2, #0
 80033de:	601a      	str	r2, [r3, #0]
	}

	xLastTime = xTimeNow;
 80033e0:	f642 6310 	movw	r3, #11792	; 0x2e10
 80033e4:	f2c2 0301 	movt	r3, #8193	; 0x2001
 80033e8:	68fa      	ldr	r2, [r7, #12]
 80033ea:	601a      	str	r2, [r3, #0]

	return xTimeNow;
 80033ec:	68fb      	ldr	r3, [r7, #12]
}
 80033ee:	4618      	mov	r0, r3
 80033f0:	f107 0710 	add.w	r7, r7, #16
 80033f4:	46bd      	mov	sp, r7
 80033f6:	bd80      	pop	{r7, pc}

080033f8 <prvInsertTimerInActiveList>:
/*-----------------------------------------------------------*/

static portBASE_TYPE prvInsertTimerInActiveList( xTIMER *pxTimer, portTickType xNextExpiryTime, portTickType xTimeNow, portTickType xCommandTime )
{
 80033f8:	b580      	push	{r7, lr}
 80033fa:	b086      	sub	sp, #24
 80033fc:	af00      	add	r7, sp, #0
 80033fe:	60f8      	str	r0, [r7, #12]
 8003400:	60b9      	str	r1, [r7, #8]
 8003402:	607a      	str	r2, [r7, #4]
 8003404:	603b      	str	r3, [r7, #0]
portBASE_TYPE xProcessTimerNow = pdFALSE;
 8003406:	f04f 0300 	mov.w	r3, #0
 800340a:	617b      	str	r3, [r7, #20]

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
 800340c:	68fb      	ldr	r3, [r7, #12]
 800340e:	68ba      	ldr	r2, [r7, #8]
 8003410:	605a      	str	r2, [r3, #4]
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 8003412:	68fb      	ldr	r3, [r7, #12]
 8003414:	68fa      	ldr	r2, [r7, #12]
 8003416:	611a      	str	r2, [r3, #16]

	if( xNextExpiryTime <= xTimeNow )
 8003418:	68ba      	ldr	r2, [r7, #8]
 800341a:	687b      	ldr	r3, [r7, #4]
 800341c:	429a      	cmp	r2, r3
 800341e:	d817      	bhi.n	8003450 <prvInsertTimerInActiveList+0x58>
	{
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if( ( ( portTickType ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks )
 8003420:	687a      	ldr	r2, [r7, #4]
 8003422:	683b      	ldr	r3, [r7, #0]
 8003424:	1ad2      	subs	r2, r2, r3
 8003426:	68fb      	ldr	r3, [r7, #12]
 8003428:	699b      	ldr	r3, [r3, #24]
 800342a:	429a      	cmp	r2, r3
 800342c:	d303      	bcc.n	8003436 <prvInsertTimerInActiveList+0x3e>
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
 800342e:	f04f 0301 	mov.w	r3, #1
 8003432:	617b      	str	r3, [r7, #20]
 8003434:	e024      	b.n	8003480 <prvInsertTimerInActiveList+0x88>
		}
		else
		{
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
 8003436:	f642 6308 	movw	r3, #11784	; 0x2e08
 800343a:	f2c2 0301 	movt	r3, #8193	; 0x2001
 800343e:	681a      	ldr	r2, [r3, #0]
 8003440:	68fb      	ldr	r3, [r7, #12]
 8003442:	f103 0304 	add.w	r3, r3, #4
 8003446:	4610      	mov	r0, r2
 8003448:	4619      	mov	r1, r3
 800344a:	f7fd f86b 	bl	8000524 <vListInsert>
 800344e:	e017      	b.n	8003480 <prvInsertTimerInActiveList+0x88>
		}
	}
	else
	{
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
 8003450:	687a      	ldr	r2, [r7, #4]
 8003452:	683b      	ldr	r3, [r7, #0]
 8003454:	429a      	cmp	r2, r3
 8003456:	d207      	bcs.n	8003468 <prvInsertTimerInActiveList+0x70>
 8003458:	68ba      	ldr	r2, [r7, #8]
 800345a:	683b      	ldr	r3, [r7, #0]
 800345c:	429a      	cmp	r2, r3
 800345e:	d303      	bcc.n	8003468 <prvInsertTimerInActiveList+0x70>
		{
			/* If, since the command was issued, the tick count has overflowed
			but the expiry time has not, then the timer must have already passed
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
 8003460:	f04f 0301 	mov.w	r3, #1
 8003464:	617b      	str	r3, [r7, #20]
 8003466:	e00b      	b.n	8003480 <prvInsertTimerInActiveList+0x88>
		}
		else
		{
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 8003468:	f642 6304 	movw	r3, #11780	; 0x2e04
 800346c:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8003470:	681a      	ldr	r2, [r3, #0]
 8003472:	68fb      	ldr	r3, [r7, #12]
 8003474:	f103 0304 	add.w	r3, r3, #4
 8003478:	4610      	mov	r0, r2
 800347a:	4619      	mov	r1, r3
 800347c:	f7fd f852 	bl	8000524 <vListInsert>
		}
	}

	return xProcessTimerNow;
 8003480:	697b      	ldr	r3, [r7, #20]
}
 8003482:	4618      	mov	r0, r3
 8003484:	f107 0718 	add.w	r7, r7, #24
 8003488:	46bd      	mov	sp, r7
 800348a:	bd80      	pop	{r7, pc}

0800348c <prvProcessReceivedCommands>:
/*-----------------------------------------------------------*/

static void	prvProcessReceivedCommands( void )
{
 800348c:	b580      	push	{r7, lr}
 800348e:	b08a      	sub	sp, #40	; 0x28
 8003490:	af02      	add	r7, sp, #8
portBASE_TYPE xTimerListsWereSwitched, xResult;
portTickType xTimeNow;

	/* In this case the xTimerListsWereSwitched parameter is not used, but it
	must be present in the function call. */
	xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
 8003492:	f107 0304 	add.w	r3, r7, #4
 8003496:	4618      	mov	r0, r3
 8003498:	f7ff ff82 	bl	80033a0 <prvSampleTimeNow>
 800349c:	61f8      	str	r0, [r7, #28]

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL )
 800349e:	e064      	b.n	800356a <prvProcessReceivedCommands+0xde>
	{
		pxTimer = xMessage.pxTimer;
 80034a0:	693b      	ldr	r3, [r7, #16]
 80034a2:	61bb      	str	r3, [r7, #24]

		/* Is the timer already in a list of active timers?  When the command
		is trmCOMMAND_PROCESS_TIMER_OVERFLOW, the timer will be NULL as the
		command is to the task rather than to an individual timer. */
		if( pxTimer != NULL )
 80034a4:	69bb      	ldr	r3, [r7, #24]
 80034a6:	2b00      	cmp	r3, #0
 80034a8:	d009      	beq.n	80034be <prvProcessReceivedCommands+0x32>
		{
			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
 80034aa:	69bb      	ldr	r3, [r7, #24]
 80034ac:	695b      	ldr	r3, [r3, #20]
 80034ae:	2b00      	cmp	r3, #0
 80034b0:	d005      	beq.n	80034be <prvProcessReceivedCommands+0x32>
			{
				/* The timer is in a list, remove it. */
				uxListRemove( &( pxTimer->xTimerListItem ) );
 80034b2:	69bb      	ldr	r3, [r7, #24]
 80034b4:	f103 0304 	add.w	r3, r3, #4
 80034b8:	4618      	mov	r0, r3
 80034ba:	f7fd f86d 	bl	8000598 <uxListRemove>
			}
		}

		traceTIMER_COMMAND_RECEIVED( pxTimer, xMessage.xMessageID, xMessage.xMessageValue );

		switch( xMessage.xMessageID )
 80034be:	68bb      	ldr	r3, [r7, #8]
 80034c0:	2b03      	cmp	r3, #3
 80034c2:	d84f      	bhi.n	8003564 <prvProcessReceivedCommands+0xd8>
 80034c4:	a201      	add	r2, pc, #4	; (adr r2, 80034cc <prvProcessReceivedCommands+0x40>)
 80034c6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80034ca:	bf00      	nop
 80034cc:	080034dd 	.word	0x080034dd
 80034d0:	08003565 	.word	0x08003565
 80034d4:	08003533 	.word	0x08003533
 80034d8:	0800355d 	.word	0x0800355d
		{
			case tmrCOMMAND_START :
				/* Start or restart a timer. */
				if( prvInsertTimerInActiveList( pxTimer,  xMessage.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.xMessageValue ) == pdTRUE )
 80034dc:	68fa      	ldr	r2, [r7, #12]
 80034de:	69bb      	ldr	r3, [r7, #24]
 80034e0:	699b      	ldr	r3, [r3, #24]
 80034e2:	18d2      	adds	r2, r2, r3
 80034e4:	68fb      	ldr	r3, [r7, #12]
 80034e6:	69b8      	ldr	r0, [r7, #24]
 80034e8:	4611      	mov	r1, r2
 80034ea:	69fa      	ldr	r2, [r7, #28]
 80034ec:	f7ff ff84 	bl	80033f8 <prvInsertTimerInActiveList>
 80034f0:	4603      	mov	r3, r0
 80034f2:	2b01      	cmp	r3, #1
 80034f4:	d138      	bne.n	8003568 <prvProcessReceivedCommands+0xdc>
				{
					/* The timer expired before it was added to the active timer
					list.  Process it now. */
					pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
 80034f6:	69bb      	ldr	r3, [r7, #24]
 80034f8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80034fa:	69b8      	ldr	r0, [r7, #24]
 80034fc:	4798      	blx	r3

					if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
 80034fe:	69bb      	ldr	r3, [r7, #24]
 8003500:	69db      	ldr	r3, [r3, #28]
 8003502:	2b01      	cmp	r3, #1
 8003504:	d130      	bne.n	8003568 <prvProcessReceivedCommands+0xdc>
					{
						xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xMessage.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
 8003506:	68fa      	ldr	r2, [r7, #12]
 8003508:	69bb      	ldr	r3, [r7, #24]
 800350a:	699b      	ldr	r3, [r3, #24]
 800350c:	18d3      	adds	r3, r2, r3
 800350e:	f04f 0200 	mov.w	r2, #0
 8003512:	9200      	str	r2, [sp, #0]
 8003514:	69b8      	ldr	r0, [r7, #24]
 8003516:	f04f 0100 	mov.w	r1, #0
 800351a:	461a      	mov	r2, r3
 800351c:	f04f 0300 	mov.w	r3, #0
 8003520:	f7ff fe34 	bl	800318c <xTimerGenericCommand>
 8003524:	6178      	str	r0, [r7, #20]
						configASSERT( xResult );
 8003526:	697b      	ldr	r3, [r7, #20]
 8003528:	2b00      	cmp	r3, #0
 800352a:	d11d      	bne.n	8003568 <prvProcessReceivedCommands+0xdc>
 800352c:	f7fd fb44 	bl	8000bb8 <ulPortSetInterruptMask>
 8003530:	e7fe      	b.n	8003530 <prvProcessReceivedCommands+0xa4>
				/* The timer has already been removed from the active list.
				There is nothing to do here. */
				break;

			case tmrCOMMAND_CHANGE_PERIOD :
				pxTimer->xTimerPeriodInTicks = xMessage.xMessageValue;
 8003532:	68fa      	ldr	r2, [r7, #12]
 8003534:	69bb      	ldr	r3, [r7, #24]
 8003536:	619a      	str	r2, [r3, #24]
				configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
 8003538:	69bb      	ldr	r3, [r7, #24]
 800353a:	699b      	ldr	r3, [r3, #24]
 800353c:	2b00      	cmp	r3, #0
 800353e:	d102      	bne.n	8003546 <prvProcessReceivedCommands+0xba>
 8003540:	f7fd fb3a 	bl	8000bb8 <ulPortSetInterruptMask>
 8003544:	e7fe      	b.n	8003544 <prvProcessReceivedCommands+0xb8>
				prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
 8003546:	69bb      	ldr	r3, [r7, #24]
 8003548:	699a      	ldr	r2, [r3, #24]
 800354a:	69fb      	ldr	r3, [r7, #28]
 800354c:	18d3      	adds	r3, r2, r3
 800354e:	69b8      	ldr	r0, [r7, #24]
 8003550:	4619      	mov	r1, r3
 8003552:	69fa      	ldr	r2, [r7, #28]
 8003554:	69fb      	ldr	r3, [r7, #28]
 8003556:	f7ff ff4f 	bl	80033f8 <prvInsertTimerInActiveList>
				break;
 800355a:	e006      	b.n	800356a <prvProcessReceivedCommands+0xde>

			case tmrCOMMAND_DELETE :
				/* The timer has already been removed from the active list,
				just free up the memory. */
				vPortFree( pxTimer );
 800355c:	69b8      	ldr	r0, [r7, #24]
 800355e:	f7fc ff0f 	bl	8000380 <vPortFree>
				break;
 8003562:	e002      	b.n	800356a <prvProcessReceivedCommands+0xde>

			default	:
				/* Don't expect to get here. */
				break;
 8003564:	bf00      	nop
 8003566:	e000      	b.n	800356a <prvProcessReceivedCommands+0xde>
						xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xMessage.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
						configASSERT( xResult );
						( void ) xResult;
					}
				}
				break;
 8003568:	bf00      	nop

	/* In this case the xTimerListsWereSwitched parameter is not used, but it
	must be present in the function call. */
	xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL )
 800356a:	f642 630c 	movw	r3, #11788	; 0x2e0c
 800356e:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8003572:	681a      	ldr	r2, [r3, #0]
 8003574:	f107 0308 	add.w	r3, r7, #8
 8003578:	4610      	mov	r0, r2
 800357a:	4619      	mov	r1, r3
 800357c:	f04f 0200 	mov.w	r2, #0
 8003580:	f04f 0300 	mov.w	r3, #0
 8003584:	f7fd fe10 	bl	80011a8 <xQueueGenericReceive>
 8003588:	4603      	mov	r3, r0
 800358a:	2b00      	cmp	r3, #0
 800358c:	d188      	bne.n	80034a0 <prvProcessReceivedCommands+0x14>
			default	:
				/* Don't expect to get here. */
				break;
		}
	}
}
 800358e:	f107 0720 	add.w	r7, r7, #32
 8003592:	46bd      	mov	sp, r7
 8003594:	bd80      	pop	{r7, pc}
 8003596:	bf00      	nop

08003598 <prvSwitchTimerLists>:
/*-----------------------------------------------------------*/

static void prvSwitchTimerLists( portTickType xLastTime )
{
 8003598:	b580      	push	{r7, lr}
 800359a:	b08a      	sub	sp, #40	; 0x28
 800359c:	af02      	add	r7, sp, #8
 800359e:	6078      	str	r0, [r7, #4]

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 80035a0:	e04b      	b.n	800363a <prvSwitchTimerLists+0xa2>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 80035a2:	f642 6304 	movw	r3, #11780	; 0x2e04
 80035a6:	f2c2 0301 	movt	r3, #8193	; 0x2001
 80035aa:	681b      	ldr	r3, [r3, #0]
 80035ac:	68db      	ldr	r3, [r3, #12]
 80035ae:	681b      	ldr	r3, [r3, #0]
 80035b0:	61fb      	str	r3, [r7, #28]

		/* Remove the timer from the list. */
		pxTimer = ( xTIMER * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
 80035b2:	f642 6304 	movw	r3, #11780	; 0x2e04
 80035b6:	f2c2 0301 	movt	r3, #8193	; 0x2001
 80035ba:	681b      	ldr	r3, [r3, #0]
 80035bc:	68db      	ldr	r3, [r3, #12]
 80035be:	68db      	ldr	r3, [r3, #12]
 80035c0:	61bb      	str	r3, [r7, #24]
		uxListRemove( &( pxTimer->xTimerListItem ) );
 80035c2:	69bb      	ldr	r3, [r7, #24]
 80035c4:	f103 0304 	add.w	r3, r3, #4
 80035c8:	4618      	mov	r0, r3
 80035ca:	f7fc ffe5 	bl	8000598 <uxListRemove>

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
 80035ce:	69bb      	ldr	r3, [r7, #24]
 80035d0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80035d2:	69b8      	ldr	r0, [r7, #24]
 80035d4:	4798      	blx	r3

		if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
 80035d6:	69bb      	ldr	r3, [r7, #24]
 80035d8:	69db      	ldr	r3, [r3, #28]
 80035da:	2b01      	cmp	r3, #1
 80035dc:	d12d      	bne.n	800363a <prvSwitchTimerLists+0xa2>
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
 80035de:	69bb      	ldr	r3, [r7, #24]
 80035e0:	699a      	ldr	r2, [r3, #24]
 80035e2:	69fb      	ldr	r3, [r7, #28]
 80035e4:	18d3      	adds	r3, r2, r3
 80035e6:	617b      	str	r3, [r7, #20]
			if( xReloadTime > xNextExpireTime )
 80035e8:	697a      	ldr	r2, [r7, #20]
 80035ea:	69fb      	ldr	r3, [r7, #28]
 80035ec:	429a      	cmp	r2, r3
 80035ee:	d912      	bls.n	8003616 <prvSwitchTimerLists+0x7e>
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
 80035f0:	69bb      	ldr	r3, [r7, #24]
 80035f2:	697a      	ldr	r2, [r7, #20]
 80035f4:	605a      	str	r2, [r3, #4]
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 80035f6:	69bb      	ldr	r3, [r7, #24]
 80035f8:	69ba      	ldr	r2, [r7, #24]
 80035fa:	611a      	str	r2, [r3, #16]
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 80035fc:	f642 6304 	movw	r3, #11780	; 0x2e04
 8003600:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8003604:	681a      	ldr	r2, [r3, #0]
 8003606:	69bb      	ldr	r3, [r7, #24]
 8003608:	f103 0304 	add.w	r3, r3, #4
 800360c:	4610      	mov	r0, r2
 800360e:	4619      	mov	r1, r3
 8003610:	f7fc ff88 	bl	8000524 <vListInsert>
 8003614:	e011      	b.n	800363a <prvSwitchTimerLists+0xa2>
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xNextExpireTime, NULL, tmrNO_DELAY );
 8003616:	f04f 0300 	mov.w	r3, #0
 800361a:	9300      	str	r3, [sp, #0]
 800361c:	69b8      	ldr	r0, [r7, #24]
 800361e:	f04f 0100 	mov.w	r1, #0
 8003622:	69fa      	ldr	r2, [r7, #28]
 8003624:	f04f 0300 	mov.w	r3, #0
 8003628:	f7ff fdb0 	bl	800318c <xTimerGenericCommand>
 800362c:	6138      	str	r0, [r7, #16]
				configASSERT( xResult );
 800362e:	693b      	ldr	r3, [r7, #16]
 8003630:	2b00      	cmp	r3, #0
 8003632:	d102      	bne.n	800363a <prvSwitchTimerLists+0xa2>
 8003634:	f7fd fac0 	bl	8000bb8 <ulPortSetInterruptMask>
 8003638:	e7fe      	b.n	8003638 <prvSwitchTimerLists+0xa0>

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 800363a:	f642 6304 	movw	r3, #11780	; 0x2e04
 800363e:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8003642:	681b      	ldr	r3, [r3, #0]
 8003644:	681b      	ldr	r3, [r3, #0]
 8003646:	2b00      	cmp	r3, #0
 8003648:	d1ab      	bne.n	80035a2 <prvSwitchTimerLists+0xa>
				( void ) xResult;
			}
		}
	}

	pxTemp = pxCurrentTimerList;
 800364a:	f642 6304 	movw	r3, #11780	; 0x2e04
 800364e:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8003652:	681b      	ldr	r3, [r3, #0]
 8003654:	60fb      	str	r3, [r7, #12]
	pxCurrentTimerList = pxOverflowTimerList;
 8003656:	f642 6308 	movw	r3, #11784	; 0x2e08
 800365a:	f2c2 0301 	movt	r3, #8193	; 0x2001
 800365e:	681a      	ldr	r2, [r3, #0]
 8003660:	f642 6304 	movw	r3, #11780	; 0x2e04
 8003664:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8003668:	601a      	str	r2, [r3, #0]
	pxOverflowTimerList = pxTemp;
 800366a:	f642 6308 	movw	r3, #11784	; 0x2e08
 800366e:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8003672:	68fa      	ldr	r2, [r7, #12]
 8003674:	601a      	str	r2, [r3, #0]
}
 8003676:	f107 0720 	add.w	r7, r7, #32
 800367a:	46bd      	mov	sp, r7
 800367c:	bd80      	pop	{r7, pc}
 800367e:	bf00      	nop

08003680 <prvCheckForValidListAndQueue>:
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue( void )
{
 8003680:	b580      	push	{r7, lr}
 8003682:	af00      	add	r7, sp, #0
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
 8003684:	f7fd fa6c 	bl	8000b60 <vPortEnterCritical>
	{
		if( xTimerQueue == NULL )
 8003688:	f642 630c 	movw	r3, #11788	; 0x2e0c
 800368c:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8003690:	681b      	ldr	r3, [r3, #0]
 8003692:	2b00      	cmp	r3, #0
 8003694:	d12b      	bne.n	80036ee <prvCheckForValidListAndQueue+0x6e>
		{
			vListInitialise( &xActiveTimerList1 );
 8003696:	f642 50dc 	movw	r0, #11740	; 0x2ddc
 800369a:	f2c2 0001 	movt	r0, #8193	; 0x2001
 800369e:	f7fc feeb 	bl	8000478 <vListInitialise>
			vListInitialise( &xActiveTimerList2 );
 80036a2:	f642 50f0 	movw	r0, #11760	; 0x2df0
 80036a6:	f2c2 0001 	movt	r0, #8193	; 0x2001
 80036aa:	f7fc fee5 	bl	8000478 <vListInitialise>
			pxCurrentTimerList = &xActiveTimerList1;
 80036ae:	f642 6304 	movw	r3, #11780	; 0x2e04
 80036b2:	f2c2 0301 	movt	r3, #8193	; 0x2001
 80036b6:	f642 52dc 	movw	r2, #11740	; 0x2ddc
 80036ba:	f2c2 0201 	movt	r2, #8193	; 0x2001
 80036be:	601a      	str	r2, [r3, #0]
			pxOverflowTimerList = &xActiveTimerList2;
 80036c0:	f642 6308 	movw	r3, #11784	; 0x2e08
 80036c4:	f2c2 0301 	movt	r3, #8193	; 0x2001
 80036c8:	f642 52f0 	movw	r2, #11760	; 0x2df0
 80036cc:	f2c2 0201 	movt	r2, #8193	; 0x2001
 80036d0:	601a      	str	r2, [r3, #0]
			xTimerQueue = xQueueCreate( ( unsigned portBASE_TYPE ) configTIMER_QUEUE_LENGTH, sizeof( xTIMER_MESSAGE ) );
 80036d2:	f04f 000a 	mov.w	r0, #10
 80036d6:	f04f 010c 	mov.w	r1, #12
 80036da:	f04f 0200 	mov.w	r2, #0
 80036de:	f7fd fb3d 	bl	8000d5c <xQueueGenericCreate>
 80036e2:	4602      	mov	r2, r0
 80036e4:	f642 630c 	movw	r3, #11788	; 0x2e0c
 80036e8:	f2c2 0301 	movt	r3, #8193	; 0x2001
 80036ec:	601a      	str	r2, [r3, #0]
		}
	}
	taskEXIT_CRITICAL();
 80036ee:	f7fd fa49 	bl	8000b84 <vPortExitCritical>
}
 80036f2:	bd80      	pop	{r7, pc}

080036f4 <xTimerIsTimerActive>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTimerIsTimerActive( xTimerHandle xTimer )
{
 80036f4:	b580      	push	{r7, lr}
 80036f6:	b084      	sub	sp, #16
 80036f8:	af00      	add	r7, sp, #0
 80036fa:	6078      	str	r0, [r7, #4]
portBASE_TYPE xTimerIsInActiveList;
xTIMER *pxTimer = ( xTIMER * ) xTimer;
 80036fc:	687b      	ldr	r3, [r7, #4]
 80036fe:	60fb      	str	r3, [r7, #12]

	/* Is the timer in the list of active timers? */
	taskENTER_CRITICAL();
 8003700:	f7fd fa2e 	bl	8000b60 <vPortEnterCritical>
	{
		/* Checking to see if it is in the NULL list in effect checks to see if
		it is referenced from either the current or the overflow timer lists in
		one go, but the logic has to be reversed, hence the '!'. */
		xTimerIsInActiveList = !( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) );
 8003704:	68fb      	ldr	r3, [r7, #12]
 8003706:	695b      	ldr	r3, [r3, #20]
 8003708:	2b00      	cmp	r3, #0
 800370a:	bf0c      	ite	eq
 800370c:	2300      	moveq	r3, #0
 800370e:	2301      	movne	r3, #1
 8003710:	b2db      	uxtb	r3, r3
 8003712:	60bb      	str	r3, [r7, #8]
	}
	taskEXIT_CRITICAL();
 8003714:	f7fd fa36 	bl	8000b84 <vPortExitCritical>

	return xTimerIsInActiveList;
 8003718:	68bb      	ldr	r3, [r7, #8]
}
 800371a:	4618      	mov	r0, r3
 800371c:	f107 0710 	add.w	r7, r7, #16
 8003720:	46bd      	mov	sp, r7
 8003722:	bd80      	pop	{r7, pc}

08003724 <pvTimerGetTimerID>:
/*-----------------------------------------------------------*/

void *pvTimerGetTimerID( xTimerHandle xTimer )
{
 8003724:	b480      	push	{r7}
 8003726:	b085      	sub	sp, #20
 8003728:	af00      	add	r7, sp, #0
 800372a:	6078      	str	r0, [r7, #4]
xTIMER *pxTimer = ( xTIMER * ) xTimer;
 800372c:	687b      	ldr	r3, [r7, #4]
 800372e:	60fb      	str	r3, [r7, #12]

	return pxTimer->pvTimerID;
 8003730:	68fb      	ldr	r3, [r7, #12]
 8003732:	6a1b      	ldr	r3, [r3, #32]
}
 8003734:	4618      	mov	r0, r3
 8003736:	f107 0714 	add.w	r7, r7, #20
 800373a:	46bd      	mov	sp, r7
 800373c:	bc80      	pop	{r7}
 800373e:	4770      	bx	lr

08003740 <Reset_Handler>:
  .weak  Reset_Handler
  .type  Reset_Handler, %function

Reset_Handler:  
/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
 8003740:	2100      	movs	r1, #0
  b  LoopCopyDataInit
 8003742:	f000 b804 	b.w	800374e <LoopCopyDataInit>

08003746 <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
 8003746:	4b0f      	ldr	r3, [pc, #60]	; (8003784 <LoopFillZerobss+0x1e>)
  ldr  r3, [r3, r1]
 8003748:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
 800374a:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
 800374c:	3104      	adds	r1, #4

0800374e <LoopCopyDataInit>:
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 800374e:	480e      	ldr	r0, [pc, #56]	; (8003788 <LoopFillZerobss+0x22>)
  ldr  r3, =_edata
 8003750:	4b0e      	ldr	r3, [pc, #56]	; (800378c <LoopFillZerobss+0x26>)
  adds  r2, r0, r1
 8003752:	1842      	adds	r2, r0, r1
  cmp  r2, r3
 8003754:	429a      	cmp	r2, r3
  bcc  CopyDataInit
 8003756:	f4ff aff6 	bcc.w	8003746 <CopyDataInit>
  ldr  r2, =_sbss
 800375a:	4a0d      	ldr	r2, [pc, #52]	; (8003790 <LoopFillZerobss+0x2a>)
  b  LoopFillZerobss
 800375c:	f000 b803 	b.w	8003766 <LoopFillZerobss>

08003760 <FillZerobss>:

/* Zero fill the bss segment. */  
FillZerobss:
  movs  r3, #0
 8003760:	2300      	movs	r3, #0
  str  r3, [r2], #4
 8003762:	f842 3b04 	str.w	r3, [r2], #4

08003766 <LoopFillZerobss>:
    
LoopFillZerobss:
  ldr  r3, = _ebss
 8003766:	4b0b      	ldr	r3, [pc, #44]	; (8003794 <LoopFillZerobss+0x2e>)
  cmp  r2, r3
 8003768:	429a      	cmp	r2, r3
  bcc  FillZerobss
 800376a:	f4ff aff9 	bcc.w	8003760 <FillZerobss>

/* FPU settings */
/* Enable CP10,CP11: Privileged and User mode access to coprocessor */
 ldr     r0, =0xE000ED88           
 800376e:	480a      	ldr	r0, [pc, #40]	; (8003798 <LoopFillZerobss+0x32>)
 ldr     r1,[r0]
 8003770:	6801      	ldr	r1, [r0, #0]
 orr     r1,r1,#(0xF << 20)
 8003772:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 str     r1,[r0]
 8003776:	6001      	str	r1, [r0, #0]

/* TODO: Add stack painting here */

/* Call the clock system intitialization function.*/
  bl  low_level_init   
 8003778:	f7fc ff3a 	bl	80005f0 <low_level_init>

/* Call the application's entry point.*/
  bl  main  /* Enter the C/C++ code */
 800377c:	f7fd f866 	bl	800084c <main>
  bx  lr    
 8003780:	4770      	bx	lr
  swi 0x0  /* cause exception if main() ever returns */
 8003782:	df00      	svc	0
/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
  b  LoopCopyDataInit

CopyDataInit:
  ldr  r3, =_sidata
 8003784:	0800436d 	.word	0x0800436d
  ldr  r3, [r3, r1]
  str  r3, [r0, r1]
  adds  r1, r1, #4
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 8003788:	20000000 	.word	0x20000000
  ldr  r3, =_edata
 800378c:	20000090 	.word	0x20000090
  adds  r2, r0, r1
  cmp  r2, r3
  bcc  CopyDataInit
  ldr  r2, =_sbss
 8003790:	20000090 	.word	0x20000090
FillZerobss:
  movs  r3, #0
  str  r3, [r2], #4
    
LoopFillZerobss:
  ldr  r3, = _ebss
 8003794:	20012e5c 	.word	0x20012e5c
  cmp  r2, r3
  bcc  FillZerobss

/* FPU settings */
/* Enable CP10,CP11: Privileged and User mode access to coprocessor */
 ldr     r0, =0xE000ED88           
 8003798:	e000ed88 	.word	0xe000ed88

0800379c <ADC_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 800379c:	f7ff bffe 	b.w	800379c <ADC_IRQHandler>

080037a0 <rcc_wait_for_osc_ready>:
 80037a0:	2804      	cmp	r0, #4
 80037a2:	d81c      	bhi.n	80037de <rcc_wait_for_osc_ready+0x3e>
 80037a4:	e8df f000 	tbb	[pc, r0]
 80037a8:	120d0803 	.word	0x120d0803
 80037ac:	17          	.byte	0x17
 80037ad:	00          	.byte	0x00
 80037ae:	4b0c      	ldr	r3, [pc, #48]	; (80037e0 <rcc_wait_for_osc_ready+0x40>)
 80037b0:	6818      	ldr	r0, [r3, #0]
 80037b2:	0183      	lsls	r3, r0, #6
 80037b4:	d5fb      	bpl.n	80037ae <rcc_wait_for_osc_ready+0xe>
 80037b6:	4770      	bx	lr
 80037b8:	4909      	ldr	r1, [pc, #36]	; (80037e0 <rcc_wait_for_osc_ready+0x40>)
 80037ba:	680a      	ldr	r2, [r1, #0]
 80037bc:	0390      	lsls	r0, r2, #14
 80037be:	d5fb      	bpl.n	80037b8 <rcc_wait_for_osc_ready+0x18>
 80037c0:	4770      	bx	lr
 80037c2:	4b07      	ldr	r3, [pc, #28]	; (80037e0 <rcc_wait_for_osc_ready+0x40>)
 80037c4:	6818      	ldr	r0, [r3, #0]
 80037c6:	0781      	lsls	r1, r0, #30
 80037c8:	d5fb      	bpl.n	80037c2 <rcc_wait_for_osc_ready+0x22>
 80037ca:	4770      	bx	lr
 80037cc:	4905      	ldr	r1, [pc, #20]	; (80037e4 <rcc_wait_for_osc_ready+0x44>)
 80037ce:	680a      	ldr	r2, [r1, #0]
 80037d0:	0792      	lsls	r2, r2, #30
 80037d2:	d5fb      	bpl.n	80037cc <rcc_wait_for_osc_ready+0x2c>
 80037d4:	4770      	bx	lr
 80037d6:	4b04      	ldr	r3, [pc, #16]	; (80037e8 <rcc_wait_for_osc_ready+0x48>)
 80037d8:	6818      	ldr	r0, [r3, #0]
 80037da:	0783      	lsls	r3, r0, #30
 80037dc:	d5fb      	bpl.n	80037d6 <rcc_wait_for_osc_ready+0x36>
 80037de:	4770      	bx	lr
 80037e0:	40023800 	.word	0x40023800
 80037e4:	40023870 	.word	0x40023870
 80037e8:	40023874 	.word	0x40023874

080037ec <rcc_wait_for_sysclk_status>:
 80037ec:	2801      	cmp	r0, #1
 80037ee:	d00a      	beq.n	8003806 <rcc_wait_for_sysclk_status+0x1a>
 80037f0:	d302      	bcc.n	80037f8 <rcc_wait_for_sysclk_status+0xc>
 80037f2:	2802      	cmp	r0, #2
 80037f4:	d112      	bne.n	800381c <rcc_wait_for_sysclk_status+0x30>
 80037f6:	e00d      	b.n	8003814 <rcc_wait_for_sysclk_status+0x28>
 80037f8:	4909      	ldr	r1, [pc, #36]	; (8003820 <rcc_wait_for_sysclk_status+0x34>)
 80037fa:	680a      	ldr	r2, [r1, #0]
 80037fc:	f002 0303 	and.w	r3, r2, #3
 8003800:	2b02      	cmp	r3, #2
 8003802:	d1f9      	bne.n	80037f8 <rcc_wait_for_sysclk_status+0xc>
 8003804:	4770      	bx	lr
 8003806:	4806      	ldr	r0, [pc, #24]	; (8003820 <rcc_wait_for_sysclk_status+0x34>)
 8003808:	6801      	ldr	r1, [r0, #0]
 800380a:	f001 0203 	and.w	r2, r1, #3
 800380e:	2a01      	cmp	r2, #1
 8003810:	d1f9      	bne.n	8003806 <rcc_wait_for_sysclk_status+0x1a>
 8003812:	4770      	bx	lr
 8003814:	4b02      	ldr	r3, [pc, #8]	; (8003820 <rcc_wait_for_sysclk_status+0x34>)
 8003816:	6818      	ldr	r0, [r3, #0]
 8003818:	0782      	lsls	r2, r0, #30
 800381a:	d1fb      	bne.n	8003814 <rcc_wait_for_sysclk_status+0x28>
 800381c:	4770      	bx	lr
 800381e:	bf00      	nop
 8003820:	40023808 	.word	0x40023808

08003824 <rcc_osc_on>:
 8003824:	2804      	cmp	r0, #4
 8003826:	d817      	bhi.n	8003858 <rcc_osc_on+0x34>
 8003828:	e8df f000 	tbb	[pc, r0]
 800382c:	0f0d0803 	.word	0x0f0d0803
 8003830:	11          	.byte	0x11
 8003831:	00          	.byte	0x00
 8003832:	4b0a      	ldr	r3, [pc, #40]	; (800385c <rcc_osc_on+0x38>)
 8003834:	681a      	ldr	r2, [r3, #0]
 8003836:	f042 7080 	orr.w	r0, r2, #16777216	; 0x1000000
 800383a:	e00c      	b.n	8003856 <rcc_osc_on+0x32>
 800383c:	4b07      	ldr	r3, [pc, #28]	; (800385c <rcc_osc_on+0x38>)
 800383e:	6819      	ldr	r1, [r3, #0]
 8003840:	f441 3080 	orr.w	r0, r1, #65536	; 0x10000
 8003844:	e007      	b.n	8003856 <rcc_osc_on+0x32>
 8003846:	4b05      	ldr	r3, [pc, #20]	; (800385c <rcc_osc_on+0x38>)
 8003848:	e002      	b.n	8003850 <rcc_osc_on+0x2c>
 800384a:	4b05      	ldr	r3, [pc, #20]	; (8003860 <rcc_osc_on+0x3c>)
 800384c:	e000      	b.n	8003850 <rcc_osc_on+0x2c>
 800384e:	4b05      	ldr	r3, [pc, #20]	; (8003864 <rcc_osc_on+0x40>)
 8003850:	681a      	ldr	r2, [r3, #0]
 8003852:	f042 0001 	orr.w	r0, r2, #1
 8003856:	6018      	str	r0, [r3, #0]
 8003858:	4770      	bx	lr
 800385a:	bf00      	nop
 800385c:	40023800 	.word	0x40023800
 8003860:	40023870 	.word	0x40023870
 8003864:	40023874 	.word	0x40023874

08003868 <rcc_osc_off>:
 8003868:	2804      	cmp	r0, #4
 800386a:	d817      	bhi.n	800389c <rcc_osc_off+0x34>
 800386c:	e8df f000 	tbb	[pc, r0]
 8003870:	0f0d0803 	.word	0x0f0d0803
 8003874:	11          	.byte	0x11
 8003875:	00          	.byte	0x00
 8003876:	4b0a      	ldr	r3, [pc, #40]	; (80038a0 <rcc_osc_off+0x38>)
 8003878:	681a      	ldr	r2, [r3, #0]
 800387a:	f022 7080 	bic.w	r0, r2, #16777216	; 0x1000000
 800387e:	e00c      	b.n	800389a <rcc_osc_off+0x32>
 8003880:	4b07      	ldr	r3, [pc, #28]	; (80038a0 <rcc_osc_off+0x38>)
 8003882:	6819      	ldr	r1, [r3, #0]
 8003884:	f421 3080 	bic.w	r0, r1, #65536	; 0x10000
 8003888:	e007      	b.n	800389a <rcc_osc_off+0x32>
 800388a:	4b05      	ldr	r3, [pc, #20]	; (80038a0 <rcc_osc_off+0x38>)
 800388c:	e002      	b.n	8003894 <rcc_osc_off+0x2c>
 800388e:	4b05      	ldr	r3, [pc, #20]	; (80038a4 <rcc_osc_off+0x3c>)
 8003890:	e000      	b.n	8003894 <rcc_osc_off+0x2c>
 8003892:	4b05      	ldr	r3, [pc, #20]	; (80038a8 <rcc_osc_off+0x40>)
 8003894:	681a      	ldr	r2, [r3, #0]
 8003896:	f022 0001 	bic.w	r0, r2, #1
 800389a:	6018      	str	r0, [r3, #0]
 800389c:	4770      	bx	lr
 800389e:	bf00      	nop
 80038a0:	40023800 	.word	0x40023800
 80038a4:	40023870 	.word	0x40023870
 80038a8:	40023874 	.word	0x40023874

080038ac <rcc_peripheral_enable_clock>:
 80038ac:	6803      	ldr	r3, [r0, #0]
 80038ae:	4319      	orrs	r1, r3
 80038b0:	6001      	str	r1, [r0, #0]
 80038b2:	4770      	bx	lr

080038b4 <rcc_set_sysclk_source>:
 80038b4:	4b03      	ldr	r3, [pc, #12]	; (80038c4 <rcc_set_sysclk_source+0x10>)
 80038b6:	681a      	ldr	r2, [r3, #0]
 80038b8:	f022 0103 	bic.w	r1, r2, #3
 80038bc:	4308      	orrs	r0, r1
 80038be:	6018      	str	r0, [r3, #0]
 80038c0:	4770      	bx	lr
 80038c2:	bf00      	nop
 80038c4:	40023808 	.word	0x40023808

080038c8 <rcc_set_ppre2>:
 80038c8:	4b03      	ldr	r3, [pc, #12]	; (80038d8 <rcc_set_ppre2+0x10>)
 80038ca:	681a      	ldr	r2, [r3, #0]
 80038cc:	f422 4160 	bic.w	r1, r2, #57344	; 0xe000
 80038d0:	ea41 3040 	orr.w	r0, r1, r0, lsl #13
 80038d4:	6018      	str	r0, [r3, #0]
 80038d6:	4770      	bx	lr
 80038d8:	40023808 	.word	0x40023808

080038dc <rcc_set_ppre1>:
 80038dc:	4b03      	ldr	r3, [pc, #12]	; (80038ec <rcc_set_ppre1+0x10>)
 80038de:	681a      	ldr	r2, [r3, #0]
 80038e0:	f422 51e0 	bic.w	r1, r2, #7168	; 0x1c00
 80038e4:	ea41 2080 	orr.w	r0, r1, r0, lsl #10
 80038e8:	6018      	str	r0, [r3, #0]
 80038ea:	4770      	bx	lr
 80038ec:	40023808 	.word	0x40023808

080038f0 <rcc_set_hpre>:
 80038f0:	4b03      	ldr	r3, [pc, #12]	; (8003900 <rcc_set_hpre+0x10>)
 80038f2:	681a      	ldr	r2, [r3, #0]
 80038f4:	f022 01f0 	bic.w	r1, r2, #240	; 0xf0
 80038f8:	ea41 1000 	orr.w	r0, r1, r0, lsl #4
 80038fc:	6018      	str	r0, [r3, #0]
 80038fe:	4770      	bx	lr
 8003900:	40023808 	.word	0x40023808

08003904 <rcc_set_main_pll_hse>:
 8003904:	f440 0080 	orr.w	r0, r0, #4194304	; 0x400000
 8003908:	ea40 1181 	orr.w	r1, r0, r1, lsl #6
 800390c:	0852      	lsrs	r2, r2, #1
 800390e:	ea41 6303 	orr.w	r3, r1, r3, lsl #24
 8003912:	1e50      	subs	r0, r2, #1
 8003914:	ea43 4100 	orr.w	r1, r3, r0, lsl #16
 8003918:	4b01      	ldr	r3, [pc, #4]	; (8003920 <rcc_set_main_pll_hse+0x1c>)
 800391a:	6019      	str	r1, [r3, #0]
 800391c:	4770      	bx	lr
 800391e:	bf00      	nop
 8003920:	40023804 	.word	0x40023804

08003924 <rcc_clock_setup_hse_3v3>:
 8003924:	b510      	push	{r4, lr}
 8003926:	4604      	mov	r4, r0
 8003928:	2002      	movs	r0, #2
 800392a:	f7ff ff7b 	bl	8003824 <rcc_osc_on>
 800392e:	2002      	movs	r0, #2
 8003930:	f7ff ff36 	bl	80037a0 <rcc_wait_for_osc_ready>
 8003934:	2000      	movs	r0, #0
 8003936:	f7ff ffbd 	bl	80038b4 <rcc_set_sysclk_source>
 800393a:	2001      	movs	r0, #1
 800393c:	f7ff ff72 	bl	8003824 <rcc_osc_on>
 8003940:	2001      	movs	r0, #1
 8003942:	f7ff ff2d 	bl	80037a0 <rcc_wait_for_osc_ready>
 8003946:	7be0      	ldrb	r0, [r4, #15]
 8003948:	b100      	cbz	r0, 800394c <rcc_clock_setup_hse_3v3+0x28>
 800394a:	2001      	movs	r0, #1
 800394c:	f000 f864 	bl	8003a18 <pwr_set_vos_scale>
 8003950:	7b20      	ldrb	r0, [r4, #12]
 8003952:	f7ff ffcd 	bl	80038f0 <rcc_set_hpre>
 8003956:	7b60      	ldrb	r0, [r4, #13]
 8003958:	f7ff ffc0 	bl	80038dc <rcc_set_ppre1>
 800395c:	7ba0      	ldrb	r0, [r4, #14]
 800395e:	f7ff ffb3 	bl	80038c8 <rcc_set_ppre2>
 8003962:	7820      	ldrb	r0, [r4, #0]
 8003964:	7922      	ldrb	r2, [r4, #4]
 8003966:	7963      	ldrb	r3, [r4, #5]
 8003968:	8861      	ldrh	r1, [r4, #2]
 800396a:	f7ff ffcb 	bl	8003904 <rcc_set_main_pll_hse>
 800396e:	4b0e      	ldr	r3, [pc, #56]	; (80039a8 <rcc_clock_setup_hse_3v3+0x84>)
 8003970:	681a      	ldr	r2, [r3, #0]
 8003972:	f042 7080 	orr.w	r0, r2, #16777216	; 0x1000000
 8003976:	6018      	str	r0, [r3, #0]
 8003978:	6819      	ldr	r1, [r3, #0]
 800397a:	0189      	lsls	r1, r1, #6
 800397c:	d5fc      	bpl.n	8003978 <rcc_clock_setup_hse_3v3+0x54>
 800397e:	68a0      	ldr	r0, [r4, #8]
 8003980:	f000 f840 	bl	8003a04 <flash_set_ws>
 8003984:	2002      	movs	r0, #2
 8003986:	f7ff ff95 	bl	80038b4 <rcc_set_sysclk_source>
 800398a:	2000      	movs	r0, #0
 800398c:	f7ff ff2e 	bl	80037ec <rcc_wait_for_sysclk_status>
 8003990:	6960      	ldr	r0, [r4, #20]
 8003992:	4906      	ldr	r1, [pc, #24]	; (80039ac <rcc_clock_setup_hse_3v3+0x88>)
 8003994:	6923      	ldr	r3, [r4, #16]
 8003996:	4a06      	ldr	r2, [pc, #24]	; (80039b0 <rcc_clock_setup_hse_3v3+0x8c>)
 8003998:	6008      	str	r0, [r1, #0]
 800399a:	2002      	movs	r0, #2
 800399c:	6013      	str	r3, [r2, #0]
 800399e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80039a2:	f7ff bf61 	b.w	8003868 <rcc_osc_off>
 80039a6:	bf00      	nop
 80039a8:	40023800 	.word	0x40023800
 80039ac:	20000024 	.word	0x20000024
 80039b0:	20000020 	.word	0x20000020

080039b4 <gpio_set>:
 80039b4:	6181      	str	r1, [r0, #24]
 80039b6:	4770      	bx	lr

080039b8 <gpio_clear>:
 80039b8:	0409      	lsls	r1, r1, #16
 80039ba:	6181      	str	r1, [r0, #24]
 80039bc:	4770      	bx	lr

080039be <gpio_mode_setup>:
 80039be:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80039c2:	6806      	ldr	r6, [r0, #0]
 80039c4:	68c5      	ldr	r5, [r0, #12]
 80039c6:	2400      	movs	r4, #0
 80039c8:	fa43 f704 	asr.w	r7, r3, r4
 80039cc:	f017 0f01 	tst.w	r7, #1
 80039d0:	d011      	beq.n	80039f6 <gpio_mode_setup+0x38>
 80039d2:	0067      	lsls	r7, r4, #1
 80039d4:	f04f 0c03 	mov.w	ip, #3
 80039d8:	fa0c f807 	lsl.w	r8, ip, r7
 80039dc:	ea6f 0c08 	mvn.w	ip, r8
 80039e0:	ea0c 0606 	and.w	r6, ip, r6
 80039e4:	fa01 f807 	lsl.w	r8, r1, r7
 80039e8:	ea0c 0505 	and.w	r5, ip, r5
 80039ec:	fa02 f707 	lsl.w	r7, r2, r7
 80039f0:	ea46 0608 	orr.w	r6, r6, r8
 80039f4:	433d      	orrs	r5, r7
 80039f6:	3401      	adds	r4, #1
 80039f8:	2c10      	cmp	r4, #16
 80039fa:	d1e5      	bne.n	80039c8 <gpio_mode_setup+0xa>
 80039fc:	6006      	str	r6, [r0, #0]
 80039fe:	60c5      	str	r5, [r0, #12]
 8003a00:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08003a04 <flash_set_ws>:
 8003a04:	4b03      	ldr	r3, [pc, #12]	; (8003a14 <flash_set_ws+0x10>)
 8003a06:	681a      	ldr	r2, [r3, #0]
 8003a08:	f022 0107 	bic.w	r1, r2, #7
 8003a0c:	4308      	orrs	r0, r1
 8003a0e:	6018      	str	r0, [r3, #0]
 8003a10:	4770      	bx	lr
 8003a12:	bf00      	nop
 8003a14:	40023c00 	.word	0x40023c00

08003a18 <pwr_set_vos_scale>:
 8003a18:	b920      	cbnz	r0, 8003a24 <pwr_set_vos_scale+0xc>
 8003a1a:	4b06      	ldr	r3, [pc, #24]	; (8003a34 <pwr_set_vos_scale+0x1c>)
 8003a1c:	6819      	ldr	r1, [r3, #0]
 8003a1e:	f441 4080 	orr.w	r0, r1, #16384	; 0x4000
 8003a22:	e005      	b.n	8003a30 <pwr_set_vos_scale+0x18>
 8003a24:	2801      	cmp	r0, #1
 8003a26:	d104      	bne.n	8003a32 <pwr_set_vos_scale+0x1a>
 8003a28:	4b02      	ldr	r3, [pc, #8]	; (8003a34 <pwr_set_vos_scale+0x1c>)
 8003a2a:	681a      	ldr	r2, [r3, #0]
 8003a2c:	f402 4080 	and.w	r0, r2, #16384	; 0x4000
 8003a30:	6018      	str	r0, [r3, #0]
 8003a32:	4770      	bx	lr
 8003a34:	40007000 	.word	0x40007000

08003a38 <__errno>:
 8003a38:	4b01      	ldr	r3, [pc, #4]	; (8003a40 <__errno+0x8>)
 8003a3a:	6818      	ldr	r0, [r3, #0]
 8003a3c:	4770      	bx	lr
 8003a3e:	bf00      	nop
 8003a40:	2000008c 	.word	0x2000008c

08003a44 <memcmp>:
 8003a44:	b530      	push	{r4, r5, lr}
 8003a46:	2300      	movs	r3, #0
 8003a48:	4293      	cmp	r3, r2
 8003a4a:	d008      	beq.n	8003a5e <memcmp+0x1a>
 8003a4c:	5cc5      	ldrb	r5, [r0, r3]
 8003a4e:	3301      	adds	r3, #1
 8003a50:	18cc      	adds	r4, r1, r3
 8003a52:	f814 4c01 	ldrb.w	r4, [r4, #-1]
 8003a56:	42a5      	cmp	r5, r4
 8003a58:	d0f6      	beq.n	8003a48 <memcmp+0x4>
 8003a5a:	1b28      	subs	r0, r5, r4
 8003a5c:	bd30      	pop	{r4, r5, pc}
 8003a5e:	2000      	movs	r0, #0
 8003a60:	bd30      	pop	{r4, r5, pc}

08003a62 <memcpy>:
 8003a62:	b510      	push	{r4, lr}
 8003a64:	2300      	movs	r3, #0
 8003a66:	4293      	cmp	r3, r2
 8003a68:	d003      	beq.n	8003a72 <memcpy+0x10>
 8003a6a:	5ccc      	ldrb	r4, [r1, r3]
 8003a6c:	54c4      	strb	r4, [r0, r3]
 8003a6e:	3301      	adds	r3, #1
 8003a70:	e7f9      	b.n	8003a66 <memcpy+0x4>
 8003a72:	bd10      	pop	{r4, pc}

08003a74 <memset>:
 8003a74:	1882      	adds	r2, r0, r2
 8003a76:	4603      	mov	r3, r0
 8003a78:	4293      	cmp	r3, r2
 8003a7a:	d002      	beq.n	8003a82 <memset+0xe>
 8003a7c:	f803 1b01 	strb.w	r1, [r3], #1
 8003a80:	e7fa      	b.n	8003a78 <memset+0x4>
 8003a82:	4770      	bx	lr

08003a84 <siprintf>:
 8003a84:	b40e      	push	{r1, r2, r3}
 8003a86:	b500      	push	{lr}
 8003a88:	b09c      	sub	sp, #112	; 0x70
 8003a8a:	ab1d      	add	r3, sp, #116	; 0x74
 8003a8c:	9002      	str	r0, [sp, #8]
 8003a8e:	9006      	str	r0, [sp, #24]
 8003a90:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
 8003a94:	9004      	str	r0, [sp, #16]
 8003a96:	9007      	str	r0, [sp, #28]
 8003a98:	f44f 7102 	mov.w	r1, #520	; 0x208
 8003a9c:	480a      	ldr	r0, [pc, #40]	; (8003ac8 <siprintf+0x44>)
 8003a9e:	f853 2b04 	ldr.w	r2, [r3], #4
 8003aa2:	f8ad 1014 	strh.w	r1, [sp, #20]
 8003aa6:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8003aaa:	f8ad 1016 	strh.w	r1, [sp, #22]
 8003aae:	6800      	ldr	r0, [r0, #0]
 8003ab0:	9301      	str	r3, [sp, #4]
 8003ab2:	a902      	add	r1, sp, #8
 8003ab4:	f000 f884 	bl	8003bc0 <_svfiprintf_r>
 8003ab8:	9b02      	ldr	r3, [sp, #8]
 8003aba:	2200      	movs	r2, #0
 8003abc:	701a      	strb	r2, [r3, #0]
 8003abe:	b01c      	add	sp, #112	; 0x70
 8003ac0:	f85d eb04 	ldr.w	lr, [sp], #4
 8003ac4:	b003      	add	sp, #12
 8003ac6:	4770      	bx	lr
 8003ac8:	2000008c 	.word	0x2000008c

08003acc <strcat>:
 8003acc:	b510      	push	{r4, lr}
 8003ace:	4604      	mov	r4, r0
 8003ad0:	4622      	mov	r2, r4
 8003ad2:	3401      	adds	r4, #1
 8003ad4:	7813      	ldrb	r3, [r2, #0]
 8003ad6:	2b00      	cmp	r3, #0
 8003ad8:	d1fa      	bne.n	8003ad0 <strcat+0x4>
 8003ada:	5ccc      	ldrb	r4, [r1, r3]
 8003adc:	54d4      	strb	r4, [r2, r3]
 8003ade:	3301      	adds	r3, #1
 8003ae0:	2c00      	cmp	r4, #0
 8003ae2:	d1fa      	bne.n	8003ada <strcat+0xe>
 8003ae4:	bd10      	pop	{r4, pc}

08003ae6 <strncpy>:
 8003ae6:	b530      	push	{r4, r5, lr}
 8003ae8:	3901      	subs	r1, #1
 8003aea:	4603      	mov	r3, r0
 8003aec:	461c      	mov	r4, r3
 8003aee:	b13a      	cbz	r2, 8003b00 <strncpy+0x1a>
 8003af0:	f811 5f01 	ldrb.w	r5, [r1, #1]!
 8003af4:	f803 5b01 	strb.w	r5, [r3], #1
 8003af8:	3a01      	subs	r2, #1
 8003afa:	461c      	mov	r4, r3
 8003afc:	2d00      	cmp	r5, #0
 8003afe:	d1f5      	bne.n	8003aec <strncpy+0x6>
 8003b00:	1899      	adds	r1, r3, r2
 8003b02:	428c      	cmp	r4, r1
 8003b04:	d003      	beq.n	8003b0e <strncpy+0x28>
 8003b06:	2200      	movs	r2, #0
 8003b08:	f804 2b01 	strb.w	r2, [r4], #1
 8003b0c:	e7f9      	b.n	8003b02 <strncpy+0x1c>
 8003b0e:	bd30      	pop	{r4, r5, pc}

08003b10 <__ssputc_r>:
 8003b10:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8003b14:	6893      	ldr	r3, [r2, #8]
 8003b16:	4606      	mov	r6, r0
 8003b18:	4689      	mov	r9, r1
 8003b1a:	4614      	mov	r4, r2
 8003b1c:	2b00      	cmp	r3, #0
 8003b1e:	d141      	bne.n	8003ba4 <__ssputc_r+0x94>
 8003b20:	8992      	ldrh	r2, [r2, #12]
 8003b22:	f412 6f90 	tst.w	r2, #1152	; 0x480
 8003b26:	d03d      	beq.n	8003ba4 <__ssputc_r+0x94>
 8003b28:	6961      	ldr	r1, [r4, #20]
 8003b2a:	6923      	ldr	r3, [r4, #16]
 8003b2c:	6827      	ldr	r7, [r4, #0]
 8003b2e:	2503      	movs	r5, #3
 8003b30:	2002      	movs	r0, #2
 8003b32:	434d      	muls	r5, r1
 8003b34:	1aff      	subs	r7, r7, r3
 8003b36:	fb95 f5f0 	sdiv	r5, r5, r0
 8003b3a:	1c79      	adds	r1, r7, #1
 8003b3c:	f402 6280 	and.w	r2, r2, #1024	; 0x400
 8003b40:	42a9      	cmp	r1, r5
 8003b42:	b211      	sxth	r1, r2
 8003b44:	bfa8      	it	ge
 8003b46:	183d      	addge	r5, r7, r0
 8003b48:	4630      	mov	r0, r6
 8003b4a:	b179      	cbz	r1, 8003b6c <__ssputc_r+0x5c>
 8003b4c:	4629      	mov	r1, r5
 8003b4e:	f000 fb09 	bl	8004164 <_malloc_r>
 8003b52:	4680      	mov	r8, r0
 8003b54:	b1a0      	cbz	r0, 8003b80 <__ssputc_r+0x70>
 8003b56:	463a      	mov	r2, r7
 8003b58:	6921      	ldr	r1, [r4, #16]
 8003b5a:	f7ff ff82 	bl	8003a62 <memcpy>
 8003b5e:	89a3      	ldrh	r3, [r4, #12]
 8003b60:	f423 6090 	bic.w	r0, r3, #1152	; 0x480
 8003b64:	f040 0280 	orr.w	r2, r0, #128	; 0x80
 8003b68:	81a2      	strh	r2, [r4, #12]
 8003b6a:	e013      	b.n	8003b94 <__ssputc_r+0x84>
 8003b6c:	4619      	mov	r1, r3
 8003b6e:	462a      	mov	r2, r5
 8003b70:	f000 fb50 	bl	8004214 <_realloc_r>
 8003b74:	4680      	mov	r8, r0
 8003b76:	b968      	cbnz	r0, 8003b94 <__ssputc_r+0x84>
 8003b78:	4630      	mov	r0, r6
 8003b7a:	6921      	ldr	r1, [r4, #16]
 8003b7c:	f000 faae 	bl	80040dc <_free_r>
 8003b80:	89a0      	ldrh	r0, [r4, #12]
 8003b82:	230c      	movs	r3, #12
 8003b84:	f040 0240 	orr.w	r2, r0, #64	; 0x40
 8003b88:	6033      	str	r3, [r6, #0]
 8003b8a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8003b8e:	81a2      	strh	r2, [r4, #12]
 8003b90:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8003b94:	eb08 0107 	add.w	r1, r8, r7
 8003b98:	6165      	str	r5, [r4, #20]
 8003b9a:	1bed      	subs	r5, r5, r7
 8003b9c:	f8c4 8010 	str.w	r8, [r4, #16]
 8003ba0:	6021      	str	r1, [r4, #0]
 8003ba2:	60a5      	str	r5, [r4, #8]
 8003ba4:	68a3      	ldr	r3, [r4, #8]
 8003ba6:	2b00      	cmp	r3, #0
 8003ba8:	dd06      	ble.n	8003bb8 <__ssputc_r+0xa8>
 8003baa:	6820      	ldr	r0, [r4, #0]
 8003bac:	f800 9b01 	strb.w	r9, [r0], #1
 8003bb0:	68a2      	ldr	r2, [r4, #8]
 8003bb2:	6020      	str	r0, [r4, #0]
 8003bb4:	1e51      	subs	r1, r2, #1
 8003bb6:	60a1      	str	r1, [r4, #8]
 8003bb8:	2000      	movs	r0, #0
 8003bba:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	...

08003bc0 <_svfiprintf_r>:
 8003bc0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8003bc4:	b09c      	sub	sp, #112	; 0x70
 8003bc6:	460d      	mov	r5, r1
 8003bc8:	9303      	str	r3, [sp, #12]
 8003bca:	898b      	ldrh	r3, [r1, #12]
 8003bcc:	f003 0180 	and.w	r1, r3, #128	; 0x80
 8003bd0:	4614      	mov	r4, r2
 8003bd2:	b20a      	sxth	r2, r1
 8003bd4:	4606      	mov	r6, r0
 8003bd6:	b162      	cbz	r2, 8003bf2 <_svfiprintf_r+0x32>
 8003bd8:	692b      	ldr	r3, [r5, #16]
 8003bda:	b953      	cbnz	r3, 8003bf2 <_svfiprintf_r+0x32>
 8003bdc:	2140      	movs	r1, #64	; 0x40
 8003bde:	f000 fac1 	bl	8004164 <_malloc_r>
 8003be2:	6028      	str	r0, [r5, #0]
 8003be4:	6128      	str	r0, [r5, #16]
 8003be6:	b910      	cbnz	r0, 8003bee <_svfiprintf_r+0x2e>
 8003be8:	210c      	movs	r1, #12
 8003bea:	6031      	str	r1, [r6, #0]
 8003bec:	e0d3      	b.n	8003d96 <_svfiprintf_r+0x1d6>
 8003bee:	2040      	movs	r0, #64	; 0x40
 8003bf0:	6168      	str	r0, [r5, #20]
 8003bf2:	2700      	movs	r7, #0
 8003bf4:	2120      	movs	r1, #32
 8003bf6:	2230      	movs	r2, #48	; 0x30
 8003bf8:	9709      	str	r7, [sp, #36]	; 0x24
 8003bfa:	f88d 1029 	strb.w	r1, [sp, #41]	; 0x29
 8003bfe:	f88d 202a 	strb.w	r2, [sp, #42]	; 0x2a
 8003c02:	4623      	mov	r3, r4
 8003c04:	461f      	mov	r7, r3
 8003c06:	f813 0b01 	ldrb.w	r0, [r3], #1
 8003c0a:	b928      	cbnz	r0, 8003c18 <_svfiprintf_r+0x58>
 8003c0c:	ebb7 0a04 	subs.w	sl, r7, r4
 8003c10:	d016      	beq.n	8003c40 <_svfiprintf_r+0x80>
 8003c12:	f04f 0900 	mov.w	r9, #0
 8003c16:	e00d      	b.n	8003c34 <_svfiprintf_r+0x74>
 8003c18:	2825      	cmp	r0, #37	; 0x25
 8003c1a:	d1f3      	bne.n	8003c04 <_svfiprintf_r+0x44>
 8003c1c:	e7f6      	b.n	8003c0c <_svfiprintf_r+0x4c>
 8003c1e:	4630      	mov	r0, r6
 8003c20:	f814 1009 	ldrb.w	r1, [r4, r9]
 8003c24:	462a      	mov	r2, r5
 8003c26:	f7ff ff73 	bl	8003b10 <__ssputc_r>
 8003c2a:	3001      	adds	r0, #1
 8003c2c:	f000 80ac 	beq.w	8003d88 <_svfiprintf_r+0x1c8>
 8003c30:	f109 0901 	add.w	r9, r9, #1
 8003c34:	45d1      	cmp	r9, sl
 8003c36:	dbf2      	blt.n	8003c1e <_svfiprintf_r+0x5e>
 8003c38:	9909      	ldr	r1, [sp, #36]	; 0x24
 8003c3a:	eb01 020a 	add.w	r2, r1, sl
 8003c3e:	9209      	str	r2, [sp, #36]	; 0x24
 8003c40:	783b      	ldrb	r3, [r7, #0]
 8003c42:	2b00      	cmp	r3, #0
 8003c44:	f000 80a0 	beq.w	8003d88 <_svfiprintf_r+0x1c8>
 8003c48:	2400      	movs	r4, #0
 8003c4a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8003c4e:	9404      	str	r4, [sp, #16]
 8003c50:	9407      	str	r4, [sp, #28]
 8003c52:	9005      	str	r0, [sp, #20]
 8003c54:	9406      	str	r4, [sp, #24]
 8003c56:	f88d 4053 	strb.w	r4, [sp, #83]	; 0x53
 8003c5a:	941a      	str	r4, [sp, #104]	; 0x68
 8003c5c:	f107 0901 	add.w	r9, r7, #1
 8003c60:	464c      	mov	r4, r9
 8003c62:	4f4f      	ldr	r7, [pc, #316]	; (8003da0 <_svfiprintf_r+0x1e0>)
 8003c64:	7821      	ldrb	r1, [r4, #0]
 8003c66:	4638      	mov	r0, r7
 8003c68:	2205      	movs	r2, #5
 8003c6a:	f000 fac5 	bl	80041f8 <memchr>
 8003c6e:	f109 0901 	add.w	r9, r9, #1
 8003c72:	9b04      	ldr	r3, [sp, #16]
 8003c74:	b130      	cbz	r0, 8003c84 <_svfiprintf_r+0xc4>
 8003c76:	1bc4      	subs	r4, r0, r7
 8003c78:	2701      	movs	r7, #1
 8003c7a:	fa07 f704 	lsl.w	r7, r7, r4
 8003c7e:	433b      	orrs	r3, r7
 8003c80:	9304      	str	r3, [sp, #16]
 8003c82:	e7ed      	b.n	8003c60 <_svfiprintf_r+0xa0>
 8003c84:	06d9      	lsls	r1, r3, #27
 8003c86:	d502      	bpl.n	8003c8e <_svfiprintf_r+0xce>
 8003c88:	2120      	movs	r1, #32
 8003c8a:	f88d 1053 	strb.w	r1, [sp, #83]	; 0x53
 8003c8e:	071a      	lsls	r2, r3, #28
 8003c90:	d502      	bpl.n	8003c98 <_svfiprintf_r+0xd8>
 8003c92:	222b      	movs	r2, #43	; 0x2b
 8003c94:	f88d 2053 	strb.w	r2, [sp, #83]	; 0x53
 8003c98:	7820      	ldrb	r0, [r4, #0]
 8003c9a:	282a      	cmp	r0, #42	; 0x2a
 8003c9c:	d002      	beq.n	8003ca4 <_svfiprintf_r+0xe4>
 8003c9e:	9b07      	ldr	r3, [sp, #28]
 8003ca0:	4627      	mov	r7, r4
 8003ca2:	e00e      	b.n	8003cc2 <_svfiprintf_r+0x102>
 8003ca4:	9a03      	ldr	r2, [sp, #12]
 8003ca6:	6817      	ldr	r7, [r2, #0]
 8003ca8:	1d10      	adds	r0, r2, #4
 8003caa:	2f00      	cmp	r7, #0
 8003cac:	9003      	str	r0, [sp, #12]
 8003cae:	db01      	blt.n	8003cb4 <_svfiprintf_r+0xf4>
 8003cb0:	9707      	str	r7, [sp, #28]
 8003cb2:	e004      	b.n	8003cbe <_svfiprintf_r+0xfe>
 8003cb4:	4279      	negs	r1, r7
 8003cb6:	f043 0302 	orr.w	r3, r3, #2
 8003cba:	9107      	str	r1, [sp, #28]
 8003cbc:	9304      	str	r3, [sp, #16]
 8003cbe:	3401      	adds	r4, #1
 8003cc0:	e00a      	b.n	8003cd8 <_svfiprintf_r+0x118>
 8003cc2:	463c      	mov	r4, r7
 8003cc4:	3701      	adds	r7, #1
 8003cc6:	7821      	ldrb	r1, [r4, #0]
 8003cc8:	3930      	subs	r1, #48	; 0x30
 8003cca:	2909      	cmp	r1, #9
 8003ccc:	d803      	bhi.n	8003cd6 <_svfiprintf_r+0x116>
 8003cce:	240a      	movs	r4, #10
 8003cd0:	fb04 1303 	mla	r3, r4, r3, r1
 8003cd4:	e7f5      	b.n	8003cc2 <_svfiprintf_r+0x102>
 8003cd6:	9307      	str	r3, [sp, #28]
 8003cd8:	7822      	ldrb	r2, [r4, #0]
 8003cda:	2a2e      	cmp	r2, #46	; 0x2e
 8003cdc:	d119      	bne.n	8003d12 <_svfiprintf_r+0x152>
 8003cde:	7860      	ldrb	r0, [r4, #1]
 8003ce0:	282a      	cmp	r0, #42	; 0x2a
 8003ce2:	d109      	bne.n	8003cf8 <_svfiprintf_r+0x138>
 8003ce4:	9803      	ldr	r0, [sp, #12]
 8003ce6:	6803      	ldr	r3, [r0, #0]
 8003ce8:	1d02      	adds	r2, r0, #4
 8003cea:	3402      	adds	r4, #2
 8003cec:	2b00      	cmp	r3, #0
 8003cee:	9203      	str	r2, [sp, #12]
 8003cf0:	bfb8      	it	lt
 8003cf2:	f04f 33ff 	movlt.w	r3, #4294967295	; 0xffffffff
 8003cf6:	e00b      	b.n	8003d10 <_svfiprintf_r+0x150>
 8003cf8:	1c67      	adds	r7, r4, #1
 8003cfa:	2300      	movs	r3, #0
 8003cfc:	463c      	mov	r4, r7
 8003cfe:	3701      	adds	r7, #1
 8003d00:	7821      	ldrb	r1, [r4, #0]
 8003d02:	3930      	subs	r1, #48	; 0x30
 8003d04:	2909      	cmp	r1, #9
 8003d06:	d803      	bhi.n	8003d10 <_svfiprintf_r+0x150>
 8003d08:	240a      	movs	r4, #10
 8003d0a:	fb04 1303 	mla	r3, r4, r3, r1
 8003d0e:	e7f5      	b.n	8003cfc <_svfiprintf_r+0x13c>
 8003d10:	9305      	str	r3, [sp, #20]
 8003d12:	4f24      	ldr	r7, [pc, #144]	; (8003da4 <_svfiprintf_r+0x1e4>)
 8003d14:	7821      	ldrb	r1, [r4, #0]
 8003d16:	4638      	mov	r0, r7
 8003d18:	2203      	movs	r2, #3
 8003d1a:	f000 fa6d 	bl	80041f8 <memchr>
 8003d1e:	b138      	cbz	r0, 8003d30 <_svfiprintf_r+0x170>
 8003d20:	9b04      	ldr	r3, [sp, #16]
 8003d22:	1bc7      	subs	r7, r0, r7
 8003d24:	2140      	movs	r1, #64	; 0x40
 8003d26:	fa01 f107 	lsl.w	r1, r1, r7
 8003d2a:	430b      	orrs	r3, r1
 8003d2c:	9304      	str	r3, [sp, #16]
 8003d2e:	3401      	adds	r4, #1
 8003d30:	f814 1b01 	ldrb.w	r1, [r4], #1
 8003d34:	481c      	ldr	r0, [pc, #112]	; (8003da8 <_svfiprintf_r+0x1e8>)
 8003d36:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
 8003d3a:	2206      	movs	r2, #6
 8003d3c:	f000 fa5c 	bl	80041f8 <memchr>
 8003d40:	b188      	cbz	r0, 8003d66 <_svfiprintf_r+0x1a6>
 8003d42:	4a1a      	ldr	r2, [pc, #104]	; (8003dac <_svfiprintf_r+0x1ec>)
 8003d44:	b932      	cbnz	r2, 8003d54 <_svfiprintf_r+0x194>
 8003d46:	9f03      	ldr	r7, [sp, #12]
 8003d48:	1dfb      	adds	r3, r7, #7
 8003d4a:	f023 0007 	bic.w	r0, r3, #7
 8003d4e:	3008      	adds	r0, #8
 8003d50:	9003      	str	r0, [sp, #12]
 8003d52:	e014      	b.n	8003d7e <_svfiprintf_r+0x1be>
 8003d54:	a903      	add	r1, sp, #12
 8003d56:	9100      	str	r1, [sp, #0]
 8003d58:	4630      	mov	r0, r6
 8003d5a:	a904      	add	r1, sp, #16
 8003d5c:	462a      	mov	r2, r5
 8003d5e:	4b14      	ldr	r3, [pc, #80]	; (8003db0 <_svfiprintf_r+0x1f0>)
 8003d60:	f3af 8000 	nop.w
 8003d64:	e007      	b.n	8003d76 <_svfiprintf_r+0x1b6>
 8003d66:	a803      	add	r0, sp, #12
 8003d68:	9000      	str	r0, [sp, #0]
 8003d6a:	a904      	add	r1, sp, #16
 8003d6c:	4630      	mov	r0, r6
 8003d6e:	462a      	mov	r2, r5
 8003d70:	4b0f      	ldr	r3, [pc, #60]	; (8003db0 <_svfiprintf_r+0x1f0>)
 8003d72:	f000 f88f 	bl	8003e94 <_printf_i>
 8003d76:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
 8003d7a:	4680      	mov	r8, r0
 8003d7c:	d004      	beq.n	8003d88 <_svfiprintf_r+0x1c8>
 8003d7e:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8003d80:	eb02 0108 	add.w	r1, r2, r8
 8003d84:	9109      	str	r1, [sp, #36]	; 0x24
 8003d86:	e73c      	b.n	8003c02 <_svfiprintf_r+0x42>
 8003d88:	89ab      	ldrh	r3, [r5, #12]
 8003d8a:	f003 0040 	and.w	r0, r3, #64	; 0x40
 8003d8e:	b202      	sxth	r2, r0
 8003d90:	b90a      	cbnz	r2, 8003d96 <_svfiprintf_r+0x1d6>
 8003d92:	9809      	ldr	r0, [sp, #36]	; 0x24
 8003d94:	e001      	b.n	8003d9a <_svfiprintf_r+0x1da>
 8003d96:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8003d9a:	b01c      	add	sp, #112	; 0x70
 8003d9c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8003da0:	0800433a 	.word	0x0800433a
 8003da4:	08004340 	.word	0x08004340
 8003da8:	08004344 	.word	0x08004344
 8003dac:	00000000 	.word	0x00000000
 8003db0:	08003b11 	.word	0x08003b11

08003db4 <_printf_common>:
 8003db4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8003db8:	4615      	mov	r5, r2
 8003dba:	4699      	mov	r9, r3
 8003dbc:	688a      	ldr	r2, [r1, #8]
 8003dbe:	690b      	ldr	r3, [r1, #16]
 8003dc0:	f8dd a020 	ldr.w	sl, [sp, #32]
 8003dc4:	429a      	cmp	r2, r3
 8003dc6:	bfa8      	it	ge
 8003dc8:	4613      	movge	r3, r2
 8003dca:	602b      	str	r3, [r5, #0]
 8003dcc:	4680      	mov	r8, r0
 8003dce:	f891 0043 	ldrb.w	r0, [r1, #67]	; 0x43
 8003dd2:	460c      	mov	r4, r1
 8003dd4:	b108      	cbz	r0, 8003dda <_printf_common+0x26>
 8003dd6:	1c59      	adds	r1, r3, #1
 8003dd8:	6029      	str	r1, [r5, #0]
 8003dda:	6826      	ldr	r6, [r4, #0]
 8003ddc:	06b2      	lsls	r2, r6, #26
 8003dde:	d502      	bpl.n	8003de6 <_printf_common+0x32>
 8003de0:	682a      	ldr	r2, [r5, #0]
 8003de2:	1c93      	adds	r3, r2, #2
 8003de4:	602b      	str	r3, [r5, #0]
 8003de6:	6820      	ldr	r0, [r4, #0]
 8003de8:	f010 0606 	ands.w	r6, r0, #6
 8003dec:	d018      	beq.n	8003e20 <_printf_common+0x6c>
 8003dee:	f894 7043 	ldrb.w	r7, [r4, #67]	; 0x43
 8003df2:	6820      	ldr	r0, [r4, #0]
 8003df4:	1c3e      	adds	r6, r7, #0
 8003df6:	bf18      	it	ne
 8003df8:	2601      	movne	r6, #1
 8003dfa:	0683      	lsls	r3, r0, #26
 8003dfc:	d51a      	bpl.n	8003e34 <_printf_common+0x80>
 8003dfe:	19a1      	adds	r1, r4, r6
 8003e00:	2230      	movs	r2, #48	; 0x30
 8003e02:	f881 2043 	strb.w	r2, [r1, #67]	; 0x43
 8003e06:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 8003e0a:	3602      	adds	r6, #2
 8003e0c:	f881 3044 	strb.w	r3, [r1, #68]	; 0x44
 8003e10:	e010      	b.n	8003e34 <_printf_common+0x80>
 8003e12:	4640      	mov	r0, r8
 8003e14:	7e61      	ldrb	r1, [r4, #25]
 8003e16:	464a      	mov	r2, r9
 8003e18:	47d0      	blx	sl
 8003e1a:	3001      	adds	r0, #1
 8003e1c:	d006      	beq.n	8003e2c <_printf_common+0x78>
 8003e1e:	3601      	adds	r6, #1
 8003e20:	68e1      	ldr	r1, [r4, #12]
 8003e22:	682a      	ldr	r2, [r5, #0]
 8003e24:	1a8b      	subs	r3, r1, r2
 8003e26:	429e      	cmp	r6, r3
 8003e28:	dbf3      	blt.n	8003e12 <_printf_common+0x5e>
 8003e2a:	e7e0      	b.n	8003dee <_printf_common+0x3a>
 8003e2c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8003e30:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8003e34:	2700      	movs	r7, #0
 8003e36:	42b7      	cmp	r7, r6
 8003e38:	da09      	bge.n	8003e4e <_printf_common+0x9a>
 8003e3a:	19e1      	adds	r1, r4, r7
 8003e3c:	4640      	mov	r0, r8
 8003e3e:	f891 1043 	ldrb.w	r1, [r1, #67]	; 0x43
 8003e42:	464a      	mov	r2, r9
 8003e44:	47d0      	blx	sl
 8003e46:	3001      	adds	r0, #1
 8003e48:	d0f0      	beq.n	8003e2c <_printf_common+0x78>
 8003e4a:	3701      	adds	r7, #1
 8003e4c:	e7f3      	b.n	8003e36 <_printf_common+0x82>
 8003e4e:	6821      	ldr	r1, [r4, #0]
 8003e50:	6828      	ldr	r0, [r5, #0]
 8003e52:	68e6      	ldr	r6, [r4, #12]
 8003e54:	6923      	ldr	r3, [r4, #16]
 8003e56:	f001 0206 	and.w	r2, r1, #6
 8003e5a:	2a04      	cmp	r2, #4
 8003e5c:	bf08      	it	eq
 8003e5e:	ebc0 0506 	rsbeq	r5, r0, r6
 8003e62:	68a6      	ldr	r6, [r4, #8]
 8003e64:	bf0c      	ite	eq
 8003e66:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
 8003e6a:	2500      	movne	r5, #0
 8003e6c:	429e      	cmp	r6, r3
 8003e6e:	bfc4      	itt	gt
 8003e70:	ebc3 0306 	rsbgt	r3, r3, r6
 8003e74:	18ed      	addgt	r5, r5, r3
 8003e76:	2600      	movs	r6, #0
 8003e78:	42ae      	cmp	r6, r5
 8003e7a:	da07      	bge.n	8003e8c <_printf_common+0xd8>
 8003e7c:	4640      	mov	r0, r8
 8003e7e:	7ea1      	ldrb	r1, [r4, #26]
 8003e80:	464a      	mov	r2, r9
 8003e82:	47d0      	blx	sl
 8003e84:	3001      	adds	r0, #1
 8003e86:	d0d1      	beq.n	8003e2c <_printf_common+0x78>
 8003e88:	3601      	adds	r6, #1
 8003e8a:	e7f5      	b.n	8003e78 <_printf_common+0xc4>
 8003e8c:	2000      	movs	r0, #0
 8003e8e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	...

08003e94 <_printf_i>:
 8003e94:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8003e98:	460c      	mov	r4, r1
 8003e9a:	b085      	sub	sp, #20
 8003e9c:	7e25      	ldrb	r5, [r4, #24]
 8003e9e:	990c      	ldr	r1, [sp, #48]	; 0x30
 8003ea0:	2d6e      	cmp	r5, #110	; 0x6e
 8003ea2:	4690      	mov	r8, r2
 8003ea4:	4607      	mov	r7, r0
 8003ea6:	4699      	mov	r9, r3
 8003ea8:	f104 0243 	add.w	r2, r4, #67	; 0x43
 8003eac:	f000 80aa 	beq.w	8004004 <_printf_i+0x170>
 8003eb0:	d812      	bhi.n	8003ed8 <_printf_i+0x44>
 8003eb2:	2d63      	cmp	r5, #99	; 0x63
 8003eb4:	d024      	beq.n	8003f00 <_printf_i+0x6c>
 8003eb6:	d809      	bhi.n	8003ecc <_printf_i+0x38>
 8003eb8:	2d00      	cmp	r5, #0
 8003eba:	f000 80bb 	beq.w	8004034 <_printf_i+0x1a0>
 8003ebe:	2d58      	cmp	r5, #88	; 0x58
 8003ec0:	f040 80cb 	bne.w	800405a <_printf_i+0x1c6>
 8003ec4:	f884 5045 	strb.w	r5, [r4, #69]	; 0x45
 8003ec8:	4d82      	ldr	r5, [pc, #520]	; (80040d4 <_printf_i+0x240>)
 8003eca:	e057      	b.n	8003f7c <_printf_i+0xe8>
 8003ecc:	2d64      	cmp	r5, #100	; 0x64
 8003ece:	d020      	beq.n	8003f12 <_printf_i+0x7e>
 8003ed0:	2d69      	cmp	r5, #105	; 0x69
 8003ed2:	f040 80c2 	bne.w	800405a <_printf_i+0x1c6>
 8003ed6:	e01c      	b.n	8003f12 <_printf_i+0x7e>
 8003ed8:	2d73      	cmp	r5, #115	; 0x73
 8003eda:	f000 80af 	beq.w	800403c <_printf_i+0x1a8>
 8003ede:	d809      	bhi.n	8003ef4 <_printf_i+0x60>
 8003ee0:	2d6f      	cmp	r5, #111	; 0x6f
 8003ee2:	d02f      	beq.n	8003f44 <_printf_i+0xb0>
 8003ee4:	2d70      	cmp	r5, #112	; 0x70
 8003ee6:	f040 80b8 	bne.w	800405a <_printf_i+0x1c6>
 8003eea:	6825      	ldr	r5, [r4, #0]
 8003eec:	f045 0620 	orr.w	r6, r5, #32
 8003ef0:	6026      	str	r6, [r4, #0]
 8003ef2:	e03f      	b.n	8003f74 <_printf_i+0xe0>
 8003ef4:	2d75      	cmp	r5, #117	; 0x75
 8003ef6:	d025      	beq.n	8003f44 <_printf_i+0xb0>
 8003ef8:	2d78      	cmp	r5, #120	; 0x78
 8003efa:	f040 80ae 	bne.w	800405a <_printf_i+0x1c6>
 8003efe:	e039      	b.n	8003f74 <_printf_i+0xe0>
 8003f00:	6808      	ldr	r0, [r1, #0]
 8003f02:	1d02      	adds	r2, r0, #4
 8003f04:	600a      	str	r2, [r1, #0]
 8003f06:	6801      	ldr	r1, [r0, #0]
 8003f08:	f104 0642 	add.w	r6, r4, #66	; 0x42
 8003f0c:	f884 1042 	strb.w	r1, [r4, #66]	; 0x42
 8003f10:	e0a7      	b.n	8004062 <_printf_i+0x1ce>
 8003f12:	6820      	ldr	r0, [r4, #0]
 8003f14:	680b      	ldr	r3, [r1, #0]
 8003f16:	f010 0f80 	tst.w	r0, #128	; 0x80
 8003f1a:	d002      	beq.n	8003f22 <_printf_i+0x8e>
 8003f1c:	1d1e      	adds	r6, r3, #4
 8003f1e:	600e      	str	r6, [r1, #0]
 8003f20:	e008      	b.n	8003f34 <_printf_i+0xa0>
 8003f22:	f103 0504 	add.w	r5, r3, #4
 8003f26:	f010 0f40 	tst.w	r0, #64	; 0x40
 8003f2a:	600d      	str	r5, [r1, #0]
 8003f2c:	d002      	beq.n	8003f34 <_printf_i+0xa0>
 8003f2e:	f9b3 1000 	ldrsh.w	r1, [r3]
 8003f32:	e000      	b.n	8003f36 <_printf_i+0xa2>
 8003f34:	6819      	ldr	r1, [r3, #0]
 8003f36:	2900      	cmp	r1, #0
 8003f38:	da3c      	bge.n	8003fb4 <_printf_i+0x120>
 8003f3a:	202d      	movs	r0, #45	; 0x2d
 8003f3c:	4249      	negs	r1, r1
 8003f3e:	f884 0043 	strb.w	r0, [r4, #67]	; 0x43
 8003f42:	e037      	b.n	8003fb4 <_printf_i+0x120>
 8003f44:	6825      	ldr	r5, [r4, #0]
 8003f46:	680e      	ldr	r6, [r1, #0]
 8003f48:	f015 0f80 	tst.w	r5, #128	; 0x80
 8003f4c:	d002      	beq.n	8003f54 <_printf_i+0xc0>
 8003f4e:	1d33      	adds	r3, r6, #4
 8003f50:	600b      	str	r3, [r1, #0]
 8003f52:	e007      	b.n	8003f64 <_printf_i+0xd0>
 8003f54:	f106 0004 	add.w	r0, r6, #4
 8003f58:	f015 0f40 	tst.w	r5, #64	; 0x40
 8003f5c:	6008      	str	r0, [r1, #0]
 8003f5e:	d001      	beq.n	8003f64 <_printf_i+0xd0>
 8003f60:	8831      	ldrh	r1, [r6, #0]
 8003f62:	e000      	b.n	8003f66 <_printf_i+0xd2>
 8003f64:	6831      	ldr	r1, [r6, #0]
 8003f66:	7e26      	ldrb	r6, [r4, #24]
 8003f68:	4d5a      	ldr	r5, [pc, #360]	; (80040d4 <_printf_i+0x240>)
 8003f6a:	2e6f      	cmp	r6, #111	; 0x6f
 8003f6c:	bf14      	ite	ne
 8003f6e:	230a      	movne	r3, #10
 8003f70:	2308      	moveq	r3, #8
 8003f72:	e01b      	b.n	8003fac <_printf_i+0x118>
 8003f74:	2078      	movs	r0, #120	; 0x78
 8003f76:	4d58      	ldr	r5, [pc, #352]	; (80040d8 <_printf_i+0x244>)
 8003f78:	f884 0045 	strb.w	r0, [r4, #69]	; 0x45
 8003f7c:	6820      	ldr	r0, [r4, #0]
 8003f7e:	680b      	ldr	r3, [r1, #0]
 8003f80:	f010 0f80 	tst.w	r0, #128	; 0x80
 8003f84:	f103 0604 	add.w	r6, r3, #4
 8003f88:	600e      	str	r6, [r1, #0]
 8003f8a:	d103      	bne.n	8003f94 <_printf_i+0x100>
 8003f8c:	0641      	lsls	r1, r0, #25
 8003f8e:	d501      	bpl.n	8003f94 <_printf_i+0x100>
 8003f90:	8819      	ldrh	r1, [r3, #0]
 8003f92:	e000      	b.n	8003f96 <_printf_i+0x102>
 8003f94:	6819      	ldr	r1, [r3, #0]
 8003f96:	07c6      	lsls	r6, r0, #31
 8003f98:	bf44      	itt	mi
 8003f9a:	f040 0020 	orrmi.w	r0, r0, #32
 8003f9e:	6020      	strmi	r0, [r4, #0]
 8003fa0:	b919      	cbnz	r1, 8003faa <_printf_i+0x116>
 8003fa2:	6820      	ldr	r0, [r4, #0]
 8003fa4:	f020 0320 	bic.w	r3, r0, #32
 8003fa8:	6023      	str	r3, [r4, #0]
 8003faa:	2310      	movs	r3, #16
 8003fac:	2000      	movs	r0, #0
 8003fae:	f884 0043 	strb.w	r0, [r4, #67]	; 0x43
 8003fb2:	e001      	b.n	8003fb8 <_printf_i+0x124>
 8003fb4:	4d47      	ldr	r5, [pc, #284]	; (80040d4 <_printf_i+0x240>)
 8003fb6:	230a      	movs	r3, #10
 8003fb8:	6866      	ldr	r6, [r4, #4]
 8003fba:	2e00      	cmp	r6, #0
 8003fbc:	60a6      	str	r6, [r4, #8]
 8003fbe:	db03      	blt.n	8003fc8 <_printf_i+0x134>
 8003fc0:	6820      	ldr	r0, [r4, #0]
 8003fc2:	f020 0004 	bic.w	r0, r0, #4
 8003fc6:	6020      	str	r0, [r4, #0]
 8003fc8:	b901      	cbnz	r1, 8003fcc <_printf_i+0x138>
 8003fca:	b16e      	cbz	r6, 8003fe8 <_printf_i+0x154>
 8003fcc:	f104 0042 	add.w	r0, r4, #66	; 0x42
 8003fd0:	fbb1 fef3 	udiv	lr, r1, r3
 8003fd4:	fb03 111e 	mls	r1, r3, lr, r1
 8003fd8:	4606      	mov	r6, r0
 8003fda:	5c69      	ldrb	r1, [r5, r1]
 8003fdc:	f800 1901 	strb.w	r1, [r0], #-1
 8003fe0:	4671      	mov	r1, lr
 8003fe2:	2900      	cmp	r1, #0
 8003fe4:	d1f4      	bne.n	8003fd0 <_printf_i+0x13c>
 8003fe6:	e000      	b.n	8003fea <_printf_i+0x156>
 8003fe8:	4616      	mov	r6, r2
 8003fea:	1b92      	subs	r2, r2, r6
 8003fec:	2b08      	cmp	r3, #8
 8003fee:	6122      	str	r2, [r4, #16]
 8003ff0:	d13c      	bne.n	800406c <_printf_i+0x1d8>
 8003ff2:	6823      	ldr	r3, [r4, #0]
 8003ff4:	07d8      	lsls	r0, r3, #31
 8003ff6:	d539      	bpl.n	800406c <_printf_i+0x1d8>
 8003ff8:	6860      	ldr	r0, [r4, #4]
 8003ffa:	4290      	cmp	r0, r2
 8003ffc:	dc36      	bgt.n	800406c <_printf_i+0x1d8>
 8003ffe:	1c51      	adds	r1, r2, #1
 8004000:	6061      	str	r1, [r4, #4]
 8004002:	e033      	b.n	800406c <_printf_i+0x1d8>
 8004004:	6826      	ldr	r6, [r4, #0]
 8004006:	680b      	ldr	r3, [r1, #0]
 8004008:	f016 0f80 	tst.w	r6, #128	; 0x80
 800400c:	d005      	beq.n	800401a <_printf_i+0x186>
 800400e:	1d1e      	adds	r6, r3, #4
 8004010:	600e      	str	r6, [r1, #0]
 8004012:	6819      	ldr	r1, [r3, #0]
 8004014:	6960      	ldr	r0, [r4, #20]
 8004016:	6008      	str	r0, [r1, #0]
 8004018:	e00c      	b.n	8004034 <_printf_i+0x1a0>
 800401a:	f103 0004 	add.w	r0, r3, #4
 800401e:	f016 0f40 	tst.w	r6, #64	; 0x40
 8004022:	6008      	str	r0, [r1, #0]
 8004024:	d003      	beq.n	800402e <_printf_i+0x19a>
 8004026:	6818      	ldr	r0, [r3, #0]
 8004028:	6963      	ldr	r3, [r4, #20]
 800402a:	8003      	strh	r3, [r0, #0]
 800402c:	e002      	b.n	8004034 <_printf_i+0x1a0>
 800402e:	6961      	ldr	r1, [r4, #20]
 8004030:	681e      	ldr	r6, [r3, #0]
 8004032:	6031      	str	r1, [r6, #0]
 8004034:	2300      	movs	r3, #0
 8004036:	6123      	str	r3, [r4, #16]
 8004038:	4616      	mov	r6, r2
 800403a:	e017      	b.n	800406c <_printf_i+0x1d8>
 800403c:	680e      	ldr	r6, [r1, #0]
 800403e:	1d32      	adds	r2, r6, #4
 8004040:	600a      	str	r2, [r1, #0]
 8004042:	6836      	ldr	r6, [r6, #0]
 8004044:	4630      	mov	r0, r6
 8004046:	f000 f919 	bl	800427c <strlen>
 800404a:	6863      	ldr	r3, [r4, #4]
 800404c:	6120      	str	r0, [r4, #16]
 800404e:	4298      	cmp	r0, r3
 8004050:	bf88      	it	hi
 8004052:	6123      	strhi	r3, [r4, #16]
 8004054:	6920      	ldr	r0, [r4, #16]
 8004056:	6060      	str	r0, [r4, #4]
 8004058:	e005      	b.n	8004066 <_printf_i+0x1d2>
 800405a:	f104 0642 	add.w	r6, r4, #66	; 0x42
 800405e:	f884 5042 	strb.w	r5, [r4, #66]	; 0x42
 8004062:	2301      	movs	r3, #1
 8004064:	6123      	str	r3, [r4, #16]
 8004066:	2100      	movs	r1, #0
 8004068:	f884 1043 	strb.w	r1, [r4, #67]	; 0x43
 800406c:	f8cd 9000 	str.w	r9, [sp]
 8004070:	4638      	mov	r0, r7
 8004072:	4621      	mov	r1, r4
 8004074:	aa03      	add	r2, sp, #12
 8004076:	4643      	mov	r3, r8
 8004078:	f7ff fe9c 	bl	8003db4 <_printf_common>
 800407c:	3001      	adds	r0, #1
 800407e:	d102      	bne.n	8004086 <_printf_i+0x1f2>
 8004080:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8004084:	e022      	b.n	80040cc <_printf_i+0x238>
 8004086:	2500      	movs	r5, #0
 8004088:	6922      	ldr	r2, [r4, #16]
 800408a:	4295      	cmp	r5, r2
 800408c:	da07      	bge.n	800409e <_printf_i+0x20a>
 800408e:	4638      	mov	r0, r7
 8004090:	5d71      	ldrb	r1, [r6, r5]
 8004092:	4642      	mov	r2, r8
 8004094:	47c8      	blx	r9
 8004096:	3001      	adds	r0, #1
 8004098:	d0f2      	beq.n	8004080 <_printf_i+0x1ec>
 800409a:	3501      	adds	r5, #1
 800409c:	e7f4      	b.n	8004088 <_printf_i+0x1f4>
 800409e:	6821      	ldr	r1, [r4, #0]
 80040a0:	0789      	lsls	r1, r1, #30
 80040a2:	d405      	bmi.n	80040b0 <_printf_i+0x21c>
 80040a4:	68e0      	ldr	r0, [r4, #12]
 80040a6:	9903      	ldr	r1, [sp, #12]
 80040a8:	4288      	cmp	r0, r1
 80040aa:	bfb8      	it	lt
 80040ac:	4608      	movlt	r0, r1
 80040ae:	e00d      	b.n	80040cc <_printf_i+0x238>
 80040b0:	2500      	movs	r5, #0
 80040b2:	68e0      	ldr	r0, [r4, #12]
 80040b4:	9b03      	ldr	r3, [sp, #12]
 80040b6:	1ac2      	subs	r2, r0, r3
 80040b8:	4295      	cmp	r5, r2
 80040ba:	daf3      	bge.n	80040a4 <_printf_i+0x210>
 80040bc:	4638      	mov	r0, r7
 80040be:	7e61      	ldrb	r1, [r4, #25]
 80040c0:	4642      	mov	r2, r8
 80040c2:	47c8      	blx	r9
 80040c4:	3001      	adds	r0, #1
 80040c6:	d0db      	beq.n	8004080 <_printf_i+0x1ec>
 80040c8:	3501      	adds	r5, #1
 80040ca:	e7f2      	b.n	80040b2 <_printf_i+0x21e>
 80040cc:	b005      	add	sp, #20
 80040ce:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80040d2:	bf00      	nop
 80040d4:	0800434b 	.word	0x0800434b
 80040d8:	0800435c 	.word	0x0800435c

080040dc <_free_r>:
 80040dc:	b530      	push	{r4, r5, lr}
 80040de:	2900      	cmp	r1, #0
 80040e0:	d03c      	beq.n	800415c <_free_r+0x80>
 80040e2:	f851 2c04 	ldr.w	r2, [r1, #-4]
 80040e6:	1f0b      	subs	r3, r1, #4
 80040e8:	491d      	ldr	r1, [pc, #116]	; (8004160 <_free_r+0x84>)
 80040ea:	2a00      	cmp	r2, #0
 80040ec:	bfb8      	it	lt
 80040ee:	189b      	addlt	r3, r3, r2
 80040f0:	680a      	ldr	r2, [r1, #0]
 80040f2:	b912      	cbnz	r2, 80040fa <_free_r+0x1e>
 80040f4:	605a      	str	r2, [r3, #4]
 80040f6:	600b      	str	r3, [r1, #0]
 80040f8:	bd30      	pop	{r4, r5, pc}
 80040fa:	4293      	cmp	r3, r2
 80040fc:	d20e      	bcs.n	800411c <_free_r+0x40>
 80040fe:	6819      	ldr	r1, [r3, #0]
 8004100:	1858      	adds	r0, r3, r1
 8004102:	4290      	cmp	r0, r2
 8004104:	d103      	bne.n	800410e <_free_r+0x32>
 8004106:	585a      	ldr	r2, [r3, r1]
 8004108:	1889      	adds	r1, r1, r2
 800410a:	6842      	ldr	r2, [r0, #4]
 800410c:	6019      	str	r1, [r3, #0]
 800410e:	4814      	ldr	r0, [pc, #80]	; (8004160 <_free_r+0x84>)
 8004110:	605a      	str	r2, [r3, #4]
 8004112:	6003      	str	r3, [r0, #0]
 8004114:	bd30      	pop	{r4, r5, pc}
 8004116:	4299      	cmp	r1, r3
 8004118:	d803      	bhi.n	8004122 <_free_r+0x46>
 800411a:	460a      	mov	r2, r1
 800411c:	6851      	ldr	r1, [r2, #4]
 800411e:	2900      	cmp	r1, #0
 8004120:	d1f9      	bne.n	8004116 <_free_r+0x3a>
 8004122:	6814      	ldr	r4, [r2, #0]
 8004124:	1915      	adds	r5, r2, r4
 8004126:	429d      	cmp	r5, r3
 8004128:	d10a      	bne.n	8004140 <_free_r+0x64>
 800412a:	6818      	ldr	r0, [r3, #0]
 800412c:	1823      	adds	r3, r4, r0
 800412e:	18d0      	adds	r0, r2, r3
 8004130:	4288      	cmp	r0, r1
 8004132:	6013      	str	r3, [r2, #0]
 8004134:	d112      	bne.n	800415c <_free_r+0x80>
 8004136:	6808      	ldr	r0, [r1, #0]
 8004138:	181b      	adds	r3, r3, r0
 800413a:	6013      	str	r3, [r2, #0]
 800413c:	684b      	ldr	r3, [r1, #4]
 800413e:	e00c      	b.n	800415a <_free_r+0x7e>
 8004140:	d902      	bls.n	8004148 <_free_r+0x6c>
 8004142:	230c      	movs	r3, #12
 8004144:	6003      	str	r3, [r0, #0]
 8004146:	bd30      	pop	{r4, r5, pc}
 8004148:	6818      	ldr	r0, [r3, #0]
 800414a:	181c      	adds	r4, r3, r0
 800414c:	428c      	cmp	r4, r1
 800414e:	d103      	bne.n	8004158 <_free_r+0x7c>
 8004150:	680c      	ldr	r4, [r1, #0]
 8004152:	6849      	ldr	r1, [r1, #4]
 8004154:	1900      	adds	r0, r0, r4
 8004156:	6018      	str	r0, [r3, #0]
 8004158:	6059      	str	r1, [r3, #4]
 800415a:	6053      	str	r3, [r2, #4]
 800415c:	bd30      	pop	{r4, r5, pc}
 800415e:	bf00      	nop
 8004160:	20012e14 	.word	0x20012e14

08004164 <_malloc_r>:
 8004164:	b570      	push	{r4, r5, r6, lr}
 8004166:	1ccd      	adds	r5, r1, #3
 8004168:	f025 0503 	bic.w	r5, r5, #3
 800416c:	3508      	adds	r5, #8
 800416e:	2d0c      	cmp	r5, #12
 8004170:	bf38      	it	cc
 8004172:	250c      	movcc	r5, #12
 8004174:	2d00      	cmp	r5, #0
 8004176:	4606      	mov	r6, r0
 8004178:	db2d      	blt.n	80041d6 <_malloc_r+0x72>
 800417a:	428d      	cmp	r5, r1
 800417c:	d32b      	bcc.n	80041d6 <_malloc_r+0x72>
 800417e:	4b1d      	ldr	r3, [pc, #116]	; (80041f4 <_malloc_r+0x90>)
 8004180:	681b      	ldr	r3, [r3, #0]
 8004182:	461c      	mov	r4, r3
 8004184:	b19c      	cbz	r4, 80041ae <_malloc_r+0x4a>
 8004186:	6822      	ldr	r2, [r4, #0]
 8004188:	1b50      	subs	r0, r2, r5
 800418a:	d40d      	bmi.n	80041a8 <_malloc_r+0x44>
 800418c:	280b      	cmp	r0, #11
 800418e:	d902      	bls.n	8004196 <_malloc_r+0x32>
 8004190:	6020      	str	r0, [r4, #0]
 8004192:	1824      	adds	r4, r4, r0
 8004194:	e017      	b.n	80041c6 <_malloc_r+0x62>
 8004196:	42a3      	cmp	r3, r4
 8004198:	d103      	bne.n	80041a2 <_malloc_r+0x3e>
 800419a:	6860      	ldr	r0, [r4, #4]
 800419c:	4a15      	ldr	r2, [pc, #84]	; (80041f4 <_malloc_r+0x90>)
 800419e:	6010      	str	r0, [r2, #0]
 80041a0:	e01d      	b.n	80041de <_malloc_r+0x7a>
 80041a2:	6861      	ldr	r1, [r4, #4]
 80041a4:	6059      	str	r1, [r3, #4]
 80041a6:	e01a      	b.n	80041de <_malloc_r+0x7a>
 80041a8:	4623      	mov	r3, r4
 80041aa:	6864      	ldr	r4, [r4, #4]
 80041ac:	e7ea      	b.n	8004184 <_malloc_r+0x20>
 80041ae:	4629      	mov	r1, r5
 80041b0:	4630      	mov	r0, r6
 80041b2:	f000 f853 	bl	800425c <_sbrk_r>
 80041b6:	1c43      	adds	r3, r0, #1
 80041b8:	4601      	mov	r1, r0
 80041ba:	d00c      	beq.n	80041d6 <_malloc_r+0x72>
 80041bc:	1ccc      	adds	r4, r1, #3
 80041be:	f024 0403 	bic.w	r4, r4, #3
 80041c2:	428c      	cmp	r4, r1
 80041c4:	d101      	bne.n	80041ca <_malloc_r+0x66>
 80041c6:	6025      	str	r5, [r4, #0]
 80041c8:	e009      	b.n	80041de <_malloc_r+0x7a>
 80041ca:	4630      	mov	r0, r6
 80041cc:	1a61      	subs	r1, r4, r1
 80041ce:	f000 f845 	bl	800425c <_sbrk_r>
 80041d2:	3001      	adds	r0, #1
 80041d4:	d1f7      	bne.n	80041c6 <_malloc_r+0x62>
 80041d6:	200c      	movs	r0, #12
 80041d8:	6030      	str	r0, [r6, #0]
 80041da:	2000      	movs	r0, #0
 80041dc:	bd70      	pop	{r4, r5, r6, pc}
 80041de:	f104 010b 	add.w	r1, r4, #11
 80041e2:	1d23      	adds	r3, r4, #4
 80041e4:	f021 0007 	bic.w	r0, r1, #7
 80041e8:	1ac3      	subs	r3, r0, r3
 80041ea:	d002      	beq.n	80041f2 <_malloc_r+0x8e>
 80041ec:	425a      	negs	r2, r3
 80041ee:	50e2      	str	r2, [r4, r3]
 80041f0:	bd70      	pop	{r4, r5, r6, pc}
 80041f2:	bd70      	pop	{r4, r5, r6, pc}
 80041f4:	20012e14 	.word	0x20012e14

080041f8 <memchr>:
 80041f8:	b510      	push	{r4, lr}
 80041fa:	b2c9      	uxtb	r1, r1
 80041fc:	4603      	mov	r3, r0
 80041fe:	1882      	adds	r2, r0, r2
 8004200:	4293      	cmp	r3, r2
 8004202:	4618      	mov	r0, r3
 8004204:	d004      	beq.n	8004210 <memchr+0x18>
 8004206:	7804      	ldrb	r4, [r0, #0]
 8004208:	3301      	adds	r3, #1
 800420a:	428c      	cmp	r4, r1
 800420c:	d1f8      	bne.n	8004200 <memchr+0x8>
 800420e:	e000      	b.n	8004212 <memchr+0x1a>
 8004210:	2000      	movs	r0, #0
 8004212:	bd10      	pop	{r4, pc}

08004214 <_realloc_r>:
 8004214:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8004216:	4606      	mov	r6, r0
 8004218:	4615      	mov	r5, r2
 800421a:	460c      	mov	r4, r1
 800421c:	b921      	cbnz	r1, 8004228 <_realloc_r+0x14>
 800421e:	4611      	mov	r1, r2
 8004220:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
 8004224:	f7ff bf9e 	b.w	8004164 <_malloc_r>
 8004228:	b91a      	cbnz	r2, 8004232 <_realloc_r+0x1e>
 800422a:	f7ff ff57 	bl	80040dc <_free_r>
 800422e:	462c      	mov	r4, r5
 8004230:	e012      	b.n	8004258 <_realloc_r+0x44>
 8004232:	f000 f82b 	bl	800428c <_malloc_usable_size_r>
 8004236:	42a8      	cmp	r0, r5
 8004238:	d20e      	bcs.n	8004258 <_realloc_r+0x44>
 800423a:	4630      	mov	r0, r6
 800423c:	4629      	mov	r1, r5
 800423e:	f7ff ff91 	bl	8004164 <_malloc_r>
 8004242:	4607      	mov	r7, r0
 8004244:	b138      	cbz	r0, 8004256 <_realloc_r+0x42>
 8004246:	4621      	mov	r1, r4
 8004248:	462a      	mov	r2, r5
 800424a:	f7ff fc0a 	bl	8003a62 <memcpy>
 800424e:	4630      	mov	r0, r6
 8004250:	4621      	mov	r1, r4
 8004252:	f7ff ff43 	bl	80040dc <_free_r>
 8004256:	463c      	mov	r4, r7
 8004258:	4620      	mov	r0, r4
 800425a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0800425c <_sbrk_r>:
 800425c:	b538      	push	{r3, r4, r5, lr}
 800425e:	4c06      	ldr	r4, [pc, #24]	; (8004278 <_sbrk_r+0x1c>)
 8004260:	2300      	movs	r3, #0
 8004262:	4605      	mov	r5, r0
 8004264:	4608      	mov	r0, r1
 8004266:	6023      	str	r3, [r4, #0]
 8004268:	f7fd fb0c 	bl	8001884 <_sbrk>
 800426c:	1c43      	adds	r3, r0, #1
 800426e:	d102      	bne.n	8004276 <_sbrk_r+0x1a>
 8004270:	6821      	ldr	r1, [r4, #0]
 8004272:	b101      	cbz	r1, 8004276 <_sbrk_r+0x1a>
 8004274:	6029      	str	r1, [r5, #0]
 8004276:	bd38      	pop	{r3, r4, r5, pc}
 8004278:	20012e58 	.word	0x20012e58

0800427c <strlen>:
 800427c:	4603      	mov	r3, r0
 800427e:	f813 2b01 	ldrb.w	r2, [r3], #1
 8004282:	2a00      	cmp	r2, #0
 8004284:	d1fb      	bne.n	800427e <strlen+0x2>
 8004286:	1a18      	subs	r0, r3, r0
 8004288:	3801      	subs	r0, #1
 800428a:	4770      	bx	lr

0800428c <_malloc_usable_size_r>:
 800428c:	f851 0c04 	ldr.w	r0, [r1, #-4]
 8004290:	2800      	cmp	r0, #0
 8004292:	da02      	bge.n	800429a <_malloc_usable_size_r+0xe>
 8004294:	3904      	subs	r1, #4
 8004296:	580b      	ldr	r3, [r1, r0]
 8004298:	18c0      	adds	r0, r0, r3
 800429a:	3804      	subs	r0, #4
 800429c:	4770      	bx	lr

0800429e <heapSTRUCT_SIZE>:
 800429e:	0010 6554 7473 0031 0000 454c 5f44 6c42     ..Test1...LED_Bl
 80042ae:	6e69 006b 0000 4449 454c 0000 0000 0a0d     ink...IDLE......
 80042be:	0000 7325 0909 6325 2509 0975 7525 2509     ..%s..%c.%u.%u.%
 80042ce:	0d75 000a 0000                              u.....

080042d4 <ucExpectedStackBytes.5486>:
 80042d4:	a5a5 a5a5 a5a5 a5a5 a5a5 a5a5 a5a5 a5a5     ................
 80042e4:	a5a5 a5a5 6d54 2072 7653 0063               ....Tmr Svc.

080042f0 <hse_8mhz_3v3>:
 80042f0:	0008 0060 0202 0000 0603 0000 0500 0104     ..`.............
 8004300:	1b00 00b7 3600 016e 0008 00f0 0502 0000     .....6n.........
 8004310:	0603 0000 0500 0104 c380 01c9 8700 0393     ................
 8004320:	0008 0150 0702 0000 0605 0000 0500 0004     ..P.............
 8004330:	de80 0280 bd00 0501 0043 2d23 2b30 0020     ........C.#-0+ .
 8004340:	6c68 004c 6665 4567 4746 3000 3231 3433     hlL.efgEFG.01234
 8004350:	3635 3837 4139 4342 4544 0046 3130 3332     56789ABCDEF.0123
 8004360:	3534 3736 3938 6261 6463 6665 0000               456789abcdef.
